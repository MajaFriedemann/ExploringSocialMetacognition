<!DOCTYPE html>
<html>
<head>
    <title>Advisor Choice Experiment</title>

    <script src="https://www.gstatic.com/charts/loader.js"></script>
    <script src="../src/sha1.js"></script>
    <script src="https://mjaquiery.github.io/jsPsych/jspsych.js"></script>
    <script src="https://mjaquiery.github.io/jsPsych/plugins/jspsych-instructions.js"></script>
    <script src="https://mjaquiery.github.io/jsPsych/plugins/jspsych-html-keyboard-response.js"></script>
    <!--local dev versions of jsPsych-->
    <!--script src="../jsPsych/jspsych.js"></script>
    <script src="../jsPsych/plugins/jspsych-instructions.js"></script>
    <script src="../jsPsych/plugins/jspsych-html-keyboard-response.js"></script>
    <script src="../jsPsych/plugins/jspsych-canvas-sliders-response.js"></script-->
    <script src="../src/bowser.min.js"></script>
    <script src="../src/jspsych-function-sliders-response.js"></script>
    <script src="../src/jspsych-jas-present-advice-choice.js"></script>
    <script src="../src/jspsych-canvas-sliders-response.js"></script>

    <link rel="stylesheet" href="../style/advisorChoice.css"/>
    <link rel="stylesheet" href="https://mjaquiery.github.io/jsPsych/css/jspsych.css"/>
    <link rel="stylesheet" href="../style/confidenceSliders.css"/>
    <link rel="stylesheet" href="../style/feedbackStyle.css"/>
    <link rel="stylesheet" href="../style/debriefForm.css"/>

    <style type="text/css">
        :root {
            --content-height: 500;
            --content-width: 900;

            --tag-border-radius: 0.5em;

            --advisor-1-p: 169, 5, 255;
            --advisor-1-primary: rgb(var(--advisor-1-p));
            --advisor-1-s: 82, 5, 146;
            --advisor-1-secondary: rgb(var(--advisor-1-s));
            --advisor-2-p: 255, 107, 0;
            --advisor-2-primary: rgb(var(--advisor-2-p));
            --advisor-2-s: 155, 68, 0;
            --advisor-2-secondary: rgb(var(--advisor-2-s));

            --group-1-p: 132, 191, 255;
            --group-1-primary: rgb(var(--group-1-p));
            --group-1-s: 16, 78, 145;
            --group-1-secondary: rgb(var(--group-1-s));
            --group-2-p: 23, 211, 69;
            --group-2-primary: rgb(var(--group-2-p));
            --group-2-s: 8, 123, 36;
            --group-2-secondary: rgb(var(--group-2-s));

            --response-label-padding: 5px;
            --response-maker-width: 40px;
            --response-marker-height: 30px;
            --response-vBar-offset: 65px;
            --response-bar-thickness: 25px;

            --min-opacity: 0.4;
        }

        body {
            background-color: white;
        }
        div {
            position: relative;
        }

        .hidden {
            display: none;
        }

        :root{
            --esm-help-width: 250px;
            --esm-help-arrowSize: 5px;
            --esm-help-backgroundColor: #f9f6ac;
            --esm-help-borderColor: black;
        }
        esm-help {
            width: var(--esm-help-width);
            position: absolute;
            z-index: 1000;
            background-color: var(--esm-help-backgroundColor);
            color: #000000;
            text-align: center;
            padding: 5px 0;
            border-radius: 6px;
            border: 1px solid var(--esm-help-borderColor);
            font-size: 0.8em;
            cursor: pointer;
            overflow: visible;
            line-height: 1.2em;
        }
        esm-help:not(.top):not(.bottom):not(.left):not(.right) {
            top: 50%;
            left: calc(50% - var(--esm-help-width) / 2);
            transform: translateY(-50%);
        }
        esm-help::after {
            content: " ";
            position: absolute;
            margin-left: calc(var(--esm-help-arrowSize) * -1);
            border-width: var(--esm-help-arrowSize);
            border-style: solid;
            border-color: transparent;
        }
        esm-help.top {
            left: calc(50% - var(--esm-help-width) / 2);
            bottom: calc(100% + var(--esm-help-arrowSize));
        }
        esm-help.top::after {
            top: 100%;
            left: 50%;
            border-top-color: var(--esm-help-borderColor);
        }
        esm-help.bottom {
            left: calc(50% - var(--esm-help-width) / 2);
            top: calc(100% + var(--esm-help-arrowSize));
        }
        esm-help.bottom::after {
            bottom: 100%;
            left: 50%;
            border-bottom-color: var(--esm-help-borderColor);
        }
        esm-help.left {
            right: calc(100% + var(--esm-help-arrowSize));
            top: 50%;
            transform: translateY(-50%);
        }
        esm-help.left::after {
            left: 102%;
            top: calc(50% - var(--esm-help-arrowSize));
            border-left-color: var(--esm-help-borderColor);
        }
        esm-help.right {
            left: calc(100% + var(--esm-help-arrowSize));
            top: 50%;
            transform: translateY(-50%);
        }
        esm-help.right::after {
            right: 100%;
            top: calc(50% - var(--esm-help-arrowSize));
            border-right-color: var(--esm-help-borderColor);
        }
        .esm-help-enabled {
            cursor: pointer;
        }
        .esm-help-enabled:hover::before {
            background-color: var(--esm-help-backgroundColor);
            outline: 1px solid var(--esm-help-borderColor);
            content: "";
            width: calc(100% + var(--esm-help-arrowSize) * 2);
            position: absolute;
            height: calc(100% + var(--esm-help-arrowSize) * 2);
            margin: var(--esm-help-arrowSize);
            top: calc(var(--esm-help-arrowSize) * -2);
            left: calc(var(--esm-help-arrowSize) * -2);
            opacity: .5;
            z-index: -1;
        }

        #jspsych-content {
            height: calc(var(--content-height) * 1px);
            width: calc(var(--content-width) * 1px);
            max-width: 100%;
            display: flex;
            flex-direction: column;
            border: 4px solid black;
            border-radius: 5px;
        }

        #jspsych-content > .frame {
            display: inline-flex;
            flex-wrap: nowrap;
            flex-direction: row;
            justify-content: space-between;
        }

        #jspsych-content > .frame.top {
            height: 60rem;
            margin-top: .2em;
        }

        #jspsych-content > .frame.bottom {
            height: 40rem;
        }

        #jspsych-content > .frame > .left,
        #jspsych-content > .frame > .right {
            width: 100%;
            display: flex;
            flex-direction: column;
            margin: auto;
        }

        #stimulus {
            height: calc(var(--content-height) * 1px / 2);
            width: calc(var(--content-width) * 1px / 2);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            opacity: 1;
        }
        #stimulus.cloak {
            opacity: 0;
        }
        #stimulus * {
            max-height: 100%;
        }
        #stimulus > *:first-child {
            margin: auto;
        }

        #prompt {
            margin: .25em 0;
            font-size: 1.2em;
        }

        #response-panel {
            height: 100%;
            width: 100%;
            display: flex;
            flex-direction: column;
            transition: opacity 0.5s;
        }
        #response-panel.cloak {
            opacity: 0.3;
        }

        .progress-bar {
            display: block;
            height: .2em;
            width: 99%;
            margin: 2px auto;
        }
        .progress-bar .outer {
            height: 100%;
            width: 75%;
            border: 1px solid transparent;
            background-color: #00ccfc;
        }
        .progress-bar .inner {
        }

        .advisor-key-row {
            display: flex;
            line-height: 2em;
            padding: .25em;
            margin: 0 0 .5em 0;
        }
        .left > .advisor-key-row {
            border-top-right-radius: var(--tag-border-radius);
            border-bottom-right-radius: var(--tag-border-radius);
            box-shadow: 1px 1px 1px 0 black;
        }
        .right > .advisor-key-row {
            border-top-left-radius: var(--tag-border-radius);
            border-bottom-left-radius: var(--tag-border-radius);
            box-shadow: -1px 1px 1px 0 black;
        }

        .marker {
            width: 1em;
            height: 1em;
            border-radius: 1em;
            border: 1px solid;
            margin: .5em;
        }

        .advisor-bg-1 {
            background-color: var(--advisor-1-primary);
        }
        .advisor-bg-2 {
            background-color: var(--advisor-2-primary);
        }
        .advisor-border-1 {
            border-color: var(--advisor-1-secondary);
        }
        .advisor-border-2 {
            border-color: var(--advisor-2-secondary);
        }

        .group-bg-1 {
            background-color: var(--group-1-primary);
        }
        .group-bg-2 {
            background-color: var(--group-2-primary);
        }

        .group-border-1 {
            border-color: var(--group-1-secondary);
        }
        .group-border-2 {
            border-color: var(--group-2-secondary);
        }

        .group-bg-gradient-1 {
            background-image: linear-gradient(var(--group-1-primary), rgba(var(--group-1-p), var(--min-opacity)));
        }
        .group-bg-gradient-2 {
            background-image: linear-gradient(var(--group-2-primary), rgba(var(--group-2-p), var(--min-opacity)));
        }

        .response-hBar {
            position: relative;
            width: 80%;
            background-color: #eeeeee;
            height: var(--response-bar-thickness);
            margin: auto;
            box-shadow: 0 0 5px 0 #777777;
        }

        .response-vBar {
            height: 150px;
            background-color: white;
            position: absolute;
            top: calc((var(--response-vBar-offset) * -1) + var(--response-bar-thickness));
            transition: all .2s;
        }

        .response-vBar,
        .response-widget {
            width: var(--response-bar-thickness);
        }

        .response-widget {
            left: calc(50% - var(--response-bar-thickness) / 2);
        }

        .response-label,
        .response-widget {
            position: absolute;
            top: -100%;
            max-width: 10%;
            overflow-wrap: break-word;
        }

        .response-label {
            opacity: 1;
        }

        .response-label.left,
        .response-label.right {
            top: calc(50% - 0.5em);
            line-height: 1em;
        }

        .response-label.top,
        .response-label.bottom {
            top: unset;
            max-width: 100px;
            transform: translateX(calc(-50% + (var(--response-bar-thickness) / 2)));
        }

        .response-vBar.cloak .response-label {
            opacity: 0;
        }

        .response-label.left {
            right: calc(100% + var(--response-label-padding));
        }
        .response-label.right {
            left: calc(100% + var(--response-label-padding));
        }
        .response-label.top {
            bottom: 100%
        }
        .response-label.bottom {
            top: 100%;
        }

        .response-marker {
            position: absolute;
            width: var(--response-maker-width);
            height: var(--response-marker-height);
            left: calc(50% - (var(--response-maker-width) / 2));
            top: calc(var(--response-vBar-offset) + ((var(--response-bar-thickness) - var(--response-marker-height)) / 2));
            border-radius: 5px;
            cursor: none;
            transition: opacity .1s;
        }
        esm-response-widget,
        esm-response-widget.cloak .response-marker {
            cursor: default;
        }

        .response-vBar.cloak {
            background-color: unset;
            background-image: unset;
        }

    </style>
</head>
<body class="jspsych-display-element" tabindex="0" style="margin: 0; height: 100%; width: 100%;">
<div class="jspsych-content-wrapper" style="height: 100vh;">
    <div id="jspsych-content" class="jspsych-content">
        <div class="progress-bar">
            <div class="outer">
                <div class="inner"></div>
            </div>
            <esm-help data-group="interface" class="bottom">
                The <em>progress bar</em> shows how far through the study you are.
            </esm-help>
        </div>
        <div class="frame top">
            <div class="left">
                <div class="advisor-key-row group-bg-2 group-border-2">
                    You are in Group 2
                    <esm-help data-group="interface" class="right">
                        This <em>tag</em> shows which group you've been assigned to.
                    </esm-help>
                </div>
            </div>
            <div class="middle">
                <div id="stimulus">
                    <img src="https://cdn.instructables.com/FMU/YSFR/IDRP7INH/FMUYSFRIDRP7INH.LARGE.jpg"/>
                </div>
                <div id="prompt">Prompt text</div>
                <esm-help data-group="interface" class="">
                    This is the <em>stimulus</em> you have to respond to. Below is the <em>prompt</em> area which tells you how to respond and provides further information.
                </esm-help>
            </div>
            <div class="right">
                <div class="advisor-key-row advisor-1 group-bg-2 group-border-2">
                    <div class="marker advisor-bg-1 advisor-border-1"></div>
                    Advisor #25
                    <esm-help data-group="interface" class="left">
                        This <em>tag</em> shows details for one of your advisors. The background colour shows you their group, and the <em>marker</em> shows you the colour used to indicate their advice.
                    </esm-help>
                </div>
                <div class="advisor-key-row advisor-2 group-bg-1 group-border-1">
                    <div class="marker advisor-bg-2 advisor-border-2"></div>
                    Advisor #352
                    <esm-help data-group="interface" class="left">
                        This <em>tag</em> shows details for one of your advisors. The background colour shows you their group, and the <em>marker</em> shows you the colour used to indicate their advice.
                    </esm-help>
                </div>
            </div>
        </div>
        <div class="frame bottom">
            <esm-response-widget id="response-panel" class="cloak" data-min="1.00" data-max="5.00" data-prefix="" data-suffix="" data-decimals="2">
                <div class="response-hBar">
                    <div class="response-label left">&pound;1.00</div>
                    <div class="response-label right">&pound;5.00</div>
                    <div class="response-widget">
                        <div class="response-vBar cloak group-bg-gradient-2">
                            <div class="response-label top">certain</div>
                            <div class="response-label bottom">guess</div>
                            <div class="response-marker group-bg-2">3.00</div>
                        </div>
                    </div>
                </div>
            </esm-response-widget>
            <esm-help data-group="interface" class="top">
                This <em>response panel</em> allows you to indicate your answer. When enabled, the marker will follow your mouse movements. <strong>Click</strong> or <strong>Tap</strong> to indicate your answer. You will then see the vertical bar which allows you to indicate your <em>confidence</em> in your answer. Again, <strong>Click</strong> or <strong>Tap</strong> to indicate your <em>confidence</em>.
            </esm-help>
        </div>
    </div>
</div>
<button onclick="toggleHelp()" style="
    position: fixed;
    font-size: 1em;
    font-weight: bold;
    margin: .5em;
    padding: 0.3em;
    border-radius: 1em;
    width: 2em;
    border: 1px solid black;
    background-color: transparent;">?</button>
<script type="text/javascript">
    "use strict";

    customElements.define('esm-response-widget',
        /**
         * @class The ResponseWidget is a div element which handles responses from
         * the participant. Its properties are set using the data-* HTML fields.
         * Currently supports continuous values only, interpolated linearly from
         * data-min to data-max.
         *
         * @property min {double} Minimum response value
         * @property max {double} Maximum response value
         * @property prefix {string} Prefix to response values
         * @property suffix {string} Suffix to response values
         * @property decimals {int} Number of decimal points in response values
         */
        class ResponseWidget extends HTMLElement {

            constructor() {
                super();

                this.reset();
            }

            /**
             * Set up the events for handling estimate input.
             */
            enableResponse() {
                this.classList.remove("cloak");

                this.addEventListener("mousemove", this.updateEstimate);
                this.addEventListener("click", this.saveEstimate);
            }

            /**
             * Handle estimate input. Update the visual position of the response
             * widget, the widget label, and store the current value.
             * @param e {MouseEvent} a mouse move event
             */
            updateEstimate(e) {
                let hBar = this.querySelector(".response-hBar");
                let widget = hBar.querySelector(".response-widget");

                let cursor =
                    e.clientX -
                    hBar.getBoundingClientRect().x -
                    (widget.clientWidth / 2);
                let max = hBar.clientWidth - widget.clientWidth;
                let left = cursor < 0? 0 : cursor > max? max : cursor;

                widget.style.left = left + "px";

                // Text label
                let d = this.dataset;
                let number =
                    (parseFloat(d.max) - parseFloat(d.min)) /
                    (hBar.clientWidth - widget.clientWidth) *
                    left;
                number += parseFloat(d.min);

                let text = d.prefix + number.toFixed(d.decimals || 0) + d.suffix;

                widget.querySelector(".response-marker").innerText = text;

                // Record estimate info
                this.responseData.estimate = number;
                this.responseData.estimateLabel = text;
                this.responseData.timeEstimate = new Date().getTime();
            }

            /**
             * Save estimate input. Remove the estimate events. Add confidence
             * events.
             * @param e {MouseEvent|TouchEvent} a mouse click/touch event
             */
            saveEstimate(e) {
                this.updateEstimate(e);
                this.removeEventListener("mousemove", this.updateEstimate);
                this.removeEventListener("click", this.saveEstimate);

                // Show the confidence bar
                this.querySelector(".response-vBar").classList.remove('cloak');

                // Enable confidence responding
                this.addEventListener("mousemove", this.updateConfidence);
                this.addEventListener("click", this.saveConfidence);

            }

            /**
             * Handle confidence input. Update the visual position of the response
             * widget and store the current value.
             * @param e {MouseEvent} a mouse move event
             */
            updateConfidence(e) {
                let vBar = this.querySelector(".response-vBar");
                let widget = e.currentTarget.querySelector(".response-marker");
                let cursor =
                    vBar.getBoundingClientRect().top -
                    e.clientY +
                    (widget.clientHeight / 2);
                let max = vBar.clientHeight - widget.clientHeight;
                cursor *= -1;
                let top = cursor < 0? 0 : cursor > max? max : cursor;
                widget.style.top = top + "px";

                let p = 1 - (1 / (vBar.clientHeight - widget.clientHeight) * top);

                widget.style.opacity = (.6 * p) + .4;

                // Record response
                this.responseData.confidence = p;
                this.responseData.timeConfidence = new Date().getTime();
            }

            /**
             * Save confidence input. Remove the confidence events.
             * @param e {MouseEvent|TouchEvent} a mouse click/touch event
             */
            saveConfidence(e) {
                this.updateConfidence(e);
                this.removeEventListener("mousemove", this.updateConfidence);
                this.removeEventListener("click", this.saveConfidence);

                this.responseData.complete = true;
            }

            /**
             * Perform the response collection process.
             *
             * @param timeout {int} maximum number of milliseconds to wait before
             * returning a Timeout.
             *
             * @return {Promise} Resolve with the response data, or Timeout reject
             */
            getResponse(timeout) {
                const me = this;
                this.enableResponse();

                return new Promise(function (resolve, reject) {
                    let ms = 50;
                    let check = function(x) {
                        if(me.responseData.complete) {
                            setTimeout(() => me.reset(), 25);
                            resolve(me.responseData);
                        }
                        else if(x > timeout / ms)
                            reject("Timeout");
                        else
                            setTimeout(check, ms, x++);
                    };
                    check(0);
                });
            }

            /**
             * Refresh the element ready for collecting a new response.
             */
            reset() {
                this.classList.add('cloak');

                // clear data
                this.responseData = {
                    estimate: null,
                    estimateLabel: null,
                    timeEstimate: null,

                    confidence: null,
                    timeConfidence: null,

                    complete: false
                };

                // reset widget styling
                this.querySelector(".response-widget").style.left = "";
                this.querySelector(".response-vBar").classList.add('cloak');
                this.querySelector(".response-marker").style.top = "";
                this.querySelector(".response-marker").style.opacity = "1";

                let d = this.dataset;
                let number = (parseFloat(d.max) - parseFloat(d.min)) / 2;
                number += parseFloat(d.min);

                this.querySelector(".response-marker").innerText =
                    d.prefix + number.toFixed(d.decimals || 0) + d.suffix;

            }
        }
    );

    customElements.define('esm-help',
        /**
         * @class The HelpDiv contains help text which will be shown in a
         * tooltip-like manner. Properties are defined using the data-* HTML
         * properties.
         *
         * A HelpDiv is shown when its parent element is clicked. Hovering
         * over a parent element of an active HelpDiv will show an outline.
         *
         * A HelpDiv can be shown/hidden which indicates whether it is visible.
         * A HelpDiv can also be in/active, which indicates whether it has the
         * potential to be shown/hidden when its parent element is clicked.
         * HelpDivs start hidden and inactive.
         *
         * @property group {string[]} space-separated list of help groups.
         * HelpDivs will hide all other HelpDivs sharing a group when they
         * are revealed.
         */
        class HelpDiv extends HTMLElement {

            /**
             * Definition of initial variables.
             */
            constructor() {
                super();

                // Start hidden
                this.classList.add("hidden");

                this.lastToggleTime = new Date().getTime();
                this.minToggleTimeDifference = 25;

                let me = this;
                this.sendShowHelpEvent = function(e) {
                    me.dispatchEvent(new CustomEvent("showHelp", {
                        bubbles: false,
                        detail: {
                            parentEvent: e
                        },
                        target: me
                    }));
                };
            }

            /**
             * Display to the user.
             */
            show() {
                // Close HelpDivs with a shared (space-separated) group tag
                if(this.dataset.hasOwnProperty("group")) {
                    // Iterate this element's groups
                    this.dataset.group.split(" ").forEach((g) => {
                            let others = document.querySelectorAll(
                                "esm-help[data-group~='" + g + "']"
                            );
                            others.forEach((elm) => elm.classList.add("hidden"));
                        }
                    );
                }

                this.classList.remove("hidden");

                return this;
            }

            /**
             * Hide from the user.
             * @param parentClick {boolean} whether the parent element was clicked
             * (as opposed to this element, or hiding via a script call).
             */
            hide(parentClick = false) {
                // Don't close by clicks on the element that opened this
                if(this.dataset.parentClickCloses === "false" && parentClick)
                    return this;

                this.classList.add("hidden");

                return this;
            }

            /**
             * Toggle between show and hide states.
             * @param e {Event} event responsible for engaging the toggle
             */
            toggleVisibility(e) {
                let now = new Date().getTime();
                if(now < this.lastToggleTime + this.minToggleTimeDifference)
                    return;
                else
                    this.lastToggleTime = now;

                return this.classList.contains("hidden")?
                    this.show() : this.hide(e && e.type === "showHelp");
            }

            /**
             * Set up the event listeners on the HelpDiv and its parent element
             */
            enable() {
                this.parentElement.addEventListener("click", this.sendShowHelpEvent);
                this.parentElement.classList.add("esm-help-enabled");

                this.addEventListener("click", this.toggleVisibility);
                this.addEventListener("showHelp", this.toggleVisibility);

                return this;
            }

            /**
             * Hide. Remove event listeners.
             */
            disable() {
                this.hide();

                this.parentElement.removeEventListener("click",
                    this.sendShowHelpEvent);
                this.parentElement.classList.remove("esm-help-enabled");

                this.removeEventListener("click", this.toggleVisibility);
                this.removeEventListener("showHelp", this.toggleVisibility);

                return this;
            }

            /**
             * Toggle between in/active states.
             */
            toggle() {
                if(this.parentElement.classList.contains("esm-help-enabled"))
                    this.disable();
                else
                    this.enable();
            }
        }
    );

    const X = {
        stimulus: document.querySelector("#stimulus"),
        prompt: document.querySelector("#prompt"),
        response: document.querySelector("esm-response-widget")
    };

    class Trial {
        /**
         * Run a trial
         * @param [callback] {function} called with arguments of
         * <string>stageName and <Trial>this object at each stage
         * @param [beginImmediately = false] {boolean} whether to begin the
         * trial immediately
         */
        constructor(callback, beginImmediately = false) {

            this.callback = null;
            this.activeTimeout = null;

            this.stim = new Image();
            this.stim.src = "https://cdn.instructables.com/FMU/YSFR/IDRP7INH/FMUYSFRIDRP7INH.LARGE.jpg";

            this.data = {
                timestampStart: null,
                timeStimOn: null,
                timeStimOff: null,
                timeEnd: null,

                stim: this.stim.src
            };

            Trial.reset();

            if(typeof callback === "function")
                this.callback = (stage) => callback(stage, this);
            else
                this.callback = () => {};

            if(beginImmediately)
                this.begin();
        }

        /**
         * Run the trial asynchronously.
         * @return {Promise<*>} Resolve with the trial data.
         */
        async run() {
            this.begin();
            let me = this;
            return new Promise(function (resolve, reject) {
                function check(x) {
                    if(me.data.timeEnd !== null) {
                        resolve(me.data);
                    } else
                        setTimeout(check, 50, x++);
                }
                check(0);
            });
        }

        /**
         * Set the prompt text and mark the start time.
         * Set the timeout for the show stimulus phase.
         */
        begin() {
            this.callback("begin");

            X.stimulus.innerHTML = this.stim.outerHTML;
            X.prompt.innerHTML = "How much are the coins worth?";

            this.data.timestampStart = new Date().getTime();

            this.activeTimeout = setTimeout(() => this.showStim(), 500);
        }

        /**
         * Show stimulus. Set the timeout for the hide stim phase.
         */
        showStim() {
            this.callback("showStim");

            this.data.timeStimOn = new Date().getTime() - this.data.timestampStart;
            X.stimulus.classList.remove('cloak');

            this.activeTimeout = setTimeout(() => this.hideStim(), 1000);
        }

        /**
         * Hide stimulus. Initiate the response phase.
         */
        hideStim() {
            this.callback("hideStim");

            this.data.timeStimOff = new Date().getTime() - this.data.timestampStart;
            X.stimulus.classList.add('cloak');

            this.getResponse()
                .then((data) => this.processResponse(data, false));
        }

        /**
         * Collect the participant's response via the ResponseWidget.
         * @return {Promise<*>}
         */
        async getResponse() {

            this.callback("getResponse");

            let response = await X.response.getResponse(Infinity);
            if(response === "undefined") {
                console.log("Timeout on response");
            }
            return response;
        }

        /**
         * Handle the response.
         * @param data {Object|undefined} response data
         * @param isInitial {boolean} whether the response is the initial response
         */
        processResponse(data, isInitial) {

            this.callback("processResponse");

            let me = this;

            Object.keys(data).forEach((k) => {
                const s = isInitial? "initialResponse" : "finalResponse";
                if(/time/.test(k))
                    data[k] -= me.data.timestampStart;

                // Save in camelCase
                me.data[s + k.substr(0,1).toUpperCase() + k.substr(1)] =
                    data[k];
            });

            if(isInitial) {

            } else {
                this.data.timeEnd = new Date().getDate() - this.data.timestampStart;
                this.cleanup();

            }
        }

        /**
         * Set the display back to its fresh state.
         */
        cleanup() {
            this.callback("cleanup");
            Trial.reset();
        }

        /**
         * Set the display to its fresh state.
         */
        static reset() {
            X.stimulus.classList.add('cloak');
            X.prompt.innerHTML = "";
        }

    }

    /**
     * Toggle between help enabled/disabled.
     */
    function toggleHelp() {
        document.querySelectorAll("esm-help").forEach((elm) => elm.toggle());

        event.currentTarget.style.backgroundColor =
            event.currentTarget.style.backgroundColor === "transparent"?
            "yellow" : "transparent";
    }

    // Procedural stuff

    async function intro() {
        console.log("intro")

        return new Promise(function(resolve) {
           setTimeout(resolve, 1, "intro");
        });
    }

    async function training() {
        console.log("training")

        return new Promise(function(resolve) {
            setTimeout(resolve, 500, "training");
        });
    }

    async function moreInstructions() {
        console.log("moreInstructions")

        return new Promise(function(resolve) {
            setTimeout(resolve, 250, "moreInstructions");
        });
    }

    async function runTrials(trials) {
        console.log("runTrials")

        let data = [];
        for (const t of trials)
            await t.run().then((d) => {
                data.push(d);
            });

        return data;
    }

    async function debrief() {
        console.log("debrief")

        return new Promise(function(resolve) {
            setTimeout(resolve, 0, "debrief");
        });
    }

    async function run(trialCount) {
        const data = {
            intro: null,
            training: null,
            instructions: null,
            trials: null,
            debrief: null
        };

        data.intro = await intro();
        data.training = await training();
        data.instructions = await moreInstructions();

        data.trials = [];
        for(let i = 0; i < trialCount; i++)
            data.trials.push(await new Trial().run());

        data.debrief = await debrief();

        return data;
    }

    Trial.reset();

    run(2).then(console.log);

</script>
</body>
</html>