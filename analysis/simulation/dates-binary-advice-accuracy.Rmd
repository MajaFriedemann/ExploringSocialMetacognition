---
title: "Confidence estimation advice properties"
author: "Matt Jaquiery (matt.jaquiery@psy.ox.ac.uk)"
output:
  html_document:
    df_print: paged
    toc: yes
    toc_depth: '3'
    css: ../src/writeUp.css
    includes:
      after_body: ../src/toc_menu.html
  html_notebook:
    toc: yes
    toc_depth: 3
    css: ../src/writeUp.css
    includes:
      after_body: ../src/toc_menu.html
editor_options:
  chunk_output_type: inline
---

December 2019

[Script run `r Sys.time()`]

```{r}
library(tidyverse)

theme_set(
  theme_light() + 
    theme(panel.grid.minor = element_blank(),
          panel.grid.major.x = element_blank())
  )
```

# Background

In the binary version of the dates task we draw the anchor dates from a normal distribution around the actual date, excluding the exact date. This gives a binary answer to the question of whether the actual date is before or after the anchor date. 

Advisors' advice is generated by having the advisors make noisy guesses at the date (another normal distribution around the actual date), and then their confidence is established by scaling the difference between the actual and guessed date according to the advisor's confidence characteristics. 

The question for simulation here is how the standard deviations of the two distributions interrelate to produce accuracy rates for the advisors. 

The anchor places a marker on a standard distribution, dividing the distribution into a left-hand part which constitutes 'before' estimates and a right-hand part which consititutes 'after' estimates. For an anchor date after the actual date (given symmetry, it's trivial to reverse this to deal with before anchors), any date up to the anchor date will be equivalent in terms of the accuracy of the binary answer (correct).

Where both standard deviations are the same, the problem is illustrated thus:

```{r}
n <- 100000
x <- tibble(
  x = seq(-3, 3, .01),
  cd = dnorm(x),
  ans = if_else(x < 2, "correct", "wrong")
)

x %>% ggplot(aes(x = x, y = cd)) +
  geom_col(aes(fill = ans)) + 
  annotate(geom = "rect", fill = "black", 
           xmin = -.01, ymin = 0, xmax = .01, ymax = .2) +
  annotate(geom = "label", x = 0, y = .22, label = "actual date") +
  annotate(geom = "rect", fill = "black", 
           xmin = 1.99, ymin = 0, xmax = 2.01, ymax = .2) +
  annotate(geom = "label", x = 2, y = .22, label = "e.g. anchor date") +
  scale_fill_discrete(h.start = 180, name = "advisor guess")
```

The question can be generalised to asking: given two samples from two independent normal distributions, what is the probability that the score from the first one is more extreme than the score for the second one? This is intuitively a function of the standard deviations of these distributions: if they were equal, the probability of a less extreme result the second time around is the cumulative density function for the first result.

**Note** a 'less extreme' result includes massive errors in the opposite direction.

# Equal SD

For the example above, we can simulate some data.

```{r}
n <- 1000

x <- tibble(
  i = 1:n,
  anchor = rnorm(n),
  guess = rnorm(n),
  correct = abs(guess) < abs(anchor) | sign(guess) != sign(anchor)
)

x %>% gather("source", "estimate", anchor:guess) %>% 
  ggplot(aes(x = source, y = estimate, colour = correct)) +
  geom_violin(fill = NA, colour = "black", size = 1.5) + 
  geom_line(aes(group = i), alpha = .1) +
  facet_wrap(~correct, labeller = label_both)

x %>% summarise(pCorrect = mean(correct))
```

When the SDs are equal we get a mean correctness of .75. This makes sense because there's a 50% chance that the anchor and the guess will be on opposite sides of the actual date (0), meaning the advice is correct. In the half of cases where the anchor and guess are on the same side, they're as likely as one another to have scores more extreme than any given value, so the probability the anchor is more extreme is .5. The 50% + (50% of the remaining 50%) = 75%. 

# Advice twice as precise (half SD)

```{r}
n <- 1000

x <- tibble(
  i = 1:n,
  anchor = rnorm(n, sd = 8),
  guess = rnorm(n, sd = 4),
  correct = abs(guess) < abs(anchor) | sign(guess) != sign(anchor)
)

x %>% gather("source", "estimate", anchor:guess) %>% 
  ggplot(aes(x = source, y = estimate, colour = correct)) +
  geom_violin(fill = NA, colour = "black", size = 1.5) + 
  geom_line(aes(group = i), alpha = .1) +
  facet_wrap(~correct, labeller = label_both)

x %>% summarise(pCorrect = mean(correct))
```

# Titrating to 70%

```{r}

n <- 1000
r <- 100

d <- NULL

for (rep in 1:r) {
  x <- tibble(
    s = seq(1, 20, .5)
  ) %>% 
    group_by(s) %>%
    do(df = tibble(
      i = 1:n,
      anchor = rnorm(n, sd = 8),
      guess = rnorm(n, sd = .$s),
      correct = abs(guess) < abs(anchor) | sign(guess) != sign(anchor)
    ) %>%
      summarise(pCorrect = mean(correct))) %>%
    unnest(df)
  
  d <- rbind(d, x)
}

d %>% group_by(s) %>% summarise(pCorrect = mean(pCorrect))

ggplot(d, aes(x = s, y = pCorrect, group = s)) +
  stat_summary(geom = "point", fun.y = mean) +
  stat_summary(geom = "errorbar", fun.data = mean_cl_normal, width = 0) + 
  geom_hline(yintercept = .7, linetype = "dashed") +
  scale_y_continuous(limits = c(0, 1)) +
  labs(x = "Advisor SD",
       caption = paste("Estimation based on", 
                       r, "repetitions of", 
                       n, "samples.")) +
  annotate(geom = "text", x = 15, y = .9, label = "Anchor SD = 8.0") +
  annotate(geom = "label", x = 3, y = .7, label = "70% accuracy")
```