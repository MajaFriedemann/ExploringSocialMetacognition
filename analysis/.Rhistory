df.vii <- NULL
tmp <- aggregate(id ~ confidenceCategory + pid, trials, length)
for(cc in confidenceCategories) {
v <- tmp$id[tmp$confidenceCategory==cc]
cl <- mean_cl_normal(v)
rn <- range(v)
df.vii <- rbind(df.vii, data.frame(confidenceCategory = cc,
meanN = cl$y,
cl95L = cl$ymin,
cl95H = cl$ymax,
rangeL = rn[1],
rangeH = rn[2]))
}
#kable(round(df.vii,2))
df.vii.2 <- NULL
tmp <- NULL
for(pid in unique(trials$pid)) {
v <- trials$confidenceCategory[trials$pid==pid]
tmp <- rbind(tmp, data.frame(pid,
low=mean(v==confidenceCategories$low),
med=mean(v==confidenceCategories$medium),
high=mean(v==confidenceCategories$high)))
}
for(cc in confidenceCategories) {
v <- tmp[ ,2+cc] # for each confidence category in tmp
cl <- mean_cl_normal(v)
rn <- range(v)
df.vii.2 <- rbind(df.vii.2, data.frame(confidenceCategory = cc,
meanProp = cl$y,
cl95L = cl$ymin, cl95H = cl$ymax,
rangeL = rn[1], rangeH = rn[2]))
}
#kable(round(df.vii.2,2))
# For parity with MATLAB experiment we look at confidence categories for initially-correct trials only
df.vii.3 <- NULL
tmp <- NULL
for(pid in unique(trials$pid)) {
v <- trials$confidenceCategory[trials$pid==pid]
v[!trials$initialCorrect[trials$pid==pid]] <- NaN # set non-initially correct to NaN
tmp <- rbind(tmp, data.frame(pid,
low=mean(v==confidenceCategories$low, na.rm=T),
med=mean(v==confidenceCategories$medium, na.rm=T),
high=mean(v==confidenceCategories$high, na.rm=T),
nan=mean(is.nan(v))))
}
for(cc in c(confidenceCategories,NaN)) {
v <- tmp[ ,2+ifelse(is.nan(cc),3,cc)] # for each confidence category in tmp
cl <- mean_cl_normal(v)
rn <- range(v)
df.vii.3 <- rbind(df.vii.3, data.frame(confidenceCategory = cc,
meanProp = cl$y,
cl95L = cl$ymin, cl95H = cl$ymax,
rangeL = rn[1], rangeH = rn[2]))
}
kable(prop2str(round(df.vii.3,2)))
#' Format proportion to be a string beginning with a decimal point.
#' Does not respect scientific notation options
prop2str <- function(proportion, precision = 2) {
if(length(proportion) > 1)
return(sapply(proportion, prop2str))
if(is.nan(proportion))
return(as.character(proportion))
proportion <- round(proportion, precision)
if(abs(proportion) < 1)
x <- sub('^-?0\\.', ifelse(proportion < 0, '-.', '.'), as.character(proportion))
else
x <- proportion
dot <- regexpr('.', x, fixed = T)
right <- substr(x, dot, dot+precision) # portion of x after 0
right <- paste0(right, rep('0',nchar(right)-precision))
substr(x, dot, dot+precision) <- right
return(x)
}
prop2str(NaN)
prop2str(0.15)
prop2str(-0.15)
prop2str(-0.1)
prop2str(-0.)
Q
proportion <- -0.
precision <- 2
proportion <- round(proportion, precision)
x <- sub('^-?0\\.', ifelse(proportion < 0, '-.', '.'), as.character(proportion))
dot <- regexpr('.', x, fixed = T)
if(dot == -1) {
x <- paste0(x,'.')
dot <- regexpr('.', x, fixed = T)
}
right <- substr(x, dot, dot+precision) # portion of x after 0
right <- paste0(right, rep('0',nchar(right)-precision))
right <- paste0(right, rep('0',precision-nchar(right)+1))
rep('0',precision-nchar(right)+1)
right <- substr(x, dot, dot+precision) # portion of x after 0
rep('0',precision-nchar(right)+1)
strrep('0',precision-nchar(right)+1)
right <- paste0(right, strrep('0',precision-nchar(right)+1))
substr(x, dot, dot+precision) <- right
x
paste0(substr(x, 1, dot-1), right)
#' Format proportion to be a string beginning with a decimal point.
#' Does not respect scientific notation options
prop2str <- function(proportion, precision = 2) {
if(length(proportion) > 1)
return(sapply(proportion, prop2str))
if(is.nan(proportion))
return(as.character(proportion))
proportion <- round(proportion, precision)
if(abs(proportion) < 1)
x <- sub('^-?0\\.', ifelse(proportion < 0, '-.', '.'), as.character(proportion))
else
x <- as.character(proportion)
dot <- regexpr('.', x, fixed = T)
if(dot == -1) {
x <- paste0(x,'.')
dot <- regexpr('.', x, fixed = T)
}
right <- substr(x, dot, dot+precision) # portion of x after 0
right <- paste0(right, strrep('0',precision-nchar(right)+1))
x <- paste0(substr(x, 1, dot-1), right)
return(x)
}
prop2str(NaN)
prop2str(100.005)
prop2str(100.050)
prop2str(100.056)
prop2str(0.752)
prop2str(0.7)
kable(prop2str(df.vii.2))
aggregate(id ~ pid, all.trials, length)
aggregate(pid ~ id, all.trials, length)
(min(ts$id)+1):max(ts$id)
confidenceCategories
lag <- 20
i <- 10
# for each trial calculate the confidence category using the lag
ts <- all.trials[all.trials$pid == pid, ]
ts$initialConfidence[!ts$initialCorrect] <- NaN # void confidence for incorrect trials
trial <- ts[ts$id == i, ]
low <- i - lag
ifelse(low < min(ts$id), min(ts$id), low)
testSet <- ts[ts$id %in% low:(i-1) & !is.nan(ts$initialConfidence), ]
markers <- quantile(testSet$initialConfidence, c(.3,.7))
sum(trial$initialConfidence < markers)
sum(markers < trial$initialConfidence)
trial$initialConfidence
testSet$initialConfidence
#markers <- quantile(testSet$initialConfidence, c(.3,.7)) # nice approach, but not used in JS version
testSet <- testSet[order(testSet$initialConfidence),]
testSet$initialConfidence
markers <- testSet$initialConfidence[c(round(nrow(testSet)*.3), round(nrow(testSet)*.7))]
nrow(testSet)
8*.3
8*.7
sum(markers < trial$initialConfidence)
ts$confidenceCategory
for(i in (min(ts$id)+1):max(ts$id)) {
trial <- ts[ts$id == i, ]
low <- i - lag
ifelse(low < min(ts$id), min(ts$id), low)
testSet <- ts[ts$id %in% low:(i-1) & !is.nan(ts$initialConfidence), ]
#markers <- quantile(testSet$initialConfidence, c(.3,.7)) # nice approach, but not used in JS version
testSet <- testSet[order(testSet$initialConfidence),]
markers <- testSet$initialConfidence[c(round(nrow(testSet)*.3), round(nrow(testSet)*.7))]
trial$confidenceCategory <- sum(markers < trial$initialConfidence)
ts[ts$id == i, ] <- trial
}
ts$confidenceCategory
i <- 7
trial <- ts[ts$id == i, ]
low <- i - lag
ifelse(low < min(ts$id), min(ts$id), low)
low <- ifelse(low < min(ts$id), min(ts$id), low)
testSet <- ts[ts$id %in% low:(i-1) & !is.nan(ts$initialConfidence), ]
#markers <- quantile(testSet$initialConfidence, c(.3,.7)) # nice approach, but not used in JS version
testSet <- testSet[order(testSet$initialConfidence),]
markers <- testSet$initialConfidence[c(round(nrow(testSet)*.3), round(nrow(testSet)*.7))]
sum(markers < trial$initialConfidence)
trial$initialConfidence
trial$initialCorrect
ts <- all.trials[all.trials$pid == pid & all.trials$initialCorrect, ] # only count correct trials
for(i in (min(ts$id)+1):max(ts$id)) {
trial <- ts[ts$id == i, ]
low <- i - lag
low <- ifelse(low < min(ts$id), min(ts$id), low)
testSet <- ts[ts$id %in% low:(i-1) & !is.nan(ts$initialConfidence), ]
#markers <- quantile(testSet$initialConfidence, c(.3,.7)) # nice approach, but not used in JS version
testSet <- testSet[order(testSet$initialConfidence),]
markers <- testSet$initialConfidence[c(round(nrow(testSet)*.3), round(nrow(testSet)*.7))]
trial$confidenceCategory <- sum(markers < trial$initialConfidence)
ts[ts$id == i, ] <- trial
}
# for each trial calculate the confidence category using the lag
ts <- all.trials[all.trials$pid == pid & all.trials$initialCorrect, ] # only count correct trials
trial <- ts[ts$id == i, ]
low <- i - lag
low <- ifelse(low < min(ts$id), min(ts$id), low)
ts <- all.trials[all.trials$pid == pid, ]
ts$initialConfidence[!ts$initialCorrect] <- NaN # void confidence for incorrect trials
for(i in (min(ts$id)+1):max(ts$id)) {
trial <- ts[ts$id == i, ]
low <- i - lag
low <- ifelse(low < min(ts$id), min(ts$id), low)
testSet <- ts[ts$id %in% low:(i-1) & !is.nan(ts$initialConfidence), ]
#markers <- quantile(testSet$initialConfidence, c(.3,.7)) # nice approach, but not used in JS version
testSet <- testSet[order(testSet$initialConfidence),]
markers <- testSet$initialConfidence[c(round(nrow(testSet)*.3), round(nrow(testSet)*.7))]
trial$confidenceCategory <- sum(markers < trial$initialConfidence)
ts[ts$id == i, ] <- trial
}
lags <- c(10,20,40,60,120,Inf)
df.lags <- NULL
# For each lag setting
for(lag in lags) {
# For each participant
for(pid in unique(participants$pid)) {
# for each trial calculate the confidence category using the lag
ts <- all.trials[all.trials$pid == pid, ]
ts$initialConfidence[!ts$initialCorrect] <- NaN # void confidence for incorrect trials
for(i in (min(ts$id)+1):max(ts$id)) {
trial <- ts[ts$id == i, ]
low <- i - lag
low <- ifelse(low < min(ts$id), min(ts$id), low)
testSet <- ts[ts$id %in% low:(i-1) & !is.nan(ts$initialConfidence), ]
#markers <- quantile(testSet$initialConfidence, c(.3,.7)) # nice approach, but not used in JS version
testSet <- testSet[order(testSet$initialConfidence),]
markers <- testSet$initialConfidence[c(round(nrow(testSet)*.3), round(nrow(testSet)*.7))]
trial$confidenceCategory <- sum(markers < trial$initialConfidence)
ts[ts$id == i, ] <- trial
}
# calculate confidence category proportions
ts <- ts[!ts$practice, ]
for(confCat in confidenceCategories) {
df.lags <- rbind(df.lags, data.frame(lag,
pid,
confCat,
prop = mean(ts$confidenceCategory==confCat, na.rm = T)))
}
}
}
# plot results
ggplot(df.lags, aes(x = as.factor(lag), y = prop, colour = confCat)) +
stat_summary(geom = 'point', fun.y = mean) +
stat_summary(geom = 'errorbar', fun.data = mean_cl_boot)
names(df.lags)
# plot results
ggplot(df.lags, aes(x = as.factor(lag), y = prop, colour = as.factor(confCat))) +
stat_summary(geom = 'point', fun.y = mean) +
stat_summary(geom = 'errorbar', fun.data = mean_cl_boot)
lags <- c(10,20,40,60,120,Inf)
df.lags <- NULL
# For each lag setting
pb <- txtProgressBar(min = 0, max = length(lags) * nrow(participants), style = 3)
for(lag in lags) {
# For each participant
for(pid in unique(participants$pid)) {
# for each trial calculate the confidence category using the lag
ts <- all.trials[all.trials$pid == pid, ]
ts$initialConfidence[!ts$initialCorrect] <- NaN # void confidence for incorrect trials
for(i in (min(ts$id)+1):max(ts$id)) {
trial <- ts[ts$id == i, ]
low <- i - lag
low <- ifelse(low < min(ts$id), min(ts$id), low)
testSet <- ts[ts$id %in% low:(i-1) & !is.nan(ts$initialConfidence), ]
#markers <- quantile(testSet$initialConfidence, c(.3,.7)) # nice approach, but not used in JS version
testSet <- testSet[order(testSet$initialConfidence),]
markers <- testSet$initialConfidence[c(round(nrow(testSet)*.3), round(nrow(testSet)*.7))]
trial$confidenceCategory <- sum(markers < trial$initialConfidence)
ts[ts$id == i, ] <- trial
}
# calculate confidence category proportions
ts <- ts[!ts$practice, ]
for(confCat in confidenceCategories) {
df.lags <- rbind(df.lags, data.frame(lag,
pid,
confCat,
prop = mean(ts$confidenceCategory==confCat, na.rm = T)))
}
}
setTxtProgressBar(pb, getTxtProgressBar(pb) + 1)
}
lags <- c(10,20,40,60,120,Inf)
df.lags <- NULL
# For each lag setting
pb <- txtProgressBar(min = 0, max = length(lags) * nrow(participants), style = 3)
for(lag in lags) {
# For each participant
for(pid in unique(participants$pid)) {
# for each trial calculate the confidence category using the lag
ts <- all.trials[all.trials$pid == pid, ]
ts$initialConfidence[!ts$initialCorrect] <- NaN # void confidence for incorrect trials
for(i in (min(ts$id)+1):max(ts$id)) {
trial <- ts[ts$id == i, ]
low <- i - lag
low <- ifelse(low < min(ts$id), min(ts$id), low)
testSet <- ts[ts$id %in% low:(i-1) & !is.nan(ts$initialConfidence), ]
#markers <- quantile(testSet$initialConfidence, c(.3,.7)) # nice approach, but not used in JS version
testSet <- testSet[order(testSet$initialConfidence),]
markers <- testSet$initialConfidence[c(round(nrow(testSet)*.3), round(nrow(testSet)*.7))]
trial$confidenceCategory <- sum(markers < trial$initialConfidence)
ts[ts$id == i, ] <- trial
}
# calculate confidence category proportions
ts <- ts[!ts$practice, ]
for(confCat in confidenceCategories) {
df.lags <- rbind(df.lags, data.frame(lag,
pid,
confCat,
prop = mean(ts$confidenceCategory==confCat, na.rm = T)))
}
setTxtProgressBar(pb, getTxtProgressBar(pb) + 1)
}
}
close(pb)
# plot results
ggplot(df.lags, aes(x = as.factor(lag), y = prop, colour = as.factor(confCat))) +
stat_summary(geom = 'point', fun.y = mean) +
stat_summary(geom = 'errorbar', fun.data = mean_cl_boot)
lags <- c(10,20,40,60,120,Inf)
df.lags <- NULL
# For each lag setting
print('Calculating trial confidence categories at various lag settings')
pb <- txtProgressBar(min = 0, max = length(lags) * nrow(participants))
for(lag in lags) {
# For each participant
for(pid in unique(participants$pid)) {
# for each trial calculate the confidence category using the lag
ts <- all.trials[all.trials$pid == pid, ]
ts$initialConfidence[!ts$initialCorrect] <- NaN # void confidence for incorrect trials
for(i in (min(ts$id)+1):max(ts$id)) {
trial <- ts[ts$id == i, ]
low <- i - lag
low <- ifelse(low < min(ts$id), min(ts$id), low)
testSet <- ts[ts$id %in% low:(i-1) & !is.nan(ts$initialConfidence), ]
markers <- quantile(testSet$initialConfidence, c(.3,.7)) # nice approach, but not used in JS version
testSet <- testSet[order(testSet$initialConfidence),]
#markers <- testSet$initialConfidence[c(round(nrow(testSet)*.3), round(nrow(testSet)*.7))]
trial$confidenceCategory <- sum(markers < trial$initialConfidence)
ts[ts$id == i, ] <- trial
}
# calculate confidence category proportions
ts <- ts[!ts$practice, ]
for(confCat in confidenceCategories) {
df.lags <- rbind(df.lags, data.frame(lag,
pid,
confCat,
prop = mean(ts$confidenceCategory==confCat, na.rm = T)))
}
setTxtProgressBar(pb, getTxtProgressBar(pb) + 1)
}
}
close(pb)
# plot results
ggplot(df.lags, aes(x = as.factor(lag), y = prop, colour = as.factor(confCat))) +
stat_summary(geom = 'point', fun.y = mean) +
stat_summary(geom = 'errorbar', fun.data = mean_cl_boot)
# for each trial calculate the confidence category using the lag
ts <- all.trials[all.trials$pid == pid, ]
ts$initialConfidence[!ts$initialCorrect] <- NaN # void confidence for incorrect trials
testSet <- ts[ts$practice & ts$id > (max(ts$id[ts$practice])-lag), ]
# markers <- quantile(testSet$initialConfidence, c(.3,.7)) # nice approach, but not used in JS version
testSet <- testSet[order(testSet$initialConfidence),]
markers <- testSet$initialConfidence[c(round(nrow(testSet)*.3), round(nrow(testSet)*.7))]
ts <- ts[!ts$practice, ]
ts$confidenceCategory <- sum(markers < ts$initialConfidence)
sum(markers < ts$initialConfidence)
sum(markers < ts$initialConfidence[ts$initialCorrect])
sum(markers < ts$initialConfidence[ts$id == i])
ts <- ts[!ts$practice & ts$initialCorrect, ]
i <- 10
sum(markers < ts$initialConfidence[ts$id == i])
i <- 20
sum(markers < ts$initialConfidence[ts$id == i])
lags <- c(5,10,20,40,60,Inf)
df.lags <- NULL
# For each lag setting
print('Calculating trial confidence categories at various lag settings')
pb <- txtProgressBar(min = 0, max = length(lags) * nrow(participants))
for(lag in lags) {
# For each participant
for(pid in unique(participants$pid)) {
# for each trial calculate the confidence category using the lag
ts <- all.trials[all.trials$pid == pid, ]
ts$initialConfidence[!ts$initialCorrect] <- NaN # void confidence for incorrect trials
testSet <- ts[ts$practice & ts$id > (max(ts$id[ts$practice])-lag), ]
# markers <- quantile(testSet$initialConfidence, c(.3,.7)) # nice approach, but not used in JS version
testSet <- testSet[order(testSet$initialConfidence),]
markers <- testSet$initialConfidence[c(round(nrow(testSet)*.3), round(nrow(testSet)*.7))]
ts <- ts[!ts$practice & ts$initialCorrect, ]
for(i in ts$id) {
ts$confidenceCategory[ts$id == i] <- sum(markers < ts$initialConfidence[ts$id == i])
}
# calculate confidence category proportions
for(confCat in confidenceCategories) {
df.lags <- rbind(df.lags, data.frame(lag,
pid,
confCat,
prop = mean(ts$confidenceCategory==confCat, na.rm = T)))
}
setTxtProgressBar(pb, getTxtProgressBar(pb) + 1)
}
}
close(pb)
# plot results
ggplot(df.lags, aes(x = as.factor(lag), y = prop, colour = as.factor(confCat))) +
stat_summary(geom = 'point', fun.y = mean) +
stat_summary(geom = 'errorbar', fun.data = mean_cl_boot)
# plot results
ggplot(df.lags, aes(x = as.factor(lag), y = prop, colour = as.factor(confCat))) +
stat_summary(geom = 'point', fun.y = mean) +
stat_summary(geom = 'errorbar', fun.data = mean_cl_boot) +
hline(yintercept = .4, linetype = 'dashed') +
hline(yintercept = .3, linetype = 'dashed')
# plot results
ggplot(df.lags, aes(x = as.factor(lag), y = prop, colour = as.factor(confCat))) +
geom_hline(yintercept = .4, linetype = 'dashed') +
geom_hline(yintercept = .3, linetype = 'dashed') +
stat_summary(geom = 'point', fun.y = mean) +
stat_summary(geom = 'errorbar', fun.data = mean_cl_boot)
ggplot(trials, aes(x = id, y = initialConfidence, colour = as.factor(pid))) +
geom_point(alpha = 0.1) +
geom_smooth(method = 'lm')
ggplot(trials, aes(x = id, y = initialConfidence, colour = as.factor(pid))) +
geom_point(alpha = 0.1) +
geom_smooth(method = 'lm', se = NULL)
ggplot(trials, aes(x = id, y = initialConfidence, colour = as.factor(pid))) +
geom_point(alpha = 0.1) +
geom_smooth(method = 'lm', se = F)
ggplot(trials[!trials$practice & trials$initialCorrect],
aes(x = id, y = initialConfidence, colour = as.factor(pid))) +
geom_point(alpha = 0.1) +
geom_smooth(method = 'lm', se = F)
ggplot(trials[!trials$practice & trials$initialCorrect, ],
aes(x = id, y = initialConfidence, colour = as.factor(pid))) +
geom_point(alpha = 0.1) +
geom_smooth(method = 'lm', se = F)
lm(initialConfidence ~ id, trials[!trials$practice & trials$initialCorrect])
lm(initialConfidence ~ id, trials[!trials$practice & trials$initialCorrect, ])
m <- lm(initialConfidence ~ id, trials[!trials$practice & trials$initialCorrect, ])
m$coefficients
m$coefficients[2]
df.conf <- NULL
for(pid in unique(trials$pid)) {
m <- lm(initialConfidence ~ id, trials[!trials$practice & trials$initialCorrect, ])
df.conf <- rbind(df.conf, data.frame(pid,
coef = m$coefficients[2]))
}
plot(df.conf$coef)
df.conf <- NULL
for(pid in unique(trials$pid)) {
m <- lm(initialConfidence ~ id, trials[!trials$practice & trials$initialCorrect & trials$pid == pid, ])
df.conf <- rbind(df.conf, data.frame(pid,
coef = m$coefficients[2]))
}
plot(df.conf$coef)
hist(df.conf$coef)
ggplot(df.conf, aes(y = coef, colour = as.factor(pid))) +
geom_point(alpha = 0.25, position = position_jitter()) +
stat_summary(geom = 'point', fun.y = mean) +
stat_summary(geom = 'errorbar', fun.data = mean_cl_boot)
ggplot(df.conf, aes(x = "", y = coef, colour = as.factor(pid))) +
geom_point(alpha = 0.25, position = position_jitter()) +
stat_summary(geom = 'point', fun.y = mean) +
stat_summary(geom = 'errorbar', fun.data = mean_cl_boot)
ggplot(df.conf, aes(x = "", y = coef)) +
geom_point(alpha = 0.25, position = position_jitter(), aes(colour = as.factor(pid))) +
stat_summary(geom = 'point', fun.y = mean) +
stat_summary(geom = 'errorbar', fun.data = mean_cl_boot)
ggplot(df.conf, aes(x = "", y = coef)) +
geom_point(alpha = 0.25, position = position_jitter(), aes(colour = as.factor(pid))) +
stat_summary(geom = 'point', fun.y = mean) +
stat_summary(geom = 'errorbar', fun.data = mean_cl_boot) +
geom_violin()
ggplot(df.conf, aes(x = "", y = coef)) +
geom_violin(alpha = 0.5, colour = NULL)
ggplot(df.conf, aes(x = "", y = coef)) +
geom_violin(alpha = 0.5, colour = NULL) +
geom_point(alpha = 0.25, position = position_jitter(), aes(colour = as.factor(pid))) +
stat_summary(geom = 'point', fun.y = mean) +
stat_summary(geom = 'errorbar', fun.data = mean_cl_boot) +
ggplot(df.conf, aes(x = "", y = coef)) +
geom_violin(alpha = 0.5, colour = NULL) +
geom_point(alpha = 0.25, position = position_jitter(), aes(colour = as.factor(pid))) +
stat_summary(geom = 'point', fun.y = mean) +
stat_summary(geom = 'errorbar', fun.data = mean_cl_boot)
ggplot(df.conf, aes(x = "", y = coef)) +
geom_violin(alpha = 0.5, colour = NULL) +
geom_point(alpha = 0.25, position = position_jitter(), aes(colour = as.factor(pid))) +
stat_summary(geom = 'point', fun.y = mean) +
stat_summary(geom = 'errorbar', fun.data = mean_cl_boot)
ggplot(df.conf, aes(x = "", y = coef)) +
geom_violin(alpha = 0.5, colour = NA) +
geom_point(alpha = 0.25, position = position_jitter(), aes(colour = as.factor(pid))) +
stat_summary(geom = 'point', fun.y = mean) +
stat_summary(geom = 'errorbar', fun.data = mean_cl_boot)
ggplot(df.conf, aes(x = "", y = coef)) +
geom_violin(alpha = 0.5, colour = NA) +
geom_point(alpha = 0.25, position = position_jitter(), aes(colour = as.factor(pid))) +
stat_summary(geom = 'point', fun.y = mean) +
stat_summary(geom = 'errorbar', fun.data = mean_cl_boot) +
theme_light
ggplot(df.conf, aes(x = "", y = coef)) +
geom_violin(alpha = 0.5, colour = NA) +
geom_point(alpha = 0.25, position = position_jitter(), aes(colour = as.factor(pid))) +
stat_summary(geom = 'point', fun.y = mean) +
stat_summary(geom = 'errorbar', fun.data = mean_cl_boot) +
theme_light()
ggplot(df.conf, aes(x = "", y = coef)) +
geom_violin(alpha = 0.5, colour = NA, fill = 'lightgrey') +
geom_point(alpha = 0.25, position = position_jitter(), aes(colour = as.factor(pid))) +
stat_summary(geom = 'point', fun.y = mean) +
stat_summary(geom = 'errorbar', fun.data = mean_cl_boot) +
theme_light()
