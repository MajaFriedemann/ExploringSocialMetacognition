paste(c(exclusions$excluded[exclusions$pid == p],
"badMarker"), collapse = ", ")
}
}
}
table(exclusions$excluded)
library(testthat)
library(tidyverse)
library(curl)
library(lsr)
library(BayesFactor)
library(BANOVA)
library(ez)
library(knitr)
library(prettyMD)
opts_chunk$set('echo' = F)
set.seed(20190425)
# Plot setup
theme_set(theme_light() +
theme(panel.grid.major.x = element_blank()))
# outlier detection and removal
zThresh <- 3 # threshold for outliers
maxTime <- 60000 # maximum trial time in ms (should pass almost all participants)
minChangePercent <- 0.1 # minimum percent of core trials with different initial and final answers
markerList <- list(thin = 1, medium = 3, wide = 9)
markerPoints <- function(width) 27 / width
#' strip newlines and html tags from string
stripTags <- function(s) {
s <- gsub("[\r\n]", "", s)
while (any(grepl("  ", s, fixed = T)))
s <- gsub("  ", " ", s, fixed = T)
s <- gsub("^ ", "", s, perl = T)
s <- gsub(" $", "", s, perl = T)
while (any(grepl("<([^\\s>]+)[^>]*>([\\s\\S]*?)<\\/\\1>", s, perl = T)))
s <- gsub("<([^\\s>]+)[^>]*>([\\s\\S]*?)<\\/\\1>", "\\2", s, perl = T)
s <- gsub("<[^>]+\\/>", "", s)
s
}
#' Return the first match for a regexpr
reFirstMatch <- function(pattern, str, ...) {
re <- regexpr(pattern, str, ..., perl = T)
name <- substr(str, attr(re, "capture.start"),
attr(re, "capture.start") + attr(re, "capture.length") - 1)
name
}
expect_equal(reFirstMatch("\\w+\\W+(\\w+)", "First, Second, Third"), "Second")
#' rbind with NA padding for missing columns
#' @params x list of data frames to join
#' @params padWith value for missing entries
safeBind <- function(x, padWith = NA) {
out <- NULL
first <- T
for (y in x) {
if (!is.data.frame(y))
y <- as.data.frame(y)
if (first) {
out <- y
first <- F
} else {
y[, names(out)[names(out) %in% names(y) == F]] <- padWith
out[, names(y)[names(y) %in% names(out) == F]] <- padWith
out <- rbind(out, y)
}
}
out
}
expect_equal(dim(safeBind(list(data.frame(x = 1:5, y = runif(5), rnorm(5)),
data.frame(x = 6:10, z = 1:5)))),
c(10, 4))
#' List the unique values of a vector and a "total" item with all unique values
#' Designed for outputting aggregate counts and totals
uniqueTotal <- function(x) {
out <- as.list(unique(x))
out[[length(out) + 1]] <- unique(x)
out
}
expect_equal(uniqueTotal(c("a", "b", "c")),
list("a", "b", "c", c("a", "b", "c")))
#' List the files on the server matching the specified version
listServerFiles <- function(version) {
rDir <- "https://acclab.psy.ox.ac.uk/~mj221/ESM/data/public/"
out <- NULL
con <- curl(rDir)
open(con, "rb")
while (isIncomplete(con)) {
buffer <- readLines(con, n = 1)
if (length(buffer)) {
f <- reFirstMatch(paste0(">(datesStudy_v", version, "_[^<]+)"),
buffer)
if (nchar(f)) {
out <- c(out, paste0(rDir, f))
}
}
}
close(con)
out
}
version <- "1-0-1"
files <- listServerFiles(version)
# Screen for acceptable IDs
f <- files[grep("metadata", files)]
okayIds <- read.csv(f)
okayIds$okay <- grepl("prolific", okayIds$tags)
files <- files[grep("metadata", files, invert = T)]
# convert CSV files to tibbles
for (f in files) {
tmp <- as.tibble(read.csv(f))
# screen out non-okay ids
if ("pid" %in% names(tmp))
tmp <- tmp[tmp$pid %in% okayIds$pid[okayIds$okay], ]
# clean up stimulus text
if ("stimHTML" %in% names(tmp)) {
tmp$stimHTML <- stripTags(tmp$stimHTML)
}
# type coersion
if ("comment" %in% names(tmp))
tmp$comment <- as.character(tmp$comment)
n <- grep("advisor[0-9]+(name|validTypes|nominalType|actualType)$",
names(tmp), value = T)
for (x in n)
tmp[, x] <- lapply(tmp[, x], as.character)
n <- grep("responseEstimateLabel", names(tmp), value = T)
for (x in n)
tmp[, x] <- lapply(tmp[, x], function(y)
as.numeric(stripTags((as.character(y)))))
if ("responseMarkerWidth" %in% names(tmp))
tmp$responseMarker <- factor(tmp[["responseMarkerWidth"]])
if ("responseMarkerWidthFinal" %in% names(tmp))
tmp$responseMarkerFinal <- factor(tmp[["responseMarkerWidthFinal"]])
# assign to workspace
name <- reFirstMatch("([^_]+)\\.csv", f)
name <- sub("-", ".", name)
assign(name, tmp)
}
# Reference variables
# Gather a list of advisor names and advice types
# This is more complex than it needs to be because it handles a wider range of
# inputs than we give it here
names <- NULL
types <- NULL
i <- 0
while (T) {
if (!length(grep(paste0("advisor", i), names(AdvisedTrial)))) {
break()
}
names <- unique(c(names,
unique(AdvisedTrial[, paste0("advisor", i,
"idDescription")])))
types <- unique(c(types,
unique(AdvisedTrial[, paste0("advisor", i,
"actualType")]),
unique(AdvisedTrial[, paste0("advisor", i,
"nominalType")])))
i <- i + 1
}
advisorNames <- unlist(names)
adviceTypes <- unlist(types)
AdvisedTrial$advisor0offBrand <- AdvisedTrial$advisor0actualType ==
"disagreeReflected"
# Produce equivalents of the advisor1|2... variables which are named for the
# advisor giving the advice
for (v in names(AdvisedTrial)[grepl("advisor0", names(AdvisedTrial))]) {
suffix <- reFirstMatch("advisor0(\\S+)", v)
for (a in advisorNames) {
s <- paste0(a, ".", suffix)
AdvisedTrial[, s] <- NA
for (i in 1:nrow(AdvisedTrial)) {
x <- 0
while (T) {
if (!length(grep(paste0("advisor", x),
names(AdvisedTrial)))) {
break()
}
if (AdvisedTrial[i, paste0("advisor", x, "idDescription")] == a) {
AdvisedTrial[i, s] <- AdvisedTrial[i, paste0("advisor", x, suffix)]
break()
}
x <- x + 1
}
}
}
}
# Trials
# Check trials which are supposed to have feedback actually have it
AdvisedTrial$feedback[is.na(AdvisedTrial$feedback)] <- 0
AdvisedTrial$feedback <- as.logical(AdvisedTrial$feedback)
expect_equal(!is.na(AdvisedTrial$timeFeedbackOn), AdvisedTrial$feedback)
AdvisedTrial$responseCorrect <-
AdvisedTrial$correctAnswer >= AdvisedTrial$responseEstimateLeft &
AdvisedTrial$correctAnswer <= AdvisedTrial$responseEstimateLeft +
AdvisedTrial$responseMarkerWidth
AdvisedTrial$responseCorrectFinal <-
AdvisedTrial$correctAnswer >= AdvisedTrial$responseEstimateLeftFinal &
AdvisedTrial$correctAnswer <= AdvisedTrial$responseEstimateLeftFinal +
AdvisedTrial$responseMarkerWidthFinal
Trial$responseCorrect <-
Trial$correctAnswer >= Trial$responseEstimateLeft &
Trial$correctAnswer <= Trial$responseEstimateLeft +
Trial$responseMarkerWidth
AdvisedTrial$responseError <- abs(AdvisedTrial$correctAnswer -
AdvisedTrial$responseEstimateLeft +
(AdvisedTrial$responseMarkerWidth / 2))
AdvisedTrial$responseErrorFinal <- abs(AdvisedTrial$correctAnswer -
AdvisedTrial$responseEstimateLeftFinal
+ (AdvisedTrial$responseMarkerWidthFinal
/ 2))
AdvisedTrial$errorReduction <- AdvisedTrial$responseError -
AdvisedTrial$responseErrorFinal
AdvisedTrial$responseScore <-
ifelse(AdvisedTrial$responseCorrect,
27 / AdvisedTrial$responseMarkerWidth, 0)
AdvisedTrial$responseScoreFinal <-
ifelse(AdvisedTrial$responseCorrectFinal,
27 / AdvisedTrial$responseMarkerWidthFinal, 0)
AdvisedTrial$accuracyChange <- AdvisedTrial$responseCorrectFinal -
AdvisedTrial$responseCorrect
AdvisedTrial$scoreChange <- AdvisedTrial$responseScoreFinal -
AdvisedTrial$responseScore
AdvisedTrial$estimateLeftChange <- abs(AdvisedTrial$responseEstimateLeftFinal -
AdvisedTrial$responseEstimateLeft)
AdvisedTrial$changed <- AdvisedTrial$estimateLeftChange > 0
AdvisedTrial$confidenceChange <-
(4 - as.numeric(AdvisedTrial$responseMarkerFinal)) -
(4 - as.numeric(AdvisedTrial$responseMarker))
tmp <- AdvisedTrial[order(AdvisedTrial$number), ]
AdvisedTrial$firstAdvisor <- unlist(sapply(AdvisedTrial$pid,
function(x)
tmp[
tmp$pid == x,
"advisor0idDescription"][1, ]))
# Trials - advisor-specific variables
for (a in advisorNames) {
# Accuracy
AdvisedTrial[, paste0(a, ".accurate")] <-
(AdvisedTrial[, paste0(a, ".advice")] -
(AdvisedTrial[, paste0(a, ".adviceWidth")] / 2)) <=
AdvisedTrial[, "correctAnswer"] &
(AdvisedTrial[, paste0(a, ".advice")] +
(AdvisedTrial[, paste0(a, ".adviceWidth")] / 2)) >=
AdvisedTrial[, "correctAnswer"]
# Error
AdvisedTrial[, paste0(a, ".error")] <-
abs(AdvisedTrial[, paste0(a, ".advice")] - AdvisedTrial[, "correctAnswer"])
# Weight on Advice
i <- AdvisedTrial[, "responseEstimateLeft"] +
(AdvisedTrial[, "responseMarkerWidth"] - 1) / 2
f <- AdvisedTrial[, "responseEstimateLeftFinal"] +
(AdvisedTrial[, "responseMarkerWidthFinal"] - 1) / 2
adv <- AdvisedTrial[, paste0(a, ".advice")]
x <- ((f - i) / (adv - i))
AdvisedTrial[, paste0(a, ".woaRaw")] <- x
x[x < 0] <- 0
x[x > 1] <- 1
AdvisedTrial[, paste0(a, ".woa")] <- x
# Agreement
for (d in c("", "Final")) {
minA <- AdvisedTrial[, paste0(a, ".advice")] -
(AdvisedTrial[, paste0(a, ".adviceWidth")] / 2)
maxA <- AdvisedTrial[, paste0(a, ".advice")] +
(AdvisedTrial[, paste0(a, ".adviceWidth")] / 2)
minP <- AdvisedTrial[, paste0("responseEstimateLeft", d)]
maxP <- minP + AdvisedTrial[, paste0("responseMarkerWidth", d)]
AdvisedTrial[, paste0(a, ".agree", d)] <-
((minA >= minP) & (minA <= maxP)) | ((maxA >= minP) & (maxA <= minP))
# Distance
reMid <- minP + (maxP - minP) / 2
advice <- AdvisedTrial[, paste0(a, ".advice")]
AdvisedTrial[, paste0(a, ".distance", d)] <- abs(reMid - advice)
}
# Agreement change
AdvisedTrial[, paste0(a, ".agreementChange")] <-
AdvisedTrial[, paste0(a, ".agreeFinal")] -
AdvisedTrial[, paste0(a, ".agree")]
}
exclusions <- tibble(pid = unique(AdvisedTrial$pid))
exclusions$excluded <- F
for (p in unique(exclusions$pid)) {
excluded <- NULL
tmp <- Trial[Trial$pid == p, ]
if (any(tmp$responseCorrect == F))
excluded <- c(excluded, "attnCheckYear")
if (any(tmp$responseMarkerWidth != 1))
excluded <- c(excluded, "attnCheckMarker")
exclusions$excluded[exclusions$pid == p] <- ifelse(is.null(excluded),
F,
paste(excluded,
collapse = ", "))
}
table(exclusions$excluded)
# Drop excluded participants' trials
tmp <- NULL
for (i in 1:nrow(AdvisedTrial))
if (exclusions$excluded[exclusions$pid == AdvisedTrial$pid[i]] == F)
tmp <- rbind(tmp, AdvisedTrial[i, ])
AdvisedTrial <- tmp
for (p in unique(exclusions$pid)) {
if (!(p %in% debrief.advisors$pid)) {
exclusions$excluded[exclusions$pid == p] <-
if (exclusions$excluded[exclusions$pid == p] == F) "safari" else
paste(exclusions$excluded[exclusions$pid == p], ", ", "safari")
}
}
# Remove outlying trials
AdvisedTrial$outlier <- AdvisedTrial$timeEnd > maxTime
ggplot(AdvisedTrial, aes(x = "", y = timeEnd)) +
geom_hline(yintercept = maxTime, linetype = "dashed") +
geom_violin(alpha = .25, color = NA, fill = "grey75") +
geom_boxplot(outlier.shape = NA, fill = NA) +
geom_point(position = position_jitterdodge(.25, dodge.width = 1),
aes(colour = pid)) +
labs(x = "trials") +
scale_colour_manual(values = rep(c("lightblue", "pink"),
ceiling(length(unique(AdvisedTrial$pid)) /
2))) +
theme(legend.position = 'none')
table(AdvisedTrial$outlier)
nMaxOutliers <- 3
for (p in unique(exclusions$pid)) {
excluded <- exclusions$excluded[exclusions$pid == p]
if (excluded == F)
excluded <- NULL
if (length(AdvisedTrial$pid[AdvisedTrial$pid == p & AdvisedTrial$outlier != F]) >
nMaxOutliers)
excluded <- c(excluded, "outlyingTrials")
if (any(AdvisedTrial$outlier[AdvisedTrial$advisor0offBrand & AdvisedTrial$pid == p])) {
excluded <- c(excluded, "offBrandOutlier")
}
exclusions$excluded[exclusions$pid == p] <-
if (is.null(excluded)) F else paste(excluded, collapse = ", ")
}
table(exclusions$excluded)
# Drop excluded participants' trials
tmp <- NULL
for (i in 1:nrow(AdvisedTrial))
if (exclusions$excluded[exclusions$pid == AdvisedTrial$pid[i]] == F)
tmp <- rbind(tmp, AdvisedTrial[i, ])
AdvisedTrial <- tmp
# We're done with excluding trials individually.
# Produce a data frame of the trials where each decision gets a unique row
decisions <- AdvisedTrial[, !grepl("^response(?=\\S+Final$)",
names(AdvisedTrial),
perl = T)]
decisions <- rbind(decisions, decisions)
decisions$decision <- sapply(1:nrow(decisions),
function(x)
if (x <= nrow(AdvisedTrial)) "first" else "last")
for (i in (nrow(AdvisedTrial) + 1):nrow(decisions)) {
for (n in names(decisions)[grepl("^response", names(decisions), perl = T)]) {
decisions[i, n] <- AdvisedTrial[i - nrow(AdvisedTrial), paste0(n, "Final")]
}
}
# Participants data frame
ns <- c("timeEnd", "responseCorrect", "responseError", "number")
ss <- c("pid", "responseMarker", "feedback", "decision")
eq <- paste0("cbind(", paste(ns, collapse = ", "), ") ~ ",
paste(ss, collapse = " + "))
PP <- as.tibble(aggregate(as.formula(eq), decisions, mean))
PP$excluded <- sapply(PP$pid, function(p)
exclusions$excluded[exclusions$pid == p])
# record the n of each row so weighted averaging can be used later
PP$number <- aggregate(as.formula(paste("number ~",
paste(ss, collapse = " +"))),
decisions, length)$number
changes <- tibble(pid = exclusions$pid, pChange = 0)
for (p in exclusions$pid) {
tmp <- AdvisedTrial[AdvisedTrial$pid %in% p, ]
if (nrow(tmp) == 0)
next()
x <- mean(tmp$responseEstimateLeft != tmp$responseEstimateLeftFinal |
tmp$responseMarkerWidth != tmp$responseMarkerWidthFinal)
changes$pChange[changes$pid %in% p] <- x
if (x < minChangePercent) {
exclusions$excluded[exclusions$pid %in% p] <-
if (exclusions$excluded[exclusions$pid %in% p] == F) "pChange" else
paste(exclusions$excluded[exclusions$pid %in% p], ", ", "pChange")
}
}
ggplot(changes, aes(x = "", y = pChange, colour = pid)) +
geom_hline(yintercept = minChangePercent, linetype = "dashed") +
geom_point() +
scale_y_continuous(limits = c(0, 1))
checkList <- c("timeEnd", "responseError", "responseCorrect")
for (v in checkList) {
p <- aggregate(as.formula(paste(v, "~ pid + feedback")),
AdvisedTrial,
mean)
p[, v] <- scale(p[, v])
for (i in 1:nrow(p)) {
if (abs(p[i, v] <= zThresh))
next()
exclusions$excluded[exclusions$pid == p$pid[i]] <-
if (exclusions$excluded[exclusions$pid == p$pid[i]] == F) v else
paste(exclusions$excluded[exclusions$pid == p$pid[i]], ", ", v)
}
print(ggplot(p, aes(x = "", y = !!ensym(v), colour = feedback)) +
geom_rect(xmin = 0, xmax = 2, ymin = -zThresh, ymax = zThresh,
fill = "white", colour = NA) +
geom_hline(yintercept = 0, linetype = "dashed", colour = "black") +
geom_violin(alpha = .25, color = NA, fill = "grey75") +
geom_boxplot(outlier.shape = NA, fill = NA, aes(group = 1)) +
geom_point(position = position_jitter(.33), alpha = .5) +
labs(x = "participants", y = paste0(v, ".z")) +
theme(panel.background = element_rect(fill = "grey95"),
panel.grid.major.y = element_blank(),
panel.grid.minor.y = element_blank()))
}
PP$excluded <- sapply(PP$pid,
function(x) exclusions$excluded[exclusions$pid == x])
table(exclusions$excluded)
# by hash of prolific id
for (uid in unique(okayIds$uidHash)) {
ids <- okayIds$pid[okayIds$uidHash == uid]
# participants who have multiple attempts at core trials
if (length(ids[ids %in% AdvisedTrial[["pid"]]]) > 1) {
tmp <- exclusions[exclusions$pid %in% ids, ]
tmp$excluded <- ifelse(tmp$excluded == F,
"multipleAttempts",
paste(tmp$excluded, ", multipleAttempts"))
exclusions$excluded[exclusions$pid %in% ids, ] <- tmp$excluded
}
# participants who have answered the same question twice
tmp <- c(AdvisedTrial$stimHTML[AdvisedTrial$pid %in% ids],
practiceTrial$stimHTML[practiceTrial$pid %in% ids],
practiceAdvisedTrial$stimHTML[practiceAdvisedTrial$pid %in% ids])
if (length(tmp) > length(unique(tmp))) {
tmp <- exclusions[exclusions$pid %in% ids, ]
tmp$excluded <- ifelse(tmp$excluded == F,
"repeatedQuestion",
paste(tmp$excluded, ", repeatedQuestion"))
exclusions$excluded[exclusions$pid %in% ids, ] <- tmp$excluded
}
}
table(exclusions$excluded)
debrief.form$guessedManipulation <-
c(F, F, F, F, F, F, F, F, F, T,
F, F, F, F, F, F, F, T, F, T,
F, F, F, F, F, F, F, F, T, F,
F, T, F, F, F)
debrief.form$guessedManipulation <-
c(F, F, F, F, F, F, F, F, F, T,
F, F, F, F, F, F, F, T, F, T,
F, F, F, F, F, F, F, F, T, F,
F, T, F, F)
debrief.form[, c("pid", "comment", "guessedManipulation")]
for (p in exclusions$pid) {
if (p %in% debrief.form$pid) {
if (debrief.form$guessedManipulation[debrief.form$pid == p]) {
exclusions$excluded[exclusions$pid == p] <-
if (exclusions$excluded[exclusions$pid == p] == F)
"guessedManipulation" else
paste(c(exclusions$excluded[exclusions$pid == p],
"guessedManipulation"), collapse = ", ")
}
}
}
# Check for erroneous marker values
okayMarkers <- c(1, 3, 9, 27)
for (p in unique(AdvisedTrial$pid)) {
tmp <- AdvisedTrial[AdvisedTrial$pid == p, ]
if (!all(tmp$responseMarkerWidth %in% okayMarkers) |
!all(tmp$responseMarkerWidthFinal %in% okayMarkers)) {
if (p %in% exclusions$pid) {
exclusions$excluded[exclusions$pid == p] <-
if (exclusions$excluded[exclusions$pid == p] == F)
"badMarker" else
paste(c(exclusions$excluded[exclusions$pid == p],
"badMarker"), collapse = ", ")
}
}
}
table(exclusions$excluded)
n <- 5 # set by power analysis
for (x in unique(okayIds$condition)) {
i <- 0
for (p in exclusions$pid[exclusions$excluded == F]) {
if (okayIds$condition[okayIds$pid %in% p] == x) {
if (i >= n) {
exclusions$excluded[exclusions$pid == p] <- "excess"
} else {
i <- i + 1
}
}
}
}
table(exclusions$excluded)
AdvisedTrial <- AdvisedTrial[AdvisedTrial$pid %in%
exclusions$pid[exclusions$excluded == F], ]
decisions <- decisions[decisions$pid %in%
exclusions$pid[exclusions$excluded == F], ]
PP <- PP[PP$pid %in% exclusions$pid[exclusions$excluded == F], ]
# Drop extraneous factor levels
for (n in ls()) {
dirty <- F
x <- get(n)
if ("data.frame" %in% class(x)) {
for (i in 1:ncol(x)) {
if (is.factor(x[[i]])) {
x[[i]] <- factor(x[[i]]) # renew level assignment
dirty <- T
}
}
}
if (dirty) {
assign(n, x)
}
}
aggregate(pid ~ pid + firstAdvisor + feedback, AdvisedTrial,
function(x) length(unique(x)))
okayIds$condition[okayIds$pid %in%
exclusions$pid[exclusions$excluded == "excess"]]
table(exclusions$excluded[exclusions$pid %in%
okayIds$pid[okayIds$condition == 2]])
