tmp <- tmp$id[order(tmp$timeStart)]
tmp <- tmp[1:50]
participants$excluded[!(participants$id %in% tmp)] <- 'Excess'
}
# Perform exclusions
participants <- participants[participants$excluded==F, ]
# Remove excluded participants' data from other data frames
all.trials <- all.trials[all.trials$pid %in% participants$pid, ]
trials <- trials[trials$pid %in% participants$pid, ]
advisors <- advisors[advisors$pid %in% participants$pid, ]
questionnaires <- questionnaires[questionnaires$pid %in% participants$pid, ]
genTrustQ <- genTrustQ[genTrustQ$pid %in% participants$pid, ]
tmp <- advisorManipulationData(trials)
l.advisorDiff <- tmp
tmp <- prop2str(l.advisorDiff$summary, 3)
rownames(tmp) <- rownames(l.advisorDiff$summary)
kable(tmp)
# significane tests
for(i in 1:ncol(l.advisorDiff$data[ ,-1])) {
if(i %% 2 == 1) {
cat('\n\n')
next()
}
cat(md.ttest(l.advisorDiff$data[ ,i], l.advisorDiff$data[ ,i+1],
labels = paste0('*M*|', names(l.advisorDiff$data[i:(i+1)])),
isProportion = T, paired = T))
}
tmp <- aggregate(initialCorrect ~ pid + adviceType, trials, mean)
for(a in c(adviceTypes$AiC, adviceTypes$HighAcc, adviceTypes$HighAgr)) {
cat(md.ttestBF(tmp$initialCorrect[tmp$adviceType == a],
tmp$initialCorrect[tmp$adviceType == a+1],
labels = paste0('*M*|', getAdviceTypeName(c(a, a+1))),
isProportion = T, paired = T))
cat('\n\n')
}
df.choice <- NULL
pairs <- getAdviceTypePairs(c(trials$choice0, trials$choice1))
if(length(pairs) < 1) {
cat('*No choice trials in the current dataset.*')
} else {
df.choice <- data.frame(pid = unique(trials$pid))
for(pair in pairs) {
refAdvisor <- pair[1]
# Calculate choice proportions favouring reference advisor for each participant
choices <- sapply(df.choice$pid, function(pid) {
tmp <- trials[trials$pid == pid, ]
tmp <- tmp$advisorId[(tmp$choice0 == pair[1] | tmp$choice1 == pair[1])
& (tmp$choice0 == pair[2] | tmp$choice1 == pair[2])]
return(mean(tmp == refAdvisor, na.rm = T))
})
cat(md.ttest(choices, mu = .5, labels = paste0('*M*|', getAdviceTypeName(refAdvisor)), isProportion = T))
cat('\n\n')
tmp <- data.frame(choices)
colnames(tmp) <- getAdviceTypeName(refAdvisor)
df.choice <- cbind(df.choice, tmp);
}
}
# forest plot for choice trials
if(!is.null(df.choice)) {
tmp <- gather(df.choice, key = advisor, value = pickRate, -pid)
# calculate confidence intervals
tmp.CI <- NULL
for(pair in pairs) {
cis <- mean_cl_normal(tmp$pickRate[tmp$advisor == getAdviceTypeName(pair[1])])
tmp.CI <- rbind(tmp.CI, data.frame(advisor = getAdviceTypeName(pair[1]),
ymin = cis$ymin,
ymax = cis$ymax,
labelsL = getAdviceTypeName(pair[2], long = T),
labelsR = getAdviceTypeName(pair[1], long = T)))
}
ggplot(tmp, aes(x = pickRate, y = advisor)) +
geom_vline(linetype = 'dashed', xintercept = .5) +
geom_point(alpha = 0.5, col = 'black',
position = position_nudge(x = 0, y = -0.05)) +
geom_density_ridges(panel_scaling = F, scale = .5,
col = NA, fill = '#2299DD', alpha = .75) +
geom_segment(data = tmp.CI,
aes(y = advisor, yend = advisor,
x = ymin, xend = ymax),
size = 1, colour = '#2299DD',
position = position_nudge(x = 0, y = -0.2)) +
geom_point(data = aggregate(pickRate ~ advisor, tmp, mean), size = 4, shape = 18,
position = position_nudge(x = 0, y = -0.2)) +
scale_x_continuous(name = 'Pick rate', limits = c(-.5,1.5), expand = c(0,0),
breaks = seq(0,1,.5)) +
# label hack
geom_text(data = tmp.CI, aes(x = 0, label = labelsL), nudge_x = -.1, nudge_y = .15, hjust = 1) +
geom_text(data = tmp.CI, aes(x = 1, label = labelsR), nudge_x = .1, nudge_y = .15, hjust = 0) +
annotate(geom = 'rect', xmin = 0, xmax = 1, ymin = -Inf, ymax = Inf,
alpha = .025, linetype = 'solid', col = 'black') +
theme_light() +
theme(panel.grid = element_blank(),
panel.border = element_blank(),
axis.line.x = element_line(),
axis.text.y = element_blank(),
axis.title.y = element_blank(),
legend.position = 'top')
}
df.change <- NULL
pairs <- getAdviceTypePairs(c(trials$advisor0id, trials$advisor1id))
if(length(pairs) < 1) {
cat('*No change trials in the current dataset.*')
} else {
df.change <- data.frame(pid = unique(trials$pid))
for(pair in pairs) {
refAdvisor <- pair[1]
changes <- NULL
# Calculate change proportions favouring reference advisor for each participant
for(pid in unique(trials$pid)) {
tmp <- trials[trials$pid == pid & trials$type == trialTypes$change, ]
tmp <- tmp[tmp$advisor0id %in% pair & tmp$advisor1id %in% pair, ]
changed <- tmp$advisorId[tmp$defaultAdvisor != tmp$advisorId]
changes <- rbind(changes, data.frame(m = mean(changed == refAdvisor, na.rm = T),
p = sum(!is.na(changed)) / nrow(tmp)))
}
cat(md.ttest(changes$m, mu = .5, labels = getAdviceTypeName(refAdvisor), isProportion = T))
cat('\n\n')
colnames(changes) <- c(getAdviceTypeName(refAdvisor), paste0('PChange_', getAdviceTypeName(refAdvisor)))
df.change <- cbind(df.change, changes);
}
}
df.change <- NULL
pairs <- getAdviceTypePairs(c(trials$advisor0id, trials$advisor1id))
if(length(pairs) < 1) {
cat('*No change trials in the current dataset.*')
} else {
df.change <- data.frame(pid = unique(trials$pid))
for(pair in pairs) {
refAdvisor <- pair[1]
changes <- NULL
# Calculate change proportions favouring reference advisor for each participant
for(pid in unique(trials$pid)) {
tmp <- trials[trials$pid == pid & trials$type == trialTypes$change, ]
tmp <- tmp[tmp$advisor0id %in% pair & tmp$advisor1id %in% pair, ]
changed <- tmp$advisorId[tmp$defaultAdvisor != tmp$advisorId]
changes <- rbind(changes, data.frame(m = mean(changed == refAdvisor, na.rm = T),
p = sum(!is.na(changed)) / nrow(tmp)))
}
cat(md.ttest(changes$m, mu = .5, labels = getAdviceTypeName(refAdvisor), isProportion = T))
cat('\n\n')
colnames(changes) <- c(getAdviceTypeName(refAdvisor), paste0('PChange_', getAdviceTypeName(refAdvisor)))
df.change <- cbind(df.change, changes);
}
}
# forest plot for change trials
if(!is.null(df.change)) {
# shuffle the data a bit
tmp <- gather(df.change, key = advisor, value = pickRate, -pid)
tmp <- tmp[!grepl('_', tmp$advisor), ]
tmp$pChanged <- sapply(1:nrow(tmp), function(i) mean(df.change[df.change$pid == tmp$pid[i],
paste0('PChange_', tmp$advisor[i])]))
# calculate confidence intervals
tmp.CI <- NULL
for(pair in pairs) {
cis <- mean_cl_normal(tmp$pickRate[tmp$advisor == getAdviceTypeName(pair[1])])
tmp.CI <- rbind(tmp.CI, data.frame(advisor = getAdviceTypeName(pair[1]),
ymin = cis$ymin,
ymax = cis$ymax,
labelsL = getAdviceTypeName(pair[2], long = T),
labelsR = getAdviceTypeName(pair[1], long = T)))
}
ggplot(tmp, aes(x = pickRate, y = advisor)) +
geom_vline(linetype = 'dashed', xintercept = .5) +
geom_point(alpha = 0.5, col = 'black', aes(size = pChanged),
position = position_nudge(x = 0, y = -0.05)) +
geom_density_ridges(panel_scaling = F, scale = .5,
col = NA, fill = '#2299DD', alpha = .75) +
geom_segment(data = tmp.CI,
aes(y = advisor, yend = advisor,
x = ymin, xend = ymax),
size = 1, colour = '#2299DD',
position = position_nudge(x = 0, y = -0.2)) +
geom_point(data = aggregate(pickRate ~ advisor, tmp, mean), size = 4, shape = 18,
position = position_nudge(x = 0, y = -0.2)) +
scale_x_continuous(name = 'Balance of changes', limits = c(-.5,1.5), expand = c(0,0),
breaks = seq(0,1,.5)) +
# label hack
geom_text(data = tmp.CI, aes(x = 0, label = labelsL), nudge_x = -.1, nudge_y = .15, hjust = 1) +
geom_text(data = tmp.CI, aes(x = 1, label = labelsR), nudge_x = .1, nudge_y = .15, hjust = 0) +
annotate(geom = 'rect', xmin = 0, xmax = 1, ymin = -Inf, ymax = Inf,
alpha = .025, linetype = 'solid', col = 'black') +
theme_light() +
theme(panel.grid = element_blank(),
panel.border = element_blank(),
axis.line.x = element_line(),
axis.text.y = element_blank(),
axis.title.y = element_blank(),
legend.position = 'top')
}
if(length(pairs) < 1) {
cat('*No change trials in the current dataset.*')
} else {
for(pair in pairs) {
refAdvisor <- pair[1]
# Calculate default advisor = reference advisor proportions for each participant
defaults <- sapply(unique(trials$pid), function(pid) {
tmp <- trials[trials$pid == pid, ]
tmp <- tmp$advisorId[tmp$defaultAdvisor %in% pair]
return(mean(tmp == refAdvisor, na.rm = T))
})
cat(md.ttestBF(defaults, mu = .5, labels = getAdviceTypeName(refAdvisor), isProportion = T))
cat('\n\n')
}
}
pairs <- getAdviceTypePairs(trials$adviceType[trials$type == trialTypes$force])
for(pair in pairs) {
meta <- adviceTypes$AiC %in% pair
# subset data
tmp <- trials[trials$type == trialTypes$force
& trials$adviceType %in% pair, ]
if(meta)
tmp <- tmp[tmp$initialCorrect == T
& tmp$confidenceCategory == confidenceCategories$medium, ]
if(nrow(tmp) <= 0)
next()
# aggregate and factorize
tmp <- aggregate(advisorInfluence ~ adviceType + advisorAgrees + pid, tmp, mean)
for(v in names(tmp[ , -ncol(tmp)])) tmp[ ,v] <- factor(tmp[ ,v])
# check data are complete
if(nrow(tmp) != 2 * 2 * length(unique(tmp$pid))) {
print(paste('Incomplete data for ', getAdviceTypeName(pair[1], long = T),
'vs', getAdviceTypeName(pair[2], long = T), '- skipping.'))
next()
}
# analyse and print
x <- ezANOVA(data = tmp, dv = advisorInfluence, wid = pid,
within = .(adviceType, advisorAgrees),
return_aov = T)
print(paste('ANOVA results for', getAdviceTypeName(pair[1], long = T),
'vs', getAdviceTypeName(pair[2], long = T)))
print(prettifyEZ(x))
assign(paste0('inf.', getAdviceTypeName(pair[1])), x)
}
tmp <- trials[trials$type == trialTypes$dual, ]
for(pair in pairs) {
aNames <- paste0(getAdviceTypeName(pair), '_agrees')
# rearrange data so advisors are separated by type rather than order
df <- tmp[tmp$advisor0type %in% pair & tmp$advisor1type %in% pair, ]
df[ , aNames[1]] <- ifelse(df$advisor0type == pair[1], df$advisor0agrees, df$advisor1agrees)
df[ , aNames[2]] <- ifelse(df$advisor0type == pair[2], df$advisor0agrees, df$advisor1agrees)
if(nrow(df) == 0)
next()
print(paste('LM results for', getAdviceTypeName(pair[1], long = T),
'vs', getAdviceTypeName(pair[2], long = T)))
f <- as.formula(paste0("confidenceShift ~ pid + initialConfidence + (", aNames[1],
' * ', aNames[2], ')'))
model <- lm(f, data = df)
print(summary(model))
}
df.prInf <- NULL
for(pid in unique(trials$pid)) {
for(b in unique(trials$block[trials$type %in% c(trialTypes$choice, trialTypes$change)])) {
ts <- trials[trials$pid == pid & trials$block == b, ]
advisorIds <- unique(ts$advisorId)
# preference strength on choice trials
prefStrength <- ts$advisorId == advisorIds[1]
# influence difference on forced trials
ts <- trials[trials$pid == pid & trials$block == (b-1), ]
inf <- NULL
if(ts$type[1] == trialTypes$dual) {
for(a in advisorIds)
inf <- c(inf, mean(sapply(1:nrow(ts), function(i) {
trial <- ts[i, ]
if(trial$advisor0id == a) return(trial$advisor0influence)
if(trial$advisor1id == a) return(trial$advisor1influence)
return(NA)
}), na.rm = T))
} else {
# force trials
for(a in advisorIds)
inf <- c(inf, mean(ts$influence[ts$advisorId == a], na.rm = T))
}
# key to favourite advisor
if(prefStrength < .5) {
prefStrength <- 1-prefStrength
infDiff <- inf[2] - inf[1]
favAdvisorId <- advisorIds[1]
nfAdvisorId <- advisorIds[2]
} else {
infDiff <- inf[1] - inf[2]
favAdvisorId <- advisorIds[2]
nfAdvisorId <- advisorIds[1]
}
df.prInf <- rbind(df.prInf, data.frame(pid, prefStrength, infDiff,
favAdvisorId, nfAdvisorId,
favAdviceType = advisors$adviceType[advisors$pid == pid
& advisors$id == favAdvisorId],
nfAdviceType = advisors$adviceType[advisors$pid == pid
& advisors$id == nfAdvisorId]))
}
}
tmp <- aggregate(cbind(prefStrength, infDiff) ~ pid, df.prInf, FUN = mean) # reaggregate
cor.test(tmp$prefStrength, tmp$infDiff)
correlationBF(tmp$prefStrength, tmp$infDiff)
warings()
warnings()
df.prInf <- NULL
for(pid in unique(trials$pid)) {
for(b in unique(trials$block[trials$type %in% c(trialTypes$choice, trialTypes$change)])) {
ts <- trials[trials$pid == pid & trials$block == b, ]
advisorIds <- unique(ts$advisorId)
# preference strength on choice trials
prefStrength <- ts$advisorId == advisorIds[1]
# influence difference on forced trials
ts <- trials[trials$pid == pid & trials$block == (b-1), ]
inf <- NULL
if(ts$type[1] == trialTypes$dual) {
for(a in advisorIds)
inf <- c(inf, mean(sapply(1:nrow(ts), function(i) {
trial <- ts[i, ]
if(trial$advisor0id == a) return(trial$advisor0influence)
if(trial$advisor1id == a) return(trial$advisor1influence)
return(NA)
}), na.rm = T))
} else {
# force trials
for(a in advisorIds)
inf <- c(inf, mean(ts$advisorInfluence[ts$advisorId == a], na.rm = T))
}
# key to favourite advisor
if(prefStrength < .5) {
prefStrength <- 1-prefStrength
infDiff <- inf[2] - inf[1]
favAdvisorId <- advisorIds[1]
nfAdvisorId <- advisorIds[2]
} else {
infDiff <- inf[1] - inf[2]
favAdvisorId <- advisorIds[2]
nfAdvisorId <- advisorIds[1]
}
df.prInf <- rbind(df.prInf, data.frame(pid, prefStrength, infDiff,
favAdvisorId, nfAdvisorId,
favAdviceType = advisors$adviceType[advisors$pid == pid
& advisors$id == favAdvisorId],
nfAdviceType = advisors$adviceType[advisors$pid == pid
& advisors$id == nfAdvisorId]))
}
}
tmp <- aggregate(cbind(prefStrength, infDiff) ~ pid, df.prInf, FUN = mean) # reaggregate
cor.test(tmp$prefStrength, tmp$infDiff)
correlationBF(tmp$prefStrength, tmp$infDiff)
warnings()
df.prInf <- NULL
for(pid in unique(trials$pid)) {
for(b in unique(trials$block[trials$type %in% c(trialTypes$choice, trialTypes$change)])) {
ts <- trials[trials$pid == pid & trials$block == b, ]
advisorIds <- unique(ts$advisorId)
# preference strength on choice trials
prefStrength <- mean(ts$advisorId == advisorIds[1], na.rm = T)
# influence difference on forced trials
ts <- trials[trials$pid == pid & trials$block == (b-1), ]
inf <- NULL
if(ts$type[1] == trialTypes$dual) {
for(a in advisorIds)
inf <- c(inf, mean(sapply(1:nrow(ts), function(i) {
trial <- ts[i, ]
if(trial$advisor0id == a) return(trial$advisor0influence)
if(trial$advisor1id == a) return(trial$advisor1influence)
return(NA)
}), na.rm = T))
} else {
# force trials
for(a in advisorIds)
inf <- c(inf, mean(ts$advisorInfluence[ts$advisorId == a], na.rm = T))
}
# key to favourite advisor
if(prefStrength < .5) {
prefStrength <- 1-prefStrength
infDiff <- inf[2] - inf[1]
favAdvisorId <- advisorIds[1]
nfAdvisorId <- advisorIds[2]
} else {
infDiff <- inf[1] - inf[2]
favAdvisorId <- advisorIds[2]
nfAdvisorId <- advisorIds[1]
}
df.prInf <- rbind(df.prInf, data.frame(pid, prefStrength, infDiff,
favAdvisorId, nfAdvisorId,
favAdviceType = advisors$adviceType[advisors$pid == pid
& advisors$id == favAdvisorId],
nfAdviceType = advisors$adviceType[advisors$pid == pid
& advisors$id == nfAdvisorId]))
}
}
tmp <- aggregate(cbind(prefStrength, infDiff) ~ pid, df.prInf, FUN = mean) # reaggregate
cor.test(tmp$prefStrength, tmp$infDiff)
correlationBF(tmp$prefStrength, tmp$infDiff)
ggplot(tmp, aes(y = prefStrength, x = infDiff)) +
geom_rect(xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = .5, fill = 'grey', alpha = .5) +
geom_rect(xmin = -Inf, xmax = Inf, ymin = 1, ymax = Inf, fill = 'grey', alpha = .5) +
geom_smooth(method = 'lm', fill = 'lightblue', alpha = 0.5) +
geom_point(aes(colour = as.factor(pid))) +
labs(title = 'Influence difference and preference strength for preferred advisor',
y = 'P(Preferred advisor chosen)',
x = 'Mean Influence difference on Forced trials') +
scale_x_continuous(expand = c(0,0.2)) +
style.long
?gather
.libPaths()
ts <- trials[trials$pid == pid & !(trials$type %in% c(trialTypes$catch, trialTypes$dual)),
c('initialConfidence', 'advisorId', 'advisorAgrees', 'confidenceShift')]
ts <- cbind(ts, data.frame(otherAdvisorAgrees = rep(NA, nrow(ts))))
ts <- ts[ ,c(1:3, 5, 4)]
tmp <- trials[trials$pid == pid & trials$type == trialTypes$dual, ]
tmp$advisorId <- tmp$advisor0id
tmp$advisorAgrees <- tmp$advisor0agrees
tmp$otherAdvisorAgrees <- tmp$advisor1agrees
ts <- rbind(ts, tmp[ , names(tmp) %in% names(ts)])
ts <- trials[trials$pid == pid & !(trials$type %in% c(trialTypes$catch, trialTypes$dual)),
c('initialConfidence', 'advisorId', 'advisorAgrees', 'confidenceShift')]
ts <- cbind(ts, data.frame(otherAdvisorAgrees = rep(NA, nrow(ts))))
ts <- ts[ ,c(1:3, 5, 4)]
tmp <- trials[trials$pid == pid & trials$type == trialTypes$dual, ]
tmp$advisorId <- tmp$advisor0id
tmp$advisorAgrees <- tmp$advisor0agrees
tmp$otherAdvisorAgrees <- tmp$advisor1agrees
ts <- rbind(ts, tmp[ , names(tmp) %in% names(ts)])
Rcpp::sourceCpp('src/model.cpp')
tmp <- gradientDescent(ts); tmp
Rcpp::sourceCpp('src/model.cpp', rebuild = T)
tmp <- gradientDescent(ts); tmp
Rcpp::sourceCpp('src/model.cpp', rebuild = T)
tmp <- gradientDescent(ts); tmp
Rcpp::sourceCpp('src/model.cpp', rebuild = T)
tmp <- gradientDescent(ts); tmp
Rcpp::sourceCpp('src/model.cpp', rebuild = T)
tmp <- gradientDescent(ts); tmp
Rcpp::sourceCpp('src/model.cpp', rebuild = T)
tmp <- gradientDescent(ts); tmp
Rcpp::sourceCpp('src/model.cpp', rebuild = T)
tmp <- gradientDescent(ts); tmp
Rcpp::sourceCpp('src/model.cpp', rebuild = T)
Rcpp::sourceCpp('src/model.cpp', rebuild = T)
tmp <- gradientDescent(ts); tmp
Rcpp::sourceCpp('src/model.cpp', rebuild = T)
tmp <- gradientDescent(ts); tmp
Rcpp::sourceCpp('src/model.cpp', rebuild = T)
tmp <- gradientDescent(ts); tmp
Rcpp::sourceCpp('src/model.cpp')
tmp <- gradientDescent(ts); tmp
# Mould the data into the format expected by the c++ code
ts <- trials[trials$pid == pid & trials$type != trialTypes$catch, ]
input <- ts[ , c('initialConfidence')]
input$a1agrees <- getAdviceByType(ts, pair[1])
input$a2agrees <- getAdviceByType(ts, pair[2])
input$confidenceShift <- ts$confidenceShift
input
getAdviceByType(ts, pair[1])
getAdviceByType(ts, pair[2])
input <- ts[ , c('initialConfidence')]
input
getAdviceByType(ts, pair[1])
input$a1agrees <- getAdviceByType(ts, pair[1])
input <- ts[ , c('initialConfidence')]
typeof(input)
typeof(getAdviceByType(ts, pair[1]))
head(cbind(ts$initialConfidence, getAdviceByType(ts, pair[1])))
head(cbind(ts$initialConfidence, getAdviceByType(ts, pair[1]), getAdviceType(ts, pair[2])))
head(cbind(ts$initialConfidence, getAdviceByType(ts, pair[1]), getAdviceType(ts, pair[2]), ts$confidenceShift))
# Mould the data into the format expected by the c++ code
ts <- trials[trials$pid == pid & trials$type != trialTypes$catch, ]
input <- cbind(ts$initialConfidence,
getAdviceByType(ts, pair[1]),
getAdviceType(ts, pair[2]),
ts$confidenceShift)
head(input)
input
input[251:400, ]
input[400:nrow(input), ]
input <- cbind(ts$initialConfidence,
getAdviceByType(ts, pair[1]),
getAdviceByType(ts, pair[2]),
ts$confidenceShift)
input[350:nrow(input), ]
input[ts$type == trialTypes$dual, ]
input <- cbind(ts$initialConfidence,
getAdviceByType(ts, pair[1]),
getAdviceByType(ts, pair[2]),
ts$confidenceShift)
input
Rcpp::sourceCpp('src/models.cpp')
tmp <- gradientDescent(input); tmp
tmp <- gradientDescent(input, rep(1,nrow(input))); tmp
tmp <- gradientDescent(input, rep(1,nrow(input)), 5, .05); tmp
Rcpp::sourceCpp('src/models.cpp', rebuild = T)
tmp <- gradientDescent(input); tmp
Rcpp::sourceCpp('src/models.cpp', rebuild = T)
tmp <- gradientDescent(input); tmp
Rcpp::sourceCpp('src/models.cpp', rebuild = T)
tmp <- gradientDescent(input); tmp
Rcpp::sourceCpp('src/models.cpp', rebuild = T)
Rcpp::sourceCpp('src/models.cpp', rebuild = T)
tmp <- gradientDescent(input); tmp
Rcpp::sourceCpp('src/models.cpp')
tmp <- gradientDescent(input); tmp
# Mould the data into the format expected by the c++ code
ts <- trials[trials$pid == pid & trials$type != trialTypes$catch, ]
input <- cbind(scale(ts$initialConfidence),
getAdviceByType(ts, pair[1]),
getAdviceByType(ts, pair[2]),
scale(ts$confidenceShift))
# Run the models
modelResults <- gradientDescent(input)
modelResults
head(input)
mean(modelResults$errors[1] ^ 2)
mean(modelResults$errors$Model1 ^ 2)
t(modelResults$MSE)
# Save a summary of the result
tmp <- modelResults$parameters
tmp$mse <- t(modelResults$MSE)
tmp
