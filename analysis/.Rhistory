style.long
ggplot(tmp, aes(x = refAdvisor, y = pickRate, fill = advisorClass)) +
geom_violin(colour = NA, alpha = .5) +
geom_point(position = position_dodge(.9), alpha = .5,
aes(colour = factor(pid), size = nChanges)) +
stat_summary(geom = 'point', aes(group = advisorClass), fun.y = mean, shape = 18, size = 5,
position = position_dodge(.9)) +
stat_summary(geom = 'errorbar', aes(group = advisorClass), fun.data = mean_cl_normal, width = .25,
position = position_dodge(.9)) +
scale_y_continuous(limits = c(0,1)) +
labs(y = 'P(Gave advice)', x = "advisor",
subtitle = "Violins show distributions for Advisors (pink) and Cues (blue).\nDots show means for individual participants,\nwith the size inidicating the number of changes made.") +
style.long
tmp <- gather(df.change, key = "refAdvisor", value="pickRate", -(c(1, ncol(df.change)-1, ncol(df.change))))
ggplot(tmp, aes(x = refAdvisor, y = pickRate, fill = advisorClass)) +
geom_violin(colour = NA, alpha = .5) +
geom_point(position = position_dodge(.9), alpha = .5,
aes(colour = factor(pid), size = nChanges)) +
stat_summary(geom = 'point', aes(group = advisorClass), fun.y = mean, shape = 18, size = 5,
position = position_dodge(.9)) +
stat_summary(geom = 'errorbar', aes(group = advisorClass), fun.data = mean_cl_normal, width = .25,
position = position_dodge(.9)) +
scale_y_continuous(limits = c(0,1)) +
labs(y = 'P(Gave advice)', x = "advisor",
subtitle = "Violins show distributions for Advisors (pink) and Cues (blue).\nDots show means for individual participants,\nwith the size inidicating the number of changes made.") +
style.long
ggplot(tmp, aes(x = refAdvisor, y = pickRate, fill = advisorClass)) +
geom_violin(colour = NA, alpha = .5) +
geom_point(alpha = .5,
aes(colour = factor(pid), size = nChanges)) +
stat_summary(geom = 'point', aes(group = advisorClass), fun.y = mean, shape = 18, size = 5,
position = position_dodge(.9)) +
stat_summary(geom = 'errorbar', aes(group = advisorClass), fun.data = mean_cl_normal, width = .25,
position = position_dodge(.9)) +
scale_y_continuous(limits = c(0,1)) +
labs(y = 'P(Gave advice)', x = "advisor",
subtitle = "Violins show distributions for Advisors (pink) and Cues (blue).\nDots show means for individual participants,\nwith the size inidicating the number of changes made.") +
style.long
ggplot(tmp, aes(x = refAdvisor, y = pickRate, fill = advisorClass)) +
geom_violin(colour = NA, alpha = .5) +
geom_point(position = position_dodge(.9), alpha = .5,
aes(colour = factor(pid), size = nChanges)) +
stat_summary(geom = 'point', aes(group = advisorClass), fun.y = mean, shape = 18, size = 5,
position = position_dodge(.9)) +
stat_summary(geom = 'errorbar', aes(group = advisorClass), fun.data = mean_cl_normal, width = .25,
position = position_dodge(.9)) +
scale_y_continuous(limits = c(0,1)) +
labs(y = 'P(Gave advice)', x = "advisor",
subtitle = "Violins show distributions for Advisors (pink) and Cues (blue).\nDots show means for individual participants,\nwith the size inidicating the number of changes made.") +
style.long
ggplot(tmp, aes(x = refAdvisor, y = pickRate, fill = advisorClass)) +
geom_violin(colour = NA, alpha = .5) +
geom_point(position = position_dodge(.5), alpha = .5,
aes(colour = factor(pid), size = nChanges)) +
stat_summary(geom = 'point', aes(group = advisorClass), fun.y = mean, shape = 18, size = 5,
position = position_dodge(.9)) +
stat_summary(geom = 'errorbar', aes(group = advisorClass), fun.data = mean_cl_normal, width = .25,
position = position_dodge(.9)) +
scale_y_continuous(limits = c(0,1)) +
labs(y = 'P(Gave advice)', x = "advisor",
subtitle = "Violins show distributions for Advisors (pink) and Cues (blue).\nDots show means for individual participants,\nwith the size inidicating the number of changes made.") +
style.long
ggplot(tmp, aes(x = refAdvisor, y = pickRate, fill = advisorClass)) +
geom_violin(colour = NA, alpha = .5) +
geom_point(position = position_dodge(1), alpha = .5,
aes(colour = factor(pid), size = nChanges)) +
stat_summary(geom = 'point', aes(group = advisorClass), fun.y = mean, shape = 18, size = 5,
position = position_dodge(.9)) +
stat_summary(geom = 'errorbar', aes(group = advisorClass), fun.data = mean_cl_normal, width = .25,
position = position_dodge(.9)) +
scale_y_continuous(limits = c(0,1)) +
labs(y = 'P(Gave advice)', x = "advisor",
subtitle = "Violins show distributions for Advisors (pink) and Cues (blue).\nDots show means for individual participants,\nwith the size inidicating the number of changes made.") +
style.long
ggplot(tmp2, aes(x = refAdvisor, y = pickRate, fill = advisorClass)) +
geom_violin(colour = NA, alpha = .5) +
geom_point(position = position_jitterdodge(jitter.width = .1, dodge.width = .9), alpha = .5,
aes(colour = factor(pid), size = nChanges)) +
stat_summary(geom = 'point', aes(group = advisorClass), fun.y = mean, shape = 18, size = 5,
position = position_dodge(.9)) +
stat_summary(geom = 'errorbar', aes(group = advisorClass), fun.data = mean_cl_normal, width = .25,
position = position_dodge(.9)) +
scale_y_continuous(limits = c(0,1)) +
labs(y = 'P(Changed to)', x = "advisor",
subtitle = "Violins show distributions for Advisors (pink) and Cues (blue).\nDots show means for individual participants,\nwith the size inidicating the number of changes made.") +
style.long
ggplot(tmp2, aes(x = refAdvisor, y = pickRate, fill = advisorClass)) +
geom_violin(colour = NA, alpha = .5) +
geom_point(position = position_jitterdodge(jitter.width = .1, dodge.width = .9), alpha = 1,
aes(colour = factor(pid), size = nChanges)) +
stat_summary(geom = 'point', aes(group = advisorClass), fun.y = mean, shape = 18, size = 5,
position = position_dodge(.9)) +
stat_summary(geom = 'errorbar', aes(group = advisorClass), fun.data = mean_cl_normal, width = .25,
position = position_dodge(.9)) +
scale_y_continuous(limits = c(0,1)) +
labs(y = 'P(Changed to)', x = "advisor",
subtitle = "Violins show distributions for Advisors (pink) and Cues (blue).\nDots show means for individual participants,\nwith the size inidicating the number of changes made.") +
style.long
ggplot(tmp, aes(x = refAdvisor, y = pickRate, fill = advisorClass)) +
geom_violin(colour = NA, alpha = .5) +
geom_point(position = position_jitterdodge(jitter.width = .1, dodge.width = .9), alpha = 1,
aes(colour = factor(pid), size = nChanges)) +
stat_summary(geom = 'point', aes(group = advisorClass), fun.y = mean, shape = 18, size = 5,
position = position_dodge(.9)) +
stat_summary(geom = 'errorbar', aes(group = advisorClass), fun.data = mean_cl_normal, width = .25,
position = position_dodge(.9)) +
scale_y_continuous(limits = c(0,1)) +
labs(y = 'P(Gave advice)', x = "advisor",
subtitle = "Violins show distributions for Advisors (pink) and Cues (blue).\nDots show means for individual participants,\nwith the size inidicating the number of changes made.") +
style.long
refAdvisor <- pair[1]
# Calculate default advisor = reference advisor proportions for each participant
defaults <- sapply(unique(trials$pid), function(pid) {
tmp <- trials[trials$pid == pid & trials$type == trialTypes$change, ]
tmp <- tmp$defaultAdvisor[tmp$defaultAdvisor %in% pair]
return(mean(tmp == refAdvisor, na.rm = T))
})
md.ttestBF(defaults, mu = .5, labels = getAdviceTypeName(refAdvisor), isProportion = T)
defaults
?cut
hist(trials$initialConfidence)
hist(cut(trials$initialConfidence, 5))
cut(trials$initialConfidence, 5)
tmp <- cut(trials$initialConfidence, 5)
head(tmp)
cut(trials$initialConfidence, seq(1,50,5))
cut(trials$initialConfidence, seq(1,50,length.out = 5))
cut(trials$initialConfidence, seq(0,50,length.out = 5))
seq(0,50,length.out = 5)
df.type2 <- NULL
for(p in unique(trials$pid)) {
for(d in c('initial', 'final')) {
tmp <- trials[trials$pid == p, c(paste0(d, 'Correct'), paste0(d, 'Confidence'))]
# remove NA values which appear in final judgements which are never made
tmp <- tmp[!is.na(tmp[ ,1]), ]
roc <- type2ROC(tmp[ ,1], tmp[ ,2], 5)
df.type2 <- rbind(df.type2, data.frame(pid = factor(p), decision = d, conf = roc$x, pCorrect = roc$y))
}
}
tmp <- aggregate(. ~ pid + decision, df.type2, mean)
tmp <- tmp[order(tmp$pid),]
# print neatly with rounding
kable(prop2str(aggregate(pCorrect ~ decision, tmp, mean)))
tmp
#' @param correctness vector of correctness of judgements
#' @param confidence vector of the confidence of judgements
#' @param bins number of bins to use, or NA if data should be judged by each confidence value individually
#' @return type 2 receiver operator characterisitc curve points
type2ROC <- function(correctness, confidence, bins = NA) {
if(!is.na(bins))
confidence <- cut(confidence, seq(0, 50, length.out = bins))
points <- data.frame(x = unique(confidence), y = NA)
for(i in 1:nrow(points)) {
points$y[i] <- mean(correctness[confidence == points$x[i]])
}
# scale x values
points$x <- points$x / max(points$x)
return(points)
}
type2ROC(tmp[ ,1], tmp[ ,2], 5)
37.5/50
#' @param correctness vector of correctness of judgements
#' @param confidence vector of the confidence of judgements
#' @param bins number of bins to use, or NA if data should be judged by each confidence value individually
#' @return type 2 receiver operator characterisitc curve points
type2ROC <- function(correctness, confidence, bins = NA) {
if(!is.na(bins))
confidence <- cut(confidence, seq(0, 50, length.out = bins))
points <- data.frame(x = unique(confidence), y = NA)
for(i in 1:nrow(points)) {
points$y[i] <- mean(correctness[confidence == points$x[i]])
}
if(!is.na(bins)) {
points$x <- seq(0, 1, length.out = bins)
return(points)
}
# scale x values
points$x <- points$x / max(points$x)
return(points)
}
type2ROC(tmp[ ,1], tmp[ ,2], 5)
type2ROC(tmp[ ,1], tmp[ ,2], 5)
bins <- 5
tmp <- seq(0, 1, length.out = bins)
tmp
sapply(1:3, function(i) mean(c(tmp[i], tmp[i+1])))
#' @param correctness vector of correctness of judgements
#' @param confidence vector of the confidence of judgements
#' @param bins number of bins to use, or NA if data should be judged by each confidence value individually
#' @return type 2 receiver operator characterisitc curve points
type2ROC <- function(correctness, confidence, bins = NA) {
if(!is.na(bins))
confidence <- cut(confidence, seq(0, 50, length.out = bins))
points <- data.frame(x = unique(confidence), y = NA)
for(i in 1:nrow(points)) {
points$y[i] <- mean(correctness[confidence == points$x[i]])
}
if(!is.na(bins)) {
tmp <- seq(0, 1, length.out = bins)
points$x <- sapply(1:length(points$x), function(i) mean(c(tmp[i], tmp[i+1])))
return(points)
}
# scale x values
points$x <- points$x / max(points$x)
return(points)
}
type2ROC(tmp[ ,1], tmp[ ,2], 5)
correct <- tmp[,1]
tmp
tmp <- trials[trials$pid == p, c(paste0(d, 'Correct'), paste0(d, 'Confidence'))]
# remove NA values which appear in final judgements which are never made
tmp <- tmp[!is.na(tmp[ ,1]), ]
type2ROC(tmp[ ,1], tmp[ ,2], 5)
correctness <- tmp[,1]
confidence <- tmp[,2]
tmp
cor.test(tmp[,1], tmp[,2])
lm(initialCorrect ~ initialConfidence, data = tmp, family = 'binom')
cut(confidence, seq(0, 50, length.out = bins))
confidence <- cut(confidence, seq(0, 50, length.out = bins))
points <- data.frame(x = unique(confidence), y = NA)
confidence
points
mean(correctness[confidence == points$x[1]])
points <- points[order(points$x), ]
points
#' @param correctness vector of correctness of judgements
#' @param confidence vector of the confidence of judgements
#' @param bins number of bins to use, or NA if data should be judged by each confidence value individually
#' @return type 2 receiver operator characterisitc curve points
type2ROC <- function(correctness, confidence, bins = NA) {
if(!is.na(bins))
confidence <- cut(confidence, seq(0, 50, length.out = bins))
points <- data.frame(x = unique(confidence), y = NA)
for(i in 1:nrow(points)) {
points$y[i] <- mean(correctness[confidence == points$x[i]])
}
points <- points[order(points$x), ]
if(!is.na(bins)) {
tmp <- seq(0, 1, length.out = bins)
points$x <- sapply(1:length(points$x), function(i) mean(c(tmp[i], tmp[i+1])))
return(points)
}
# scale x values
points$x <- points$x / max(points$x)
return(points)
}
roc <- type2ROC(tmp[ ,1], tmp[ ,2], 7)
roc
roc <- type2ROC(tmp[ ,1], tmp[ ,2], bins = 7)
roc
#' @param correctness vector of correctness of judgements
#' @param confidence vector of the confidence of judgements
#' @param bins number of bins to use, or NA if data should be judged by each confidence value individually
#' @return type 2 receiver operator characterisitc curve points
type2ROC <- function(correctness, confidence, bins = NA) {
if(!is.na(bins))
confidence <- cut(confidence, seq(0, 50, length.out = bins))
points <- data.frame(x = unique(confidence), y = NA)
for(i in 1:nrow(points)) {
points$y[i] <- mean(correctness[confidence == points$x[i]])
}
points <- points[order(points$x), ]
if(!is.na(bins)) {
points$bin <- points$x
tmp <- seq(0, 1, length.out = bins)
points$x <- sapply(1:length(points$x), function(i) mean(c(tmp[i], tmp[i+1])))
return(points)
}
# scale x values
points$x <- points$x / max(points$x)
return(points)
}
type2ROC(tmp[ ,1], tmp[ ,2], bins = 7)
#' @param correctness vector of correctness of judgements
#' @param confidence vector of the confidence of judgements
#' @param bins number of bins to use, or NA if data should be judged by each confidence value individually
#' @return type 2 receiver operator characterisitc curve points
type2ROC <- function(correctness, confidence, bins = NA) {
if(!is.na(bins))
confidence <- cut(confidence, seq(0, 50, length.out = bins))
points <- data.frame(x = unique(confidence), y = NA)
for(i in 1:nrow(points)) {
points$y[i] <- mean(correctness[confidence == points$x[i]])
}
points <- points[order(points$x), ]
if(!is.na(bins)) {
points$bin <- points$x
points$x <- seq(0, 1, length.out = bins-2)
return(points)
}
# scale x values
points$x <- points$x / max(points$x)
return(points)
}
type2ROC(tmp[ ,1], tmp[ ,2], bins = 7)
seq(0, 1, length.out = bins-1)[2:bins-1]
seq(0, 1, length.out = bins-1)[2:bins]
bins
2:bins-2
seq(0, 1, length.out = bins-1)[2:bins-2]
seq(0, 1, length.out = bins-1)
seq(0, 1, length.out = bins)[2:bins-1]
seq(0, 1, length.out = bins)
seq(0, 1, length.out = bins)[2:(bins-1)]
seq(0, 1, length.out = bins-1)[2:(bins-1)]
seq(0, 1, length.out = bins-1)
seq(0, 1, length.out = bins)
seq(0, 1, length.out = bins)[2:(bins-1)]
points
mean(as.numeric(points$x[1]))
as.numeric(points$x[1])
seq(0, 50, length.out = bins)
seq(0, 50, length.out = bins-2)
#' @param correctness vector of correctness of judgements
#' @param confidence vector of the confidence of judgements
#' @param bins number of bins to use, or NA if data should be judged by each confidence value individually
#' @return type 2 receiver operator characterisitc curve points
type2ROC <- function(correctness, confidence, bins = NA) {
if(!is.na(bins))
confidence <- cut(confidence, seq(0, 50, length.out = bins))
points <- data.frame(x = unique(confidence), y = NA)
for(i in 1:nrow(points)) {
points$y[i] <- mean(correctness[confidence == points$x[i]])
}
points <- points[order(points$x), ]
# scale x values
#points$x <- points$x / max(points$x)
return(points)
}
type2ROC(tmp[ ,1], tmp[ ,2], bins = 7)
roc <- type2ROC(tmp[ ,1], tmp[ ,2], bins = 7)
df.type2 <- rbind(df.type2, data.frame(pid = factor(p), decision = d, conf = roc$x, pCorrect = roc$y))
df.type2 <- NULL
for(p in unique(trials$pid)) {
for(d in c('initial', 'final')) {
tmp <- trials[trials$pid == p, c(paste0(d, 'Correct'), paste0(d, 'Confidence'))]
# remove NA values which appear in final judgements which are never made
tmp <- tmp[!is.na(tmp[ ,1]), ]
roc <- type2ROC(tmp[ ,1], tmp[ ,2], bins = 7)
df.type2 <- rbind(df.type2, data.frame(pid = factor(p), decision = d, conf = roc$x, pCorrect = roc$y))
}
}
tmp <- aggregate(. ~ pid + decision, df.type2, mean)
tmp <- tmp[order(tmp$pid),]
# print neatly with rounding
kable(prop2str(aggregate(pCorrect ~ decision, tmp, mean)))
aggregate(. ~ pid + decision, df.type2, mean)
type2ROC(tmp[ ,1], tmp[ ,2], bins = 7)
tmp <- trials[trials$pid == p, c(paste0(d, 'Correct'), paste0(d, 'Confidence'))]
# remove NA values which appear in final judgements which are never made
tmp <- tmp[!is.na(tmp[ ,1]), ]
roc <- type2ROC(tmp[ ,1], tmp[ ,2], bins = 7)
roc
df.type2 <- NULL
data.frame(pid = factor(p), decision = d, conf = roc$x, pCorrect = roc$y)
df.type2 <- rbind(df.type2, data.frame(pid = factor(p), decision = d, conf = roc$x, pCorrect = roc$y))
df.type2 <- NULL
for(p in unique(trials$pid)) {
for(d in c('initial', 'final')) {
tmp <- trials[trials$pid == p, c(paste0(d, 'Correct'), paste0(d, 'Confidence'))]
# remove NA values which appear in final judgements which are never made
tmp <- tmp[!is.na(tmp[ ,1]), ]
roc <- type2ROC(tmp[ ,1], tmp[ ,2], bins = 7)
df.type2 <- rbind(df.type2, data.frame(pid = factor(p), decision = d, conf = roc$x, pCorrect = roc$y))
}
}
df.type2
aggregate(. ~ pid + decision, df.type2, mean)
aggregate(. ~ conf + decision + , df.type2, mean)
aggregate(pCorrect ~ conf + decision, df.type2, mean)
# print neatly with rounding
tmp[ ,3] <- prop2str(tmp[ ,3])
tmp[ ,3]
tmp <- aggregate(pCorrect ~ conf + decision, df.type2, mean)
# print neatly with rounding
tmp[ ,3] <- prop2str(tmp[ ,3])
kable(prop2str(tmp))
ggplot(df.type2, aes(x = conf, y = pCorrect, colour = pid)) +
geom_point() +
geom_line(alpha = .5) +
facet_wrap(~decision, labeller = label_both) +
coord_fixed() +
style +
theme(panel.spacing.x = unit(2, 'lines'))
df.type2
ggplot(df.type2, aes(x = conf, y = pCorrect, colour = pid)) +
geom_point() +
geom_line(alpha = .5, aes(group = pid)) +
facet_wrap(~decision, labeller = label_both) +
coord_fixed() +
style +
theme(panel.spacing.x = unit(2, 'lines'))
ggplot(df.type2, aes(x = conf, y = pCorrect, colour = pid)) +
geom_point() +
geom_line(alpha = .5, aes(group = pid)) +
facet_wrap(~decision, labeller = label_both) +
coord_fixed() +
style.long +
theme(panel.spacing.x = unit(2, 'lines'))
ggplot(df.type2, aes(x = 1:5, y = pCorrect, colour = pid)) +
geom_point() +
geom_line(alpha = .5, aes(group = pid)) +
facet_wrap(~decision, labeller = label_both) +
coord_fixed() +
style.long +
theme(panel.spacing.x = unit(2, 'lines'))
ggplot(df.type2, aes(x = conf, y = pCorrect, colour = pid)) +
geom_point() +
geom_line(alpha = .5, aes(group = pid)) +
facet_wrap(~decision, labeller = label_both) +
coord_fixed() +
style.long +
theme(panel.spacing.x = unit(2, 'lines'))
ggplot(df.type2, aes(x = conf, y = pCorrect * 40, colour = pid)) +
geom_point() +
geom_line(alpha = .5, aes(group = pid)) +
facet_wrap(~decision, labeller = label_both) +
coord_fixed() +
style.long +
theme(panel.spacing.x = unit(2, 'lines'))
ggplot(df.type2, aes(x = conf, y = pCorrect, colour = pid)) +
geom_point() +
geom_line(alpha = .5, aes(group = pid)) +
facet_wrap(~decision, labeller = label_both) +
coord_fixed() +
style.long +
theme(panel.spacing.x = unit(2, 'lines'))
level(df.type2$conf[1:4])
tmp <- seq(0, 1, length.out = length(unique(df.type2$conf)))
tmp
sapply(1:length(tmp), function(i) mean(c(tmp[i], tmp[i+1])))
sapply(1:(length(tmp)-1), function(i) mean(c(tmp[i], tmp[i+1])))
df.type2$confProp <- sapply(df.type2$conf, function(x) tmp[which(levels(df.type2$conf) == x)])
df.type2$confProp
df.type2 <- NULL
for(p in unique(trials$pid)) {
for(d in c('initial', 'final')) {
tmp <- trials[trials$pid == p, c(paste0(d, 'Correct'), paste0(d, 'Confidence'))]
# remove NA values which appear in final judgements which are never made
tmp <- tmp[!is.na(tmp[ ,1]), ]
roc <- type2ROC(tmp[ ,1], tmp[ ,2], bins = 7)
df.type2 <- rbind(df.type2, data.frame(pid = factor(p), decision = d, conf = roc$x, pCorrect = roc$y))
}
}
tmp <- seq(0, 1, length.out = length(unique(df.type2$conf)))
tmp <- sapply(1:(length(tmp)-1), function(i) mean(c(tmp[i], tmp[i+1])))
df.type2$confProp <- sapply(df.type2$conf, function(x) tmp[which(levels(df.type2$conf) == x)])
tmp <- aggregate(pCorrect ~ conf + decision, df.type2, mean)
# print neatly with rounding
tmp[ ,3] <- prop2str(tmp[ ,3])
kable(prop2str(tmp))
ggplot(df.type2, aes(x = confProp, y = pCorrect, colour = pid)) +
geom_point() +
geom_line(alpha = .5, aes(group = pid)) +
facet_wrap(~decision, labeller = label_both) +
coord_fixed() +
style.long +
theme(panel.spacing.x = unit(2, 'lines'))
ggplot(df.type2, aes(x = confProp, y = pCorrect, colour = pid)) +
geom_abline(slope = 1, intercept = c(0,0), linestyle = 'dashed', colour = 'black') +
geom_point() +
geom_line(alpha = .5, aes(group = pid)) +
facet_wrap(~decision, labeller = label_both) +
coord_fixed() +
style.long +
theme(panel.spacing.x = unit(2, 'lines'))
ggplot(df.type2, aes(x = confProp, y = pCorrect, colour = pid)) +
geom_abline(slope = 1, intercept = c(0,0), linetype = 'dashed', colour = 'black') +
geom_point() +
geom_line(alpha = .5, aes(group = pid)) +
facet_wrap(~decision, labeller = label_both) +
coord_fixed() +
style.long +
theme(panel.spacing.x = unit(2, 'lines'))
df.type2
ggplot(df.type2, aes(x = confProp, y = pCorrect, colour = pid)) +
geom_abline(slope = 1, intercept = c(0,0), linetype = 'dashed', colour = 'black') +
geom_point() +
geom_line(alpha = .5, aes(group = pid)) +
facet_wrap(~decision, labeller = label_both) +
scale_x_continuous(limits = c(0,1)) +
coord_fixed() +
style.long +
theme(panel.spacing.x = unit(2, 'lines'))
ggplot(df.type2, aes(x = confProp, y = pCorrect, colour = pid)) +
geom_abline(slope = 1, intercept = c(0,0), linetype = 'dashed', colour = 'black') +
geom_point() +
geom_line(alpha = .5, aes(group = pid)) +
facet_wrap(~decision, labeller = label_both) +
scale_x_continuous(limits = c(0,1)) +
coord_fixed() +
style.long +
theme(panel.spacing.x = unit(1.5, 'lines'))
ggplot(df.type2, aes(x = confProp, y = pCorrect, colour = pid)) +
geom_abline(slope = 1, intercept = c(0,0), linetype = 'dashed', colour = 'black') +
geom_point() +
geom_line(alpha = .5, aes(group = pid)) +
facet_wrap(~decision, labeller = label_both) +
scale_x_continuous(limits = c(0,1)) +
coord_fixed() +
style.long +
theme(panel.spacing.x = unit(1.2, 'lines'))
ggplot(df.type2, aes(x = confProp, y = pCorrect, colour = pid)) +
geom_abline(slope = 1, intercept = c(0,0), linetype = 'dashed', colour = 'black') +
geom_point() +
geom_line(alpha = .5, aes(group = pid)) +
facet_wrap(~decision, labeller = label_both) +
scale_x_continuous(limits = c(0,1)) +
coord_fixed() +
style.long +
theme(panel.spacing.x = unit(1, 'lines'))
