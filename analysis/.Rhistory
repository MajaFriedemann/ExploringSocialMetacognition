tmp <- NULL
for (i in 1:nrow(decisions))
if (exclusions$excluded[exclusions$pid == decisions$pid[i]] == F)
tmp <- rbind(tmp, decisions[i, ])
decisions <- tmp
# Remove outlying trials
checkList <- c("timeEnd")
decisions$outlier <- F
for (v in checkList) {
tmp <- scale(decisions[[v]])
decisions$outlier[abs(tmp) > zThresh] <-
ifelse(decisions$outlier[abs(tmp) > zThresh] == F,
v, paste(decisions$outlier, v, collapse = ", "))
if (any(abs(tmp) > zThresh))
print(ggplot(decisions, aes(x = "", y = !!ensym(v))) +
geom_violin(alpha = .25, color = NA, fill = "grey75") +
geom_boxplot(outlier.shape = NA, fill = NA) +
geom_point(position = position_jitter(.33), alpha = .5) +
labs(x = "trials"))
}
tmp <- ggplot(decisions, aes(!!ensym(v))) + geom_histogram()
table(decisions$outlier)
nMaxOutliers <- 2
for (p in unique(exclusions$pid)) {
excluded <- NULL
if (length(decisions$pid[decisions$pid == p & decisions$outlier != F]) > nMaxOutliers)
excluded <- c(excluded, "outlyingTrials")
exclusions$excluded[exclusions$pid == p] <- ifelse(is.null(excluded),
F,
paste(excluded, collapse = ", "))
}
table(exclusions$excluded)
# Drop excluded participants' trials
tmp <- NULL
for (i in 1:nrow(decisions))
if (exclusions$excluded[exclusions$pid == decisions$pid[i]] == F)
tmp <- rbind(tmp, decisions[i, ])
decisions <- tmp
# Participants data frame
ns <- c("timeEnd", "responseCorrect", "responseError", "number")
ss <- c("pid", "responseMarker", "hasFeedback", "decision")
eq <- paste0("cbind(", paste(ns, collapse = ", "), ") ~ ",
paste(ss, collapse = " + "))
PP <- as.tibble(aggregate(as.formula(eq), decisions, mean))
PP$excluded <- sapply(PP$pid, function(p)
exclusions$excluded[exclusions$pid == p])
# record the n of each row so weighted averaging can be used later
PP$number <- aggregate(as.formula(paste("number ~",
paste(ss, collapse = " +"))),
decisions, length)$number
checkList <- c("timeEnd", "responseError", "responseCorrect")
for (v in checkList) {
p <- aggregate(as.formula(paste(v, "~ pid + hasFeedback")),
AdvisedTrial,
mean)
p[, v] <- scale(p[, v])
for (i in 1:nrow(p)) {
if (abs(p[i, v] <= zThresh))
next()
PP$excluded[PP$pid == p$pid[i]] <-
if (PP$excluded[PP$pid == p$pid[i]] == F) v else
paste(PP$excluded[PP$pid == p$pid[i]], ", ", v)
}
if (any(abs(p[, v]) > zThresh))
print(ggplot(p, aes(x = "", y = !!ensym(v), colour = hasFeedback)) +
geom_violin(alpha = .25, color = NA, fill = "grey75") +
geom_boxplot(outlier.shape = NA, fill = NA, aes(group = 1)) +
geom_point(position = position_jitter(.33), alpha = .5) +
labs(x = "participants"))
}
for (p in exclusions$pid)
if (p %in% PP$pid && unique(PP$excluded[PP$pid == p]) != F)
exclusions$excluded[exclusions$pid == p] <- paste(
exclusions$excluded[exclusions$pid == p],
unique(PP$excluded[PP$pid == p]), collapse = ", ")
table(exclusions$excluded)
PP$proportion <- sapply(1:nrow(PP),
function(i)
2 * PP$number[i] /
sum(PP$number[PP$pid == PP$pid[i]]))
# Pad out the proportions
for (p in unique(PP$pid)) {
for (d in unique(PP$decision))
for (m in markerList)
if (nrow(PP[PP$pid == p &
PP$decision == d &
PP$responseMarker == m, ]) == 0)
PP <- safeBind(list(PP,
tibble(pid = p,
responseMarker = m,
hasFeedback = PP$hasFeedback[PP$pid == p][1],
decision = d,
number = 0,
excluded = PP$excluded[PP$pid == p][1],
proportion = 0)))
}
#' Means of v for each marker after converting df entries to participant means
#' @params v column
#' @params df dataframe containing v
markerBreakdown <- function(v, df, hideMarkerTotal = F, ...) {
v <- substitute(v)
fun <- function(x) {
eq <- as.formula(paste(ensym(v), "~ + pid"))
tmp <- aggregate(eq, x, mean, ...)
mean(tmp[, ncol(tmp)])
}
# rename total fields
n <- function(x, alt = NA) if (length(x) == 1) x else alt
out <- list()
for (d in uniqueTotal(df$decision)) {
if (length(d) != 1)
next()
for (f in uniqueTotal(df$hasFeedback)) {
tmp <- tibble(decision = n(d), feedback = n(f))
for (m in uniqueTotal(markerList)) {
if (length(m) != 1 && hideMarkerTotal)
next()
x <- fun(df[df$decision %in% d &
df$hasFeedback %in% f &
df$responseMarker %in% m, ])
if (is.na(n(m)))
tmp$mean <- x
else
tmp[paste0("mean|m=", m)] <- x
}
out[[d]] <- rbind(out[[d]], tmp)
}
}
out
}
tmp <- markerBreakdown(proportion, PP, hideMarkerTotal = T)
# Proportions within a row should sum to 1
for (x in tmp)
expect_equal(apply(x[, 3:5], 1, sum), rep(1, nrow(x)))
num2str.tibble(tmp$first, isProportion = T, precision = 3)
num2str.tibble(tmp$last, isProportion = T, precision = 3)
ggplot(PP[!is.na(PP$responseMarker), ],
aes(x = responseMarker, y = proportion)) +
geom_violin(alpha = .25, colour = NA, fill = "grey75") +
geom_boxplot(fill = NA, outlier.color = NA) +
geom_line(alpha = .5, aes(colour = pid, group = pid)) +
geom_point(alpha = .5, aes(colour = pid)) +
stat_summary(geom = "line", fun.y = mean,
aes(group = 1, linetype = "mean"), size = 1.5) +
facet_grid(hasFeedback ~ decision, labeller = label_both) +
scale_linetype_manual(values = c("dashed")) +
labs(x = "response marker width (years)",
y = "p(marker used)")
tmp <- markerBreakdown(responseCorrect, decisions)
num2str.tibble(tmp$first, isProportion = T, precision = 3)
num2str.tibble(tmp$last, isProportion = T, precision = 3)
ggplot(aggregate(responseCorrect ~
responseMarker + decision + hasFeedback + pid,
decisions, mean),
aes(x = responseMarker, y = responseCorrect)) +
geom_violin(alpha = .25, colour = NA, fill = "grey75") +
geom_boxplot(fill = NA, outlier.color = NA) +
geom_line(alpha = .5, aes(colour = pid, group = pid)) +
geom_point(alpha = .5, aes(colour = pid)) +
stat_summary(geom = "line", fun.y = mean,
aes(group = 1, linetype = "mean"), size = 1.5) +
facet_grid(hasFeedback ~ decision, labeller = label_both) +
scale_linetype_manual(values = c("dashed")) +
labs(x = "response marker width (years)",
y = "p(response correct)")
tmp <- markerBreakdown(responseError, decisions)
num2str.tibble(tmp$first)
num2str.tibble(tmp$last)
ggplot(aggregate(responseError ~
responseMarker + decision + hasFeedback + pid,
decisions, mean),
aes(x = responseMarker, y = responseError)) +
geom_violin(alpha = .25, colour = NA, fill = "grey75") +
geom_boxplot(fill = NA, outlier.color = NA) +
geom_line(alpha = .5, aes(colour = pid, group = pid)) +
geom_point(alpha = .5, aes(colour = pid)) +
stat_summary(geom = "line", fun.y = mean,
aes(group = 1, linetype = "mean"), size = 1.5) +
facet_grid(hasFeedback ~ decision, labeller = label_both) +
scale_linetype_manual(values = c("dashed")) +
labs(x = "response marker width (years)",
y = "|target - response marker centre| (years)")
tmp <- markerBreakdown(responseScore, decisions)
num2str.tibble(tmp$first)
num2str.tibble(tmp$last)
ggplot(aggregate(responseScore ~
responseMarker + decision + hasFeedback + pid,
decisions, mean),
aes(x = responseMarker, y = responseScore)) +
geom_violin(alpha = .25, colour = NA, fill = "grey75") +
geom_boxplot(fill = NA, outlier.color = NA) +
geom_line(alpha = .5, aes(colour = pid, group = pid)) +
geom_point(alpha = .5, aes(colour = pid)) +
stat_summary(geom = "line", fun.y = mean,
aes(group = 1, linetype = "mean"), size = 1.5) +
facet_grid(hasFeedback ~ decision, labeller = label_both) +
scale_linetype_manual(values = c("dashed")) +
labs(x = "response marker width (years)",
y = "points scored")
tmp <- markerBreakdown(timeEnd, decisions)
num2str.tibble(tmp$last)
ggplot(aggregate(timeEnd ~
responseMarker + decision + hasFeedback + pid,
decisions, mean),
aes(x = responseMarker,
y = timeEnd / 1000)) +
geom_violin(alpha = .25, colour = NA, fill = "grey75") +
geom_boxplot(fill = NA, outlier.color = NA) +
geom_line(alpha = .5, aes(colour = pid, group = pid)) +
geom_point(alpha = .5, aes(colour = pid)) +
stat_summary(geom = "line", fun.y = mean,
aes(group = 1, linetype = "mean"), size = 1.5) +
facet_grid(hasFeedback ~ decision, labeller = label_both) +
scale_linetype_manual(values = c("dashed")) +
labs(x = "response marker width (years)",
y = "response time (s)")
decisions$rt <- decisions$responseTimeEstimate - decisions$timeResponseOpen
tmp <- markerBreakdown(rt, decisions)
num2str.tibble(tmp$first)
num2str.tibble(tmp$last)
ggplot(aggregate(rt ~
responseMarker + decision + hasFeedback + pid,
decisions, mean),
aes(x = responseMarker,
y = rt / 1000)) +
geom_violin(alpha = .25, colour = NA, fill = "grey75") +
geom_boxplot(fill = NA, outlier.color = NA) +
geom_line(alpha = .5, aes(colour = pid, group = pid)) +
geom_point(alpha = .5, aes(colour = pid)) +
stat_summary(geom = "line", fun.y = mean,
aes(group = 1, linetype = "mean"), size = 1.5) +
facet_grid(hasFeedback ~ decision, labeller = label_both) +
scale_linetype_manual(values = c("dashed")) +
labs(x = "response marker width (years)",
y = "response time (s)")
# Gather a list of advisor names and advice types
advisorNames <- NULL
adviceTypes <- NULL
for (i in 1:length(grep("advisor[0-9+]idDescription", names(AdvisedTrial)))) {
x <- lapply(AdvisedTrial[paste0("advisor", i, "idDescription")], as.character)
advisorNames <- unique(c(advisorNames, unique(unlist(x))))
y <- lapply(AdvisedTrial[paste0("advisor", i, "actualType")], as.character)
adviceTypes <- unique(c(adviceTypes, unique(unlist(y))))
y <- lapply(AdvisedTrial[paste0("advisor", i, "nominalType")], as.character)
adviceTypes <- unique(c(adviceTypes, unique(unlist(y))))
}
# Gather a list of advice type names
for (i in 1:length(grep("advisor[0-9+]actualType", names(AdvisedTrial)))) {
}
# Produce equivalents of the advisor1|2... variables which are named for the
# advisor giving the advice
# This will probably not work where only one advisor offers advice
for (v in names(decisions)[grepl("advisor1", names(decisions))]) {
suffix <- reFirstMatch("advisor1(\\S+)", v)
for (a in unique(c(as.character(decisions$advisor1idDescription),
as.character(decisions$advisor2idDescription)))) {
s <- paste0(a, ".", suffix)
decisions[, s] <- decisions[, paste0("advisor1", suffix)]
for (i in 1:length(grep("^advisor[0-9]+id$", names(decisions)))) {
decisions[decisions[paste0("advisor", i, "idDescription")] == a, s] <-
decisions[decisions[paste0("advisor", i, "idDescription")] == a,
paste0("advisor", i, suffix)]
}
}
}
# bind feedback property from participants
advisors <- advisors[advisors$pid %in% PP$pid, ]
advisors <- left_join(advisors, unique(PP[c("pid", "hasFeedback")]), "pid")
# drop practice advisors
advisors <- advisors[advisors$idDescription != "Practice", ]
# bind advice types back into AdvisedTrial because we don't want decisions split
# by first/last
AdvisedTrial <-
left_join(AdvisedTrial,
decisions[, grepl(paste0("(pid|number|",
paste0(advisorNames, collapse = "|"),
")"), names(decisions))],
by = c("pid", "number"))
advisors$meanPosition <- NA
for (i in 1:nrow(advisors))
advisors$meanPosition[i] <- mean(decisions[[paste0(advisors$idDescription[i],
".position")]]
[decisions$pid == advisors$pid[i]])
tibble(hasFeedback = c(T, F), meanPosition = c(mean(advisors$meanPosition
[advisors$hasFeedback]),
mean(advisors$meanPosition
[!advisors$hasFeedback])))
out <- list()
for (f in unique(AdvisedTrial$hasFeedback)) {
m <- AdvisedTrial$hasFeedback == f
tmp <- NULL
for (a in advisorNames) {
r <- tibble(feedback = f, advisor = a)
for (x in adviceTypes) {
eq <- as.formula(paste0(a, ".nominalType ~ pid"))
r[, x] <- mean(aggregate(eq,
AdvisedTrial[m, ],
function(q) mean(q == x))[, 2])
}
tmp <- rbind(tmp, r)
}
out[[as.character(f)]] <- tmp
}
prop2str(out$`TRUE`, precision = 3)
prop2str(out$`FALSE`, precision = 3)
out <- list()
for (f in unique(AdvisedTrial$hasFeedback)) {
m <- AdvisedTrial$hasFeedback == f
tmp <- NULL
for (a in advisorNames) {
r <- tibble(feedback = f, advisor = a)
for (x in adviceTypes) {
eq <- as.formula(paste0(a, ".actualType ~ pid"))
r[, x] <- mean(aggregate(eq,
AdvisedTrial[m, ],
function(q) mean(q == x))[, 2])
}
tmp <- rbind(tmp, r)
}
out[[as.character(f)]] <- tmp
}
prop2str(out$`TRUE`, precision = 3)
prop2str(out$`FALSE`, precision = 3)
tmp <- NULL
for (a in advisorNames) {
AdvisedTrial[, paste0(a, ".accurate")] <-
(AdvisedTrial[, paste0(a, ".advice")] -
(AdvisedTrial[, paste0(a, ".adviceWidth")] / 2)) <=
AdvisedTrial[, "correctAnswer"] &
(AdvisedTrial[, paste0(a, ".advice")] +
(AdvisedTrial[, paste0(a, ".adviceWidth")] / 2)) >=
AdvisedTrial[, "correctAnswer"]
AdvisedTrial[, paste0(a, ".error")] <-
abs(AdvisedTrial[, paste0(a, ".advice")] - AdvisedTrial[, "correctAnswer"])
eq <- as.formula(paste0("cbind(", a, ".accurate, ",
a, ".error) ~ pid + hasFeedback"))
r <- aggregate(eq, AdvisedTrial, mean)
colnames(r) <- c("pid", "feedback", "accuracy", "error")
r$advisor = a
tmp <- rbind(tmp, as.tibble(r))
}
prop2str(as.tibble(aggregate(cbind(accuracy, error) ~ advisor + feedback,
tmp,
mean)),
precision = 3)
tmp <- gather(tmp, "var", "value", accuracy:error)
ggplot(tmp, aes(x = advisor, y = value, colour = pid)) +
geom_violin(colour = NA, fill = "grey75", alpha = .25) +
geom_boxplot(outlier.colour = NA, fill = NA, aes(group = advisor)) +
geom_line(alpha = .5, aes(colour = pid, group = pid)) +
geom_point(alpha = .5, aes(colour = pid)) +
stat_summary(geom = "line", fun.y = mean,
aes(group = 1, linetype = "mean"), size = 1.5) +
facet_grid(var ~ feedback, scales = "free_y", labeller = label_both)
tmp <- NULL
for (a in advisorNames) {
for (d in c("", "Final")) {
minA <- AdvisedTrial[, paste0(a, ".advice")] -
(AdvisedTrial[, paste0(a, ".adviceWidth")] / 2)
maxA <- AdvisedTrial[, paste0(a, ".advice")] +
(AdvisedTrial[, paste0(a, ".adviceWidth")] / 2)
minP <- AdvisedTrial[, paste0("responseEstimateLeft", d)]
maxP <- minP + AdvisedTrial[, paste0("responseMarkerWidth", d)]
AdvisedTrial[, paste0(a, ".agree", d)] <-
((minA >= minP) & (minA <= maxP)) | ((maxA >= minP) & (maxA <= minP))
}
eq <- as.formula(paste0(a, ".agree ~ pid + hasFeedback"))
r <- aggregate(eq, AdvisedTrial, mean)
colnames(r) <- c("pid", "feedback", "agreement")
r$advisor <- a
tmp <- rbind(tmp, r)
}
prop2str(as.tibble(aggregate(agreement ~ advisor + feedback, tmp, mean)),
precision = 3)
ggplot(tmp, aes(x = advisor, y = agreement, colour = pid)) +
geom_violin(colour = NA, fill = "grey75", alpha = .25) +
geom_boxplot(outlier.colour = NA, fill = NA, aes(group = advisor)) +
geom_line(alpha = .5, aes(colour = pid, group = pid)) +
geom_point(alpha = .5, aes(colour = pid)) +
stat_summary(geom = "line", fun.y = mean,
aes(group = 1, linetype = "mean"), size = 1.5) +
facet_wrap(~feedback, labeller = label_both)
tmp <- NULL
for (a in advisorNames) {
i <- AdvisedTrial[, "responseEstimateLeft"] +
(AdvisedTrial[, "responseMarkerWidth"] - 1) / 2
f <- AdvisedTrial[, "responseEstimateLeftFinal"] +
(AdvisedTrial[, "responseMarkerWidthFinal"] - 1) / 2
adv <- AdvisedTrial[, paste0(a, ".advice")]
x <- ((f - i) / (adv - i))
x[x < 0] <- 0
x[x > 1] <- 1
AdvisedTrial[, paste0(a, ".woa")] <- x
eq <- as.formula(paste0(a, ".woa ~ pid + hasFeedback"))
r <- aggregate(eq, AdvisedTrial, mean)
colnames(r) <- c("pid", "feedback", "WoA")
r$advisor <- a
tmp <- rbind(tmp, r)
}
prop2str(as.tibble(aggregate(WoA ~ advisor + feedback, tmp, mean)),
precision = 3)
ggplot(tmp, aes(x = advisor, y = WoA, colour = pid)) +
geom_violin(colour = NA, fill = "grey75", alpha = .25) +
geom_boxplot(outlier.colour = NA, fill = NA, aes(group = advisor)) +
geom_line(alpha = .5, aes(colour = pid, group = pid)) +
geom_point(alpha = .5, aes(colour = pid)) +
stat_summary(geom = "line", fun.y = mean,
aes(group = 1, linetype = "mean"), size = 1.5) +
facet_wrap(~feedback, labeller = label_both)
AdvisedTrial$accuracyChange <- AdvisedTrial$responseCorrectFinal -
AdvisedTrial$responseCorrect
tmp <- aggregate(accuracyChange ~ pid + hasFeedback, AdvisedTrial, mean)
num2str(as.tibble(aggregate(accuracyChange ~ hasFeedback, tmp, mean)))
ggplot(tmp, aes(x = hasFeedback, y = accuracyChange, colour = pid)) +
geom_violin(alpha = .25, colour = NA, fill = "grey75") +
geom_boxplot(fill = NA, outlier.color = NA, aes(group = hasFeedback)) +
stat_summary(geom = "line", fun.y = mean,
aes(group = 1, linetype = "mean"), size = 1.5) +
geom_point(alpha = .5, aes(colour = pid))
AdvisedTrial$scoreChange <- AdvisedTrial$responseScoreFinal -
AdvisedTrial$responseScore
tmp <- aggregate(scoreChange ~ pid + hasFeedback, AdvisedTrial, mean)
num2str(as.tibble(aggregate(scoreChange ~ hasFeedback, tmp, mean)))
ggplot(tmp, aes(x = hasFeedback, y = scoreChange, colour = pid)) +
geom_violin(alpha = .25, colour = NA, fill = "grey75") +
geom_boxplot(fill = NA, outlier.color = NA, aes(group = hasFeedback)) +
stat_summary(geom = "line", fun.y = mean,
aes(group = 1, linetype = "mean"), size = 1.5) +
geom_point(alpha = .5, aes(colour = pid))
AdvisedTrial$estimateLeftChange <- abs(AdvisedTrial$responseEstimateLeftFinal -
AdvisedTrial$responseEstimateLeft)
tmp <- aggregate(estimateLeftChange ~ pid + hasFeedback, AdvisedTrial, mean)
num2str(as.tibble(aggregate(estimateLeftChange ~ hasFeedback, tmp, mean)))
ggplot(tmp, aes(x = hasFeedback, y = estimateLeftChange, colour = pid)) +
geom_violin(alpha = .25, colour = NA, fill = "grey75") +
geom_boxplot(fill = NA, outlier.color = NA, aes(group = hasFeedback)) +
stat_summary(geom = "line", fun.y = mean,
aes(group = 1, linetype = "mean"), size = 1.5) +
geom_point(alpha = .5, aes(colour = pid))
AdvisedTrial$confidenceChange <-
(4 - as.numeric(AdvisedTrial$responseMarkerFinal)) -
(4 - as.numeric(AdvisedTrial$responseMarker))
tmp <- aggregate(confidenceChange ~ pid + hasFeedback, AdvisedTrial, mean)
num2str(as.tibble(aggregate(confidenceChange ~ hasFeedback, tmp, mean)))
ggplot(tmp, aes(x = hasFeedback, y = confidenceChange, colour = pid)) +
geom_violin(alpha = .25, colour = NA, fill = "grey75") +
geom_boxplot(fill = NA, outlier.color = NA, aes(group = hasFeedback)) +
stat_summary(geom = "line", fun.y = mean,
aes(group = 1, linetype = "mean"), size = 1.5) +
geom_point(alpha = .5, aes(colour = pid))
eq <- NULL
for (a in advisorNames) {
AdvisedTrial[, paste0(a, ".agreementChange")] <-
AdvisedTrial[, paste0(a, ".agreeFinal")] -
AdvisedTrial[, paste0(a, ".agree")]
eq <- c(eq, paste0(a, ".agreementChange"))
}
eq <- paste0("cbind(", paste(eq, collapse = ", "), ") ~ pid + hasFeedback")
tmp <- aggregate(as.formula(eq), AdvisedTrial, mean)
tmp <- gather(tmp, "advisor", "agreementChange",
grep("\\.agreementChange", names(tmp)))
tmp$advisor <- sapply(tmp$advisor, function(s) reFirstMatch("([^\\.]+)", s))
num2str(as.tibble(aggregate(agreementChange ~ hasFeedback, tmp, mean)))
ggplot(tmp, aes(x = advisor, y = agreementChange, colour = pid)) +
geom_violin(alpha = .25, colour = NA, fill = "grey75") +
geom_boxplot(fill = NA, outlier.color = NA, aes(group = advisor)) +
geom_line(alpha = .5, aes(colour = pid, group = pid)) +
geom_point(alpha = .5, aes(colour = pid)) +
stat_summary(geom = "line", fun.y = mean,
aes(group = 1, linetype = "mean"), size = 1.5) +
facet_wrap(~hasFeedback, labeller = label_both)
tmp <- aggregate(cbind(responseError, responseErrorFinal) ~ pid,
AdvisedTrial,
mean)
r <- md.ttest(tmp$responseErrorFinal, tmp$responseError, c("*M*|last", "*M*|first"))
cat(r)
tmp <- aggregate(cbind(responseScore, responseScoreFinal) ~ pid,
AdvisedTrial,
mean)
r <- md.ttest(tmp$responseScoreFinal, tmp$responseScore, c("*M*|last", "*M*|first"))
cat(r)
tmp <- aggregate(cbind(responseError, responseErrorFinal) ~ pid,
AdvisedTrial[AdvisedTrial$hasFeedback, ],
mean)
r <- md.ttest(tmp$responseErrorFinal, tmp$responseError, c("*M*|last", "*M*|first"))
cat(r)
tmp <- aggregate(cbind(responseScore, responseScoreFinal) ~ pid,
AdvisedTrial[AdvisedTrial$hasFeedback, ],
mean)
r <- md.ttest(tmp$responseScoreFinal, tmp$responseScore, c("*M*|last", "*M*|first"))
cat(r)
tmp <- aggregate(cbind(responseError, responseErrorFinal) ~ pid,
AdvisedTrial[!AdvisedTrial$hasFeedback, ],
mean)
r <- md.ttest(tmp$responseErrorFinal, tmp$responseError, c("*M*|last", "*M*|first"))
cat(r)
tmp <- aggregate(cbind(responseScore, responseScoreFinal) ~ pid,
AdvisedTrial[!AdvisedTrial$hasFeedback, ],
mean)
r <- md.ttest(tmp$responseScoreFinal, tmp$responseScore, c("*M*|last", "*M*|first"))
cat(r)
tmp <- aggregate(cbind(Accurate.woa, Agreeing.woa) ~ pid, AdvisedTrial[AdvisedTrial$hasFeedback, ], mean)
md.ttest(tmp$Accurate.woa, tmp$Agreeing.woa)
cat(md.ttest(tmp$Accurate.woa, tmp$Agreeing.woa), labels = c("Acc", "Agr"))
tmp <- aggregate(cbind(Accurate.woa, Agreeing.woa) ~ pid, AdvisedTrial[!AdvisedTrial$hasFeedback, ], mean)
cat(md.ttest(tmp$Accurate.woa, tmp$Agreeing.woa), labels = c("Acc", "Agr"))
source('F:/xampp/htdocs/ExploringSocialMetacognition/analysis/ACv2/paymentAndExclusion.R', echo=TRUE)
x <- c("Linda", "Sarah", "Raj", "Aaron", "Nick", "Matt D", "Matt J", "Michael", "Naomi", "Joshua")
sample(x)
sample(x)
sample(x)
rm("x")
