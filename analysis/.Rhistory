ggplot(tmp, aes(x = A, y = woa)) +
geom_point(alpha = .25, aes(colour = pid)) +
geom_smooth(method = 'lm', alpha = .5) +
facet_grid(hasFeedback ~ idDescription + Q, labeller = label_both)
ggplot(tmp, aes(x = A, y = woa)) +
geom_point(alpha = .25, aes(colour = pid)) +
geom_smooth(method = 'lm', alpha = .5) +
facet_grid(hasFeedback ~ idDescription + Q, labeller = label_both) +
theme(legend.position = 'bottom')
ggplot(tmp, aes(x = A, y = woa)) +
geom_point(alpha = .25, aes(colour = pid)) +
geom_smooth(method = 'lm', alpha = .5) +
facet_grid(hasFeedback ~ idDescription + Q) +
theme(legend.position = 'bottom')
ggplot(tmp, aes(x = A, y = woa, colour = hasFeedback,
linetype = hasFeedback, shape = hasFeedback)) +
geom_point(alpha = .25, aes(colour = pid)) +
geom_smooth(method = 'lm', alpha = .5) +
facet_grid(idDescription ~ Q) +
theme(legend.position = 'bottom')
ggplot(tmp, aes(x = A, y = woa, linetype = hasFeedback, shape = hasFeedback)) +
geom_point(alpha = .25, aes(colour = pid)) +
geom_smooth(method = 'lm', alpha = .5) +
facet_grid(idDescription ~ Q) +
theme(legend.position = 'bottom')
ggplot(tmp, aes(x = A, y = woa, linetype = hasFeedback, shape = hasFeedback,
fill = hasFeedback)) +
geom_point(alpha = .25) +
geom_smooth(method = 'lm', alpha = .5) +
facet_grid(idDescription ~ Q) +
theme(legend.position = 'bottom')
ggplot(tmp, aes(x = A, y = woa, linetype = hasFeedback, shape = hasFeedback,
fill = hasFeedback)) +
geom_point(alpha = .25, size = 3) +
geom_smooth(method = 'lm', alpha = .5) +
facet_grid(idDescription ~ Q) +
theme(legend.position = 'bottom')
ggplot(tmp, aes(x = A, y = woa, linetype = hasFeedback, shape = hasFeedback,
fill = hasFeedback, colour = hasFeedback)) +
geom_point(alpha = .25, size = 3) +
geom_smooth(method = 'lm', alpha = .5) +
facet_grid(idDescription ~ Q) +
theme(legend.position = 'bottom')
ggplot(tmp, aes(x = A, y = woa, linetype = hasFeedback,
fill = hasFeedback, colour = hasFeedback)) +
geom_point(alpha = .25, size = 3) +
geom_smooth(method = 'lm', alpha = .5) +
facet_grid(idDescription ~ Q) +
theme(legend.position = 'bottom')
ggplot(tmp, aes(x = A, y = woa, linetype = hasFeedback,
fill = hasFeedback, colour = hasFeedback)) +
geom_point(alpha = .5, size = 3) +
geom_smooth(method = 'lm', alpha = .5) +
facet_grid(idDescription ~ Q) +
theme(legend.position = 'bottom')
ggplot(tmp, aes(x = A, y = woa, linetype = hasFeedback,
fill = hasFeedback, colour = hasFeedback)) +
geom_smooth(method = 'lm', alpha = .5) +
geom_point(alpha = .5, size = 3) +
facet_grid(idDescription ~ Q) +
theme(legend.position = 'bottom')
ggplot(tmp, aes(x = A, y = woa, linetype = hasFeedback,
fill = hasFeedback, colour = hasFeedback)) +
geom_hline(yintercept = 0, linetype = "dashed", size = 1) +
geom_hline(yintercept = 1, linetype = "dashed", size = 1) +
geom_smooth(method = 'lm', alpha = .5) +
geom_point(alpha = .5, size = 3) +
facet_grid(idDescription ~ Q) +
theme(legend.position = 'bottom')
ggplot(tmp, aes(x = A, y = woa, linetype = hasFeedback,
fill = hasFeedback, colour = hasFeedback)) +
geom_hline(yintercept = 0, linetype = "dashed", size = .5) +
geom_hline(yintercept = 1, linetype = "dashed", size = .5) +
geom_smooth(method = 'lm', alpha = .5) +
geom_point(alpha = .5, size = 3) +
facet_grid(idDescription ~ Q) +
theme(legend.position = 'bottom')
ggplot(tmp, aes(x = A, y = woa, linetype = hasFeedback,
fill = hasFeedback, colour = hasFeedback)) +
geom_hline(yintercept = 0, linetype = "dashed", size = .5) +
geom_hline(yintercept = 1, linetype = "dashed", size = .5) +
geom_vline(yintercept = 100, linetype = "dashed", size = .5) +
geom_vline(yintercept = 0, linetype = "dashed", size = .5) +
geom_smooth(method = 'lm', alpha = .5) +
geom_point(alpha = .5, size = 3) +
facet_grid(idDescription ~ Q) +
theme(legend.position = 'bottom')
ggplot(tmp, aes(x = A, y = woa, linetype = hasFeedback,
fill = hasFeedback, colour = hasFeedback)) +
geom_hline(yintercept = 0, linetype = "dashed", size = .5) +
geom_hline(yintercept = 1, linetype = "dashed", size = .5) +
geom_vline(xintercept = 100, linetype = "dashed", size = .5) +
geom_vline(xintercept = 0, linetype = "dashed", size = .5) +
geom_smooth(method = 'lm', alpha = .5) +
geom_point(alpha = .5, size = 3) +
facet_grid(idDescription ~ Q) +
theme(legend.position = 'bottom')
library(testthat)
library(tidyverse)
library(curl)
library(lsr)
library(BayesFactor)
library(BANOVA)
library(knitr)
library(prettyMD)
opts_chunk$set('echo' = F)
set.seed(20190425)
# Plot setup
theme_set(theme_light() +
theme(panel.grid.major.x = element_blank()))
zThresh <- 3 # threshold for outliers
markerList <- list(thin = 1, medium = 3, wide = 9)
markerPoints <- function(width) 27 / width
#' strip newlines and html tags from string
stripTags <- function(s) {
s <- gsub("[\r\n]", "", s)
while (any(grepl("  ", s, fixed = T)))
s <- gsub("  ", " ", s, fixed = T)
s <- gsub("^ ", "", s, perl = T)
s <- gsub(" $", "", s, perl = T)
while (any(grepl("<([^\\s>]+)[^>]*>([\\s\\S]*?)<\\/\\1>", s, perl = T)))
s <- gsub("<([^\\s>]+)[^>]*>([\\s\\S]*?)<\\/\\1>", "\\2", s, perl = T)
s <- gsub("<[^>]+\\/>", "", s)
s
}
#' Return the first match for a regexpr
reFirstMatch <- function(pattern, str, ...) {
re <- regexpr(pattern, str, ..., perl = T)
name <- substr(str, attr(re, "capture.start"),
attr(re, "capture.start") + attr(re, "capture.length") - 1)
name
}
expect_equal(reFirstMatch("\\w+\\W+(\\w+)", "First, Second, Third"), "Second")
#' rbind with NA padding for missing columns
#' @params x list of data frames to join
#' @params padWith value for missing entries
safeBind <- function(x, padWith = NA) {
out <- NULL
first <- T
for (y in x) {
if (!is.data.frame(y))
y <- as.data.frame(y)
if (first) {
out <- y
first <- F
} else {
y[, names(out)[names(out) %in% names(y) == F]] <- padWith
out[, names(y)[names(y) %in% names(out) == F]] <- padWith
out <- rbind(out, y)
}
}
out
}
expect_equal(dim(safeBind(list(data.frame(x = 1:5, y = runif(5), rnorm(5)),
data.frame(x = 6:10, z = 1:5)))),
c(10, 4))
#' List the unique values of a vector and a "total" item with all unique values
#' Designed for outputting aggregate counts and totals
uniqueTotal <- function(x) {
out <- as.list(unique(x))
out[[length(out) + 1]] <- unique(x)
out
}
expect_equal(uniqueTotal(c("a", "b", "c")),
list("a", "b", "c", c("a", "b", "c")))
#' List the files on the server matching the specified version
listServerFiles <- function(version) {
rDir <- "https://acclab.psy.ox.ac.uk/~mj221/ESM/data/public/"
out <- NULL
con <- curl(rDir)
open(con, "rb")
while (isIncomplete(con)) {
buffer <- readLines(con, n = 1)
if (length(buffer)) {
f <- reFirstMatch(paste0(">(datesStudy_v", version, "_[^<]+)"),
buffer)
if (nchar(f)) {
out <- c(out, paste0(rDir, f))
}
}
}
close(con)
out
}
version <- "0-0-16"
prefix <- paste0("datesStudy_v", version)
# files <- list.files("../../data/public/", full.names = T)
files <- listServerFiles(version)
# Screen for acceptable IDs
if (!length(grep("metadata", files))) {
idsCSV <- paste0("../../data/public/", prefix, "_okayIds.csv")
if (!file.exists(idsCSV)) {
source("privateDataScript.R")
}
okayIds <- read.csv(idsCSV)
} else {
f <- files[grep("metadata", files)]
okayIds <- read.csv(f)
okayIds$okay <- T
files <- files[grep("metadata", files, invert = T)]
}
for (f in files) {
tmp <- as.tibble(read.csv(f))
# screen out non-okay ids
if ("pid" %in% names(tmp))
tmp <- tmp[tmp$pid %in% okayIds$pid[okayIds$okay], ]
if ("stimHTML" %in% names(tmp)) {
tmp$stimHTML <- stripTags(tmp$stimHTML)
}
# type coersion
if ("comment" %in% names(tmp))
tmp$comment <- as.character(tmp$comment)
n <- grep("advisor[0-9]+(name|validTypes|nominalType|actualType)$",
names(tmp), value = T)
for (x in n)
tmp[, x] <- lapply(tmp[, x], as.character)
n <- grep("responseEstimateLabel", names(tmp), value = T)
for (x in n)
tmp[, x] <- lapply(tmp[, x], function(y)
as.numeric(stripTags((as.character(y)))))
if ("responseMarkerWidth" %in% names(tmp))
tmp$responseMarker <- factor(tmp[["responseMarkerWidth"]])
if ("responseMarkerWidthFinal" %in% names(tmp))
tmp$responseMarkerFinal <- factor(tmp[["responseMarkerWidthFinal"]])
# assign to workspace
name <- reFirstMatch("([^_]+)\\.csv", f)
name <- sub("-", ".", name)
assign(name, tmp)
}
# Reference variables
# Gather a list of advisor names and advice types
names <- NULL
types <- NULL
i <- 0
while (T) {
if (!length(grep(paste0("advisor", i), names(AdvisedTrial)))) {
break()
}
names <- unique(c(names,
unique(AdvisedTrial[, paste0("advisor", i,
"idDescription")])))
types <- unique(c(types,
unique(AdvisedTrial[, paste0("advisor", i,
"actualType")]),
unique(AdvisedTrial[, paste0("advisor", i,
"nominalType")])))
i <- i + 1
}
advisorNames <- unlist(names)
adviceTypes <- unlist(types)
# Produce equivalents of the advisor1|2... variables which are named for the
# advisor giving the advice
for (v in names(AdvisedTrial)[grepl("advisor0", names(AdvisedTrial))]) {
suffix <- reFirstMatch("advisor0(\\S+)", v)
for (a in advisorNames) {
s <- paste0(a, ".", suffix)
AdvisedTrial[, s] <- NA
for (i in 1:nrow(AdvisedTrial)) {
x <- 0
while (T) {
if (!length(grep(paste0("advisor", x),
names(AdvisedTrial)))) {
break()
}
if (AdvisedTrial[i, paste0("advisor", x, "idDescription")] == a) {
AdvisedTrial[i, s] <- AdvisedTrial[i, paste0("advisor", x, suffix)]
break()
}
x <- x + 1
}
}
}
}
# Trials
AdvisedTrial$hasFeedback <- !is.na(AdvisedTrial$timeFeedbackOn)
AdvisedTrial$responseCorrect <-
AdvisedTrial$correctAnswer >= AdvisedTrial$responseEstimateLeft &
AdvisedTrial$correctAnswer <= AdvisedTrial$responseEstimateLeft +
AdvisedTrial$responseMarkerWidth
AdvisedTrial$responseCorrectFinal <-
AdvisedTrial$correctAnswer >= AdvisedTrial$responseEstimateLeftFinal &
AdvisedTrial$correctAnswer <= AdvisedTrial$responseEstimateLeftFinal +
AdvisedTrial$responseMarkerWidthFinal
Trial$responseCorrect <-
Trial$correctAnswer >= Trial$responseEstimateLeft &
Trial$correctAnswer <= Trial$responseEstimateLeft +
Trial$responseMarkerWidth
AdvisedTrial$responseError <- abs(AdvisedTrial$correctAnswer -
AdvisedTrial$responseEstimateLeft +
(AdvisedTrial$responseMarkerWidth / 2))
AdvisedTrial$responseErrorFinal <- abs(AdvisedTrial$correctAnswer -
AdvisedTrial$responseEstimateLeftFinal
+ (AdvisedTrial$responseMarkerWidthFinal
/ 2))
AdvisedTrial$errorReduction <- AdvisedTrial$responseError -
AdvisedTrial$responseErrorFinal
AdvisedTrial$responseScore <-
ifelse(AdvisedTrial$responseCorrect,
27 / AdvisedTrial$responseMarkerWidth, 0)
AdvisedTrial$responseScoreFinal <-
ifelse(AdvisedTrial$responseCorrectFinal,
27 / AdvisedTrial$responseMarkerWidthFinal, 0)
AdvisedTrial$accuracyChange <- AdvisedTrial$responseCorrectFinal -
AdvisedTrial$responseCorrect
AdvisedTrial$scoreChange <- AdvisedTrial$responseScoreFinal -
AdvisedTrial$responseScore
AdvisedTrial$estimateLeftChange <- abs(AdvisedTrial$responseEstimateLeftFinal -
AdvisedTrial$responseEstimateLeft)
AdvisedTrial$confidenceChange <-
(4 - as.numeric(AdvisedTrial$responseMarkerFinal)) -
(4 - as.numeric(AdvisedTrial$responseMarker))
# Trials - advisor-specific variables
for (a in advisorNames) {
# Accuracy
AdvisedTrial[, paste0(a, ".accurate")] <-
(AdvisedTrial[, paste0(a, ".advice")] -
(AdvisedTrial[, paste0(a, ".adviceWidth")] / 2)) <=
AdvisedTrial[, "correctAnswer"] &
(AdvisedTrial[, paste0(a, ".advice")] +
(AdvisedTrial[, paste0(a, ".adviceWidth")] / 2)) >=
AdvisedTrial[, "correctAnswer"]
# Error
AdvisedTrial[, paste0(a, ".error")] <-
abs(AdvisedTrial[, paste0(a, ".advice")] - AdvisedTrial[, "correctAnswer"])
# Weight on Advice
i <- AdvisedTrial[, "responseEstimateLeft"] +
(AdvisedTrial[, "responseMarkerWidth"] - 1) / 2
f <- AdvisedTrial[, "responseEstimateLeftFinal"] +
(AdvisedTrial[, "responseMarkerWidthFinal"] - 1) / 2
adv <- AdvisedTrial[, paste0(a, ".advice")]
x <- ((f - i) / (adv - i))
AdvisedTrial[, paste0(a, ".woaRaw")] <- x
x[x < 0] <- 0
x[x > 1] <- 1
AdvisedTrial[, paste0(a, ".woa")] <- x
# Agreement
for (d in c("", "Final")) {
minA <- AdvisedTrial[, paste0(a, ".advice")] -
(AdvisedTrial[, paste0(a, ".adviceWidth")] / 2)
maxA <- AdvisedTrial[, paste0(a, ".advice")] +
(AdvisedTrial[, paste0(a, ".adviceWidth")] / 2)
minP <- AdvisedTrial[, paste0("responseEstimateLeft", d)]
maxP <- minP + AdvisedTrial[, paste0("responseMarkerWidth", d)]
AdvisedTrial[, paste0(a, ".agree", d)] <-
((minA >= minP) & (minA <= maxP)) | ((maxA >= minP) & (maxA <= minP))
# Distance
reMid <- minP + (maxP - minP) / 2
advice <- AdvisedTrial[, paste0(a, ".advice")]
AdvisedTrial[, paste0(a, ".distance", d)] <- abs(reMid - advice)
}
# Agreement change
AdvisedTrial[, paste0(a, ".agreementChange")] <-
AdvisedTrial[, paste0(a, ".agreeFinal")] -
AdvisedTrial[, paste0(a, ".agree")]
}
# Advisors
advisors$meanPosition <- NA
for (i in 1:nrow(advisors)) {
if (advisors$idDescription[i] == "Practice") {
next()
}
tmp <- AdvisedTrial[AdvisedTrial$pid %in% advisors$pid[i], ]
advisors$meanPosition[i] <-
mean(tmp[[paste0(advisors$idDescription[i], ".position")]], na.rm = T)
}
# Produce a data frame of the trials where each decision gets a unique row
decisions <- AdvisedTrial[, !grepl("^response(?=\\S+Final$)",
names(AdvisedTrial),
perl = T)]
decisions <- rbind(decisions, decisions)
decisions$decision <- sapply(1:nrow(decisions),
function(x)
if (x <= nrow(AdvisedTrial)) "first" else "last")
for (i in (nrow(AdvisedTrial) + 1):nrow(decisions)) {
for (n in names(decisions)[grepl("^response", names(decisions), perl = T)]) {
decisions[i, n] <- AdvisedTrial[i - nrow(AdvisedTrial), paste0(n, "Final")]
}
}
exclusions <- tibble(pid = unique(decisions$pid))
exclusions$excluded <- F
for (p in unique(exclusions$pid)) {
excluded <- NULL
tmp <- Trial[Trial$pid == p, ]
if (any(tmp$responseCorrect == F))
excluded <- c(excluded, "attnCheckYear")
if (any(tmp$responseMarkerWidth != 1))
excluded <- c(excluded, "attnCheckMarker")
exclusions$excluded[exclusions$pid == p] <- ifelse(is.null(excluded),
F,
paste(excluded,
collapse = ", "))
}
table(exclusions$excluded)
# Drop excluded participants' trials
tmp <- NULL
for (i in 1:nrow(decisions))
if (exclusions$excluded[exclusions$pid == decisions$pid[i]] == F)
tmp <- rbind(tmp, decisions[i, ])
decisions <- tmp
for (p in unique(exclusions$pid)) {
if (!(p %in% debrief.advisors$pid)) {
exclusions$excluded[exclusions$pid == p] <-
if (exclusions$excluded[exclusions$pid == p] == F) "safari" else
paste(exclusions$excluded[exclusions$pid == p], ", ", "safari")
}
}
# Remove outlying trials
checkList <- c("timeEnd")
decisions$outlier <- F
for (v in checkList) {
tmp <- scale(decisions[[v]])
decisions$outlier[abs(tmp) > zThresh] <-
ifelse(decisions$outlier[abs(tmp) > zThresh] == F,
v, paste(decisions$outlier, v, collapse = ", "))
if (any(abs(tmp) > zThresh))
print(ggplot(decisions, aes(x = "", y = !!ensym(v))) +
geom_violin(alpha = .25, color = NA, fill = "grey75") +
geom_boxplot(outlier.shape = NA, fill = NA) +
geom_point(position = position_jitter(.33), alpha = .5) +
labs(x = "trials"))
}
tmp <- ggplot(decisions, aes(!!ensym(v))) + geom_histogram()
table(decisions$outlier)
nMaxOutliers <- 2
for (p in unique(exclusions$pid)) {
excluded <- exclusions$excluded[exclusions$pid == p]
if (excluded == F)
excluded <- NULL
if (length(decisions$pid[decisions$pid == p & decisions$outlier != F]) >
nMaxOutliers)
excluded <- c(excluded, "outlyingTrials")
exclusions$excluded[exclusions$pid == p] <-
if (is.null(excluded)) F else excluded
}
table(exclusions$excluded)
# Drop excluded participants' trials
tmp <- NULL
for (i in 1:nrow(decisions))
if (exclusions$excluded[exclusions$pid == decisions$pid[i]] == F)
tmp <- rbind(tmp, decisions[i, ])
decisions <- tmp
# Participants data frame
ns <- c("timeEnd", "responseCorrect", "responseError", "number")
ss <- c("pid", "responseMarker", "hasFeedback", "decision")
eq <- paste0("cbind(", paste(ns, collapse = ", "), ") ~ ",
paste(ss, collapse = " + "))
PP <- as.tibble(aggregate(as.formula(eq), decisions, mean))
PP$excluded <- sapply(PP$pid, function(p)
exclusions$excluded[exclusions$pid == p])
# record the n of each row so weighted averaging can be used later
PP$number <- aggregate(as.formula(paste("number ~",
paste(ss, collapse = " +"))),
decisions, length)$number
checkList <- c("timeEnd", "responseError", "responseCorrect")
for (v in checkList) {
p <- aggregate(as.formula(paste(v, "~ pid + hasFeedback")),
AdvisedTrial,
mean)
p[, v] <- scale(p[, v])
for (i in 1:nrow(p)) {
if (abs(p[i, v] <= zThresh))
next()
exclusions$excluded[exclusions$pid == p$pid[i]] <-
if (exclusions$excluded[exclusions$pid == p$pid[i]] == F) v else
paste(exclusions$excluded[exclusions$pid == p$pid[i]], ", ", v)
}
if (any(abs(p[, v]) > zThresh))
print(ggplot(p, aes(x = "", y = !!ensym(v), colour = hasFeedback)) +
geom_violin(alpha = .25, color = NA, fill = "grey75") +
geom_boxplot(outlier.shape = NA, fill = NA, aes(group = 1)) +
geom_point(position = position_jitter(.33), alpha = .5) +
labs(x = "participants", y = paste0(v, ".z")))
}
PP$excluded <- sapply(PP$pid,
function(x) exclusions$excluded[exclusions$pid == x])
table(exclusions$excluded)
debrief.form$guessedManipulation <-
c(F, F, F, F, F, F, F, F, F, F,
F, F, F, F, F, T, F, F, F, F,
F, F, F, F, F, F, F, F, F, F)
debrief.form[, c("pid", "comment", "guessedManipulation")]
for (p in exclusions$pid) {
if (p %in% debrief.form$pid) {
if (debrief.form$guessedManipulation[debrief.form$pid == p]) {
exclusions$excluded[exclusions$pid == p] <-
if (exclusions$excluded[exclusions$pid == p] == F)
"guessedManipulation" else
paste(c(exclusions$excluded[exclusions$pid == p],
"guessedManipulation"), collapse = ", ")
}
}
}
# Check for erroneous marker values
okayMarkers <- c(1, 3, 9, 27)
for (p in unique(AdvisedTrial$pid)) {
tmp <- AdvisedTrial[AdvisedTrial$pid == p, ]
if (!all(tmp$responseMarkerWidth %in% okayMarkers) |
!all(tmp$responseMarkerWidthFinal %in% okayMarkers)) {
if (p %in% exclusions$pid) {
exclusions$excluded[exclusions$pid == p] <-
if (exclusions$excluded[exclusions$pid == p] == F)
"badMarker" else
paste(c(exclusions$excluded[exclusions$pid == p],
"badMarker"), collapse = ", ")
}
}
}
table(exclusions$excluded)
source('F:/xampp/htdocs/ExploringSocialMetacognition/analysis/ACv2/paymentAndExclusion.R', echo=TRUE)
View(Trial[trial$pid == "0d7f6356",])
Trial[Trial$pid == "0d7f6356",]
Trial[Trial$pid == "6daabdde",]
