participants <- NULL
trials <- NULL
advisors <- NULL
questionnaires <- NULL
genTrustQ <- NULL
for (i in seq(length(files))) {
fileName <- paste(folderName, files[[i]], sep='/')
json <- readChar(fileName, file.info(fileName)$size)
jsonData <- fromJSON(json, simplifyVector = T, simplifyMatrix = T, simplifyDataFrame = T)
# store all columns in participants table except the three last
# (trials, advisors, and questionnaires are stored separately)
participants <- rbind(participants,
as.data.frame(t(jsonData[!names(jsonData) %in% c('advisors',
'questionnaires',
'trials',
'generalisedTrustQuestionnaire')])))
# store the trials in the trials table
trials <- rbind(trials, jsonData$trials)
advisors <- rbind(advisors, jsonData$advisors)
questionnaires <- rbind(questionnaires, jsonData$questionnaires)
if(('generalisedTrustQuestionnaire' %in% names(jsonData)))
genTrustQ <- rbind(genTrustQ, jsonData$generalisedTrustQuestionnaire)
}
#rm(jsonData, files, fileName, folderName, json)
#   1.ii) Calculate utility variables ####
print('Calculate utility variables')
# Fix for the javascript saving function recording the advice side as correctness rather than agreement
trials$adviceRight <- grepl('RIGHT', trials$adviceString, fixed = T)
trials$adviceSideOld <- trials$adviceSide
trials$adviceSide <- ifelse(trials$adviceRight, 1, 0)
trials$advisorAgreesOld <- trials$advisorAgrees
trials$advisorAgrees <- trials$initialAnswer == trials$adviceRight
trials$adviceType <- getAdviceType(trials, participants, advisors) # adviceType > trials table
trials$confidenceShift <- getConfidenceShift(trials) #  amount the confidence changes
trials$confidenceShiftRaw <- getConfidenceShift(trials,T,T) # as above, without symmetry adjustment
trials$influence <- getInfluence(trials) # amount the confidence changes in the direction of the advice
trials$rawInfluence <- getInfluence(trials, T, T) # as above, without symmetry adjustment
trials$switch <- trials$initialAnswer != trials$finalAnswer # whether participant switched response
trials$initialCorrect <- trials$initialAnswer == trials$correctAnswer # whether the initial answer is correct
trials$finalCorrect <- trials$finalAnswer == trials$correctAnswer # whether the final answer is correct
# Sometimes it helps to see confidence arranged from sure left to sure right (-100 to 100)
trials$initialConfSpan <- ifelse(trials$initialAnswer==0,trials$initialConfidence*-1,trials$initialConfidence)
trials$finalConfSpan <- ifelse(trials$finalAnswer==0,trials$finalConfidence*-1,trials$finalConfidence)
# Was the response to the advice irrational?
trials$irrational <- (trials$advisorAgrees & trials$confidenceShift < 0) |
(!trials$advisorAgrees & trials$confidenceShift > 0)
# Convert times to seconds since the 70 epoch
participants$timeStart <- sapply(participants$timeStart, function(x)x[[1]]/1000)
participants$timeEnd <- sapply(participants$timeEnd, function(x)x[[1]]/1000)
# For convenience the long participant Id is shortened to a simple number:
participants$pid <- which(as.character(participants$id) == participants$id)
tmp <- function(x) participants$pid[which(participants$id == x)]
trials$pid <- sapply(trials$participantId, tmp)
questionnaires$pid <- sapply(questionnaires$participantId, tmp)
advisors$pid <- sapply(advisors$participantId, tmp)
genTrustQ$pid <- sapply(genTrustQ$participantId, tmp)
# adviceType > questionnaire table
aT <- vector(length = dim(questionnaires)[1])
timepoint <- aT
for (i in 1:dim(questionnaires)[1]) {
aT[[i]] <- getAdviceTypeById(questionnaires$advisorId[i], questionnaires$participantId[i], advisors)
# get the time point of the questionnaire (1=prospective, 2=retrospective)
timepoint[i] <- 1 +
as.numeric(questionnaires$afterTrial[i] >
mean(questionnaires$afterTrial[questionnaires$pid == questionnaires$pid[i]
& questionnaires$advisorId == questionnaires$advisorId[i]]))
}
questionnaires$adviceType <- aT
questionnaires$timepoint <- timepoint
# Stick the name and portrait data into the questionnaires table
questionnaires$advisorName <- factor(sapply(1:nrow(questionnaires), function(i)
advisors$name[advisors$pid==questionnaires$pid[i]
& advisors$id == questionnaires$advisorId[i]]))
questionnaires$advisorPortrait <- sapply(1:nrow(questionnaires), function(i) {
x <- advisors$portraitSrc[advisors$pid==questionnaires$pid[i]
& advisors$id == questionnaires$advisorId[i]]
x <- sub('assets/image/advisor', '', x, fixed = T)
as.factor(sub('.jpg', '', x, fixed = T))
})
# Add on the source data
questionnaires$advisorAge <- sapply(questionnaires$advisorPortrait, function(i) portraitDetails$age[i])
questionnaires$advisorCategory <- sapply(questionnaires$advisorPortrait, function(i) portraitDetails$category[i])
# The first general trust question is reverse coded
genTrustQ$answer <- as.numeric(genTrustQ$answer)
genTrustQ$answer[genTrustQ$order==0] <- 100 - genTrustQ$answer[genTrustQ$order==0]
#   1.iii) Split off real trials ####
print('Separate real trials from practice')
all.trials <- trials
trials <- trials[which(!trials$practice),]
all.questionnaires <- questionnaires
questionnaires <- questionnaires[which(questionnaires$adviceType!=0),]
all.advisors <- advisors
advisors <- advisors[which(advisors$adviceType!=0),]
# Chunk 1
source('ESM_core.R')
# Chunk 2
#   1.i) Load data ####
print('Load data')
folderName <- "G:\\Documents\\University\\Google Drive\\Project Documents\\AdvisorChoice\\results\\Accuracy\\2018-09-17 120 practice trials\\processed"
files <- list.files(folderName)
participants <- NULL
trials <- NULL
advisors <- NULL
questionnaires <- NULL
genTrustQ <- NULL
for (i in seq(length(files))) {
fileName <- paste(folderName, files[[i]], sep='/')
json <- readChar(fileName, file.info(fileName)$size)
jsonData <- fromJSON(json, simplifyVector = T, simplifyMatrix = T, simplifyDataFrame = T)
# store all columns in participants table except the three last
# (trials, advisors, and questionnaires are stored separately)
participants <- rbind(participants,
as.data.frame(t(jsonData[!names(jsonData) %in% c('advisors',
'questionnaires',
'trials',
'generalisedTrustQuestionnaire')])))
# store the trials in the trials table
trials <- rbind(trials, jsonData$trials)
advisors <- rbind(advisors, jsonData$advisors)
questionnaires <- rbind(questionnaires, jsonData$questionnaires)
if(('generalisedTrustQuestionnaire' %in% names(jsonData)))
genTrustQ <- rbind(genTrustQ, jsonData$generalisedTrustQuestionnaire)
}
#rm(jsonData, files, fileName, folderName, json)
#   1.ii) Calculate utility variables ####
print('Calculate utility variables')
# Fix for the javascript saving function recording the advice side as correctness rather than agreement
trials$adviceRight <- grepl('RIGHT', trials$adviceString, fixed = T)
trials$adviceSideOld <- trials$adviceSide
trials$adviceSide <- ifelse(trials$adviceRight, 1, 0)
trials$advisorAgreesOld <- trials$advisorAgrees
trials$advisorAgrees <- trials$initialAnswer == trials$adviceRight
trials$adviceType <- getAdviceType(trials, participants, advisors) # adviceType > trials table
trials$confidenceShift <- getConfidenceShift(trials) #  amount the confidence changes
trials$confidenceShiftRaw <- getConfidenceShift(trials,T,T) # as above, without symmetry adjustment
trials$influence <- getInfluence(trials) # amount the confidence changes in the direction of the advice
trials$rawInfluence <- getInfluence(trials, T, T) # as above, without symmetry adjustment
trials$switch <- trials$initialAnswer != trials$finalAnswer # whether participant switched response
trials$initialCorrect <- trials$initialAnswer == trials$correctAnswer # whether the initial answer is correct
trials$finalCorrect <- trials$finalAnswer == trials$correctAnswer # whether the final answer is correct
# Sometimes it helps to see confidence arranged from sure left to sure right (-100 to 100)
trials$initialConfSpan <- ifelse(trials$initialAnswer==0,trials$initialConfidence*-1,trials$initialConfidence)
trials$finalConfSpan <- ifelse(trials$finalAnswer==0,trials$finalConfidence*-1,trials$finalConfidence)
# Was the response to the advice irrational?
trials$irrational <- (trials$advisorAgrees & trials$confidenceShift < 0) |
(!trials$advisorAgrees & trials$confidenceShift > 0)
# Convert times to seconds since the 70 epoch
participants$timeStart <- sapply(participants$timeStart, function(x)x[[1]]/1000)
participants$timeEnd <- sapply(participants$timeEnd, function(x)x[[1]]/1000)
# For convenience the long participant Id is shortened to a simple number:
participants$pid <- which(as.character(participants$id) == participants$id)
tmp <- function(x) participants$pid[which(participants$id == x)]
trials$pid <- sapply(trials$participantId, tmp)
questionnaires$pid <- sapply(questionnaires$participantId, tmp)
advisors$pid <- sapply(advisors$participantId, tmp)
genTrustQ$pid <- sapply(genTrustQ$participantId, tmp)
# adviceType > questionnaire table
aT <- vector(length = dim(questionnaires)[1])
timepoint <- aT
for (i in 1:dim(questionnaires)[1]) {
aT[[i]] <- getAdviceTypeById(questionnaires$advisorId[i], questionnaires$participantId[i], advisors)
# get the time point of the questionnaire (1=prospective, 2=retrospective)
timepoint[i] <- 1 +
as.numeric(questionnaires$afterTrial[i] >
mean(questionnaires$afterTrial[questionnaires$pid == questionnaires$pid[i]
& questionnaires$advisorId == questionnaires$advisorId[i]]))
}
questionnaires$adviceType <- aT
questionnaires$timepoint <- timepoint
# Stick the name and portrait data into the questionnaires table
questionnaires$advisorName <- factor(sapply(1:nrow(questionnaires), function(i)
advisors$name[advisors$pid==questionnaires$pid[i]
& advisors$id == questionnaires$advisorId[i]]))
questionnaires$advisorPortrait <- sapply(1:nrow(questionnaires), function(i) {
x <- advisors$portraitSrc[advisors$pid==questionnaires$pid[i]
& advisors$id == questionnaires$advisorId[i]]
x <- sub('assets/image/advisor', '', x, fixed = T)
as.factor(sub('.jpg', '', x, fixed = T))
})
# Add on the source data
questionnaires$advisorAge <- sapply(questionnaires$advisorPortrait, function(i) portraitDetails$age[i])
questionnaires$advisorCategory <- sapply(questionnaires$advisorPortrait, function(i) portraitDetails$category[i])
# The first general trust question is reverse coded
genTrustQ$answer <- as.numeric(genTrustQ$answer)
genTrustQ$answer[genTrustQ$order==0] <- 100 - genTrustQ$answer[genTrustQ$order==0]
#   1.iii) Split off real trials ####
print('Separate real trials from practice')
all.trials <- trials
trials <- trials[which(!trials$practice),]
all.questionnaires <- questionnaires
questionnaires <- questionnaires[which(questionnaires$adviceType!=0),]
all.advisors <- advisors
advisors <- advisors[which(advisors$adviceType!=0),]
# Chunk 3
aov.iii.i <- aov.agreementContingencies(trials)
kable(prettifyEZ(aov.iii.i))
# Chunk 4
gg.iii.ii <- gg.agreementContingencies(trials) +
labs(title = 'Observed agreement rate')
gg.iii.ii
# Chunk 5
# Initial block is forced trials
tmp.aov <- aov.agreementContingencies(trials[trials$type==trialTypes$force, ])
kable(prettifyEZ(tmp.aov))
# Chunk 6
gg.iii.iv <- gg.agreementContingencies(trials[trials$type==trialTypes$force, ]) +
labs(title = 'Observed agreement rate on Forced trials')
gg.iii.iv
# Chunk 7
tmp.aov <- aov.agreementContingenciesByType(trials[trials$initialCorrect==T, ])
kable(prettifyEZ(tmp.aov))
gg.iii.iv.i <- gg.agreementContingenciesByType(trials[trials$initialCorrect==T, ])
gg.iii.iv.i
# Chunk 8
# Let's also check we got appropriate numbers of trials in each of the bins for
# each participant
gg.iii.vi <- gg.contingencyCounts(trials)
gg.iii.vi
# Chunk 9
participants$excluded <- sapply(participants$pid, function(pid){
ts <- which(all.trials$pid == pid)
# overall accuracy of initial decisions
v <- all.trials$initialAnswer[ts] == all.trials$correctAnswer[ts]
m <- mean(as.numeric(v), na.rm = T)
if(m < .6 | m > .85)
return('Accuracy')
# varied use of confidence scale
ts <- which(trials$pid == pid)
cCs <- aggregate(pid ~ confidenceCategory, data = trials[ts, ], FUN = length)
# All confidence categories must be used
if(nrow(cCs) < 3)
return ('Confidence')
# Clarify the numbers on the rules below
# All confidence categories must have at least 5% of the number of trials
if(any(cCs$pid < length(ts)*.05))
return('Confidence.cat')
return(F)
})
# exclude on the basis of collecting too much data
if(sum(participants$excluded == F) > 50) {
tmp <- participants[participants$excluded == F, c('id', 'timeStart')]
tmp <- tmp$id[order(tmp$timeStart)]
tmp <- tmp[1:50]
participants$excluded[!(participants$id %in% tmp)] <- 'Excess.data'
}
# manual exclusions
# participants$excluded[participants$pid %in% c(37)] <- T
all.participants <- participants
participants <- participants[participants$excluded==F, ]
# Remove excluded participants' data from other data frames
trials <- trials[trials$pid %in% participants$pid, ]
advisors <- advisors[advisors$pid %in% participants$pid, ]
questionnaires <- questionnaires[questionnaires$pid %in% participants$pid, ]
all.genTrustQ <- genTrustQ
genTrustQ <- genTrustQ[genTrustQ$pid %in% participants$pid, ]
df.iv <- aggregate(pid ~ excluded, data = all.participants, FUN = length)
names(df.iv) <- c('exclusionReason', 'count')
kable(df.iv)
tmp <- aggregate(finalCorrect ~ adviceType + pid, data = trials, FUN = mean)
tmp
md.ttest(tmp$finalCorrect[tmp$adviceType==5], tmp$finalCorrect[tmp$adviceType==6], c(getAdviceTypeName(5), getAdviceTypeName(6)), paired = T)
# Chunk 1
source('ESM_core.R')
# Chunk 2
#   1.i) Load data ####
print('Load data')
folderName <- "G:\\Documents\\University\\Google Drive\\Project Documents\\AdvisorChoice\\results\\Agreement\\processed"
files <- list.files(folderName)
participants <- NULL
trials <- NULL
advisors <- NULL
questionnaires <- NULL
genTrustQ <- NULL
for (i in seq(length(files))) {
fileName <- paste(folderName, files[[i]], sep='/')
json <- readChar(fileName, file.info(fileName)$size)
jsonData <- fromJSON(json, simplifyVector = T, simplifyMatrix = T, simplifyDataFrame = T)
# store all columns in participants table except the three last
# (trials, advisors, and questionnaires are stored separately)
participants <- rbind(participants,
as.data.frame(t(jsonData[!names(jsonData) %in% c('advisors',
'questionnaires',
'trials',
'generalisedTrustQuestionnaire')])))
# store the trials in the trials table
trials <- rbind(trials, jsonData$trials)
advisors <- rbind(advisors, jsonData$advisors)
questionnaires <- rbind(questionnaires, jsonData$questionnaires)
if(('generalisedTrustQuestionnaire' %in% names(jsonData)))
genTrustQ <- rbind(genTrustQ, jsonData$generalisedTrustQuestionnaire)
}
#rm(jsonData, files, fileName, folderName, json)
#   1.ii) Calculate utility variables ####
print('Calculate utility variables')
# Fix for the javascript saving function recording the advice side as correctness rather than agreement
trials$adviceRight <- grepl('RIGHT', trials$adviceString, fixed = T)
trials$adviceSideOld <- trials$adviceSide
trials$adviceSide <- ifelse(trials$adviceRight, 1, 0)
trials$advisorAgreesOld <- trials$advisorAgrees
trials$advisorAgrees <- trials$initialAnswer == trials$adviceRight
trials$adviceType <- getAdviceType(trials, participants, advisors) # adviceType > trials table
trials$confidenceShift <- getConfidenceShift(trials) #  amount the confidence changes
trials$confidenceShiftRaw <- getConfidenceShift(trials,T,T) # as above, without symmetry adjustment
trials$influence <- getInfluence(trials) # amount the confidence changes in the direction of the advice
trials$rawInfluence <- getInfluence(trials, T, T) # as above, without symmetry adjustment
trials$switch <- trials$initialAnswer != trials$finalAnswer # whether participant switched response
trials$initialCorrect <- trials$initialAnswer == trials$correctAnswer # whether the initial answer is correct
trials$finalCorrect <- trials$finalAnswer == trials$correctAnswer # whether the final answer is correct
# Sometimes it helps to see confidence arranged from sure left to sure right (-100 to 100)
trials$initialConfSpan <- ifelse(trials$initialAnswer==0,trials$initialConfidence*-1,trials$initialConfidence)
trials$finalConfSpan <- ifelse(trials$finalAnswer==0,trials$finalConfidence*-1,trials$finalConfidence)
# Was the response to the advice irrational?
trials$irrational <- (trials$advisorAgrees & trials$confidenceShift < 0) |
(!trials$advisorAgrees & trials$confidenceShift > 0)
# Confidence category as calculated post-hoc rather than at advice time
for(pid in unique(trials$pid)) {
v <- trials$initialConfidence[trials$pid == pid]
tmp <- hdquantile(v, c(.3, .7))
trials$postHocConfCat[trials$pid == pid] <- sapply(v, function(x) {
if(x < tmp[1]) return(0)
if(x < tmp[2]) return(1)
return(2)
})
}
# Convert times to seconds since the 70 epoch
participants$timeStart <- sapply(participants$timeStart, function(x)x[[1]]/1000)
participants$timeEnd <- sapply(participants$timeEnd, function(x)x[[1]]/1000)
# For convenience the long participant Id is shortened to a simple number:
participants$pid <- which(as.character(participants$id) == participants$id)
tmp <- function(x) participants$pid[which(participants$id == x)]
trials$pid <- sapply(trials$participantId, tmp)
questionnaires$pid <- sapply(questionnaires$participantId, tmp)
advisors$pid <- sapply(advisors$participantId, tmp)
genTrustQ$pid <- sapply(genTrustQ$participantId, tmp)
# adviceType > questionnaire table
aT <- vector(length = dim(questionnaires)[1])
timepoint <- aT
for (i in 1:dim(questionnaires)[1]) {
aT[[i]] <- getAdviceTypeById(questionnaires$advisorId[i], questionnaires$participantId[i], advisors)
# get the time point of the questionnaire (1=prospective, 2=retrospective)
timepoint[i] <- 1 +
as.numeric(questionnaires$afterTrial[i] >
mean(questionnaires$afterTrial[questionnaires$pid == questionnaires$pid[i]
& questionnaires$advisorId == questionnaires$advisorId[i]]))
}
questionnaires$adviceType <- aT
questionnaires$timepoint <- timepoint
# Stick the name and portrait data into the questionnaires table
questionnaires$advisorName <- factor(sapply(1:nrow(questionnaires), function(i)
advisors$name[advisors$pid==questionnaires$pid[i]
& advisors$id == questionnaires$advisorId[i]]))
questionnaires$advisorPortrait <- sapply(1:nrow(questionnaires), function(i) {
x <- advisors$portraitSrc[advisors$pid==questionnaires$pid[i]
& advisors$id == questionnaires$advisorId[i]]
x <- sub('assets/image/advisor', '', x, fixed = T)
as.factor(sub('.jpg', '', x, fixed = T))
})
# Add on the source data
questionnaires$advisorAge <- sapply(questionnaires$advisorPortrait, function(i) portraitDetails$age[i])
questionnaires$advisorCategory <- sapply(questionnaires$advisorPortrait, function(i) portraitDetails$category[i])
# The first general trust question is reverse coded
genTrustQ$answer <- as.numeric(genTrustQ$answer)
genTrustQ$answer[genTrustQ$order==0] <- 100 - genTrustQ$answer[genTrustQ$order==0]
#   1.iii) Split off real trials ####
print('Separate real trials from practice')
all.trials <- trials
trials <- trials[which(!trials$practice),]
all.questionnaires <- questionnaires
questionnaires <- questionnaires[which(questionnaires$adviceType!=0),]
all.advisors <- advisors
advisors <- advisors[which(advisors$adviceType!=0),]
# Chunk 3
aov.iii.i <- aov.agreementContingencies(trials)
kable(prettifyEZ(aov.iii.i))
# Chunk 4
gg.iii.ii <- gg.agreementContingencies(trials) +
labs(title = 'Observed agreement rate')
gg.iii.ii
# Chunk 5
# Initial block is forced trials
tmp.aov <- aov.agreementContingencies(trials[trials$type==trialTypes$force, ])
kable(prettifyEZ(tmp.aov))
# Chunk 6
gg.iii.iv <- gg.agreementContingencies(trials[trials$type==trialTypes$force, ]) +
labs(title = 'Observed agreement rate on Forced trials')
gg.iii.iv
# Chunk 7
tmp.aov <- aov.agreementContingenciesByType(trials[trials$initialCorrect==T, ])
kable(prettifyEZ(tmp.aov))
gg.iii.iv.i <- gg.agreementContingenciesByType(trials[trials$initialCorrect==T, ])
gg.iii.iv.i
# Chunk 8
# Let's also check we got appropriate numbers of trials in each of the bins for
# each participant
gg.iii.vi <- gg.contingencyCounts(trials)
gg.iii.vi
# Chunk 9
participants$excluded <- sapply(participants$pid, function(pid){
ts <- which(all.trials$pid == pid)
# overall accuracy of initial decisions
v <- all.trials$initialAnswer[ts] == all.trials$correctAnswer[ts]
m <- mean(as.numeric(v), na.rm = T)
if(m < .6 | m > .85)
return('Accuracy')
# varied use of confidence scale
ts <- which(trials$pid == pid)
cCs <- aggregate(pid ~ confidenceCategory, data = trials[ts, ], FUN = length)
# All confidence categories must be used
if(nrow(cCs) < 3)
return ('Confidence')
# All confidence categories must have at least 5% of the number of trials
if(any(cCs$pid < length(ts)*.05))
return('Confidence.cat')
return(F)
})
# exclude on the basis of collecting too much data
if(sum(participants$excluded == F) > 50) {
tmp <- participants[participants$excluded == F, c('id', 'timeStart')]
tmp <- tmp$id[order(tmp$timeStart)]
tmp <- tmp[1:50]
participants$excluded[!(participants$id %in% tmp)] <- 'Excess.data'
}
all.participants <- participants
participants <- participants[participants$excluded==F, ]
# Remove excluded participants' data from other data frames
trials <- trials[trials$pid %in% participants$pid, ]
advisors <- advisors[advisors$pid %in% participants$pid, ]
questionnaires <- questionnaires[questionnaires$pid %in% participants$pid, ]
all.genTrustQ <- genTrustQ
genTrustQ <- genTrustQ[genTrustQ$pid %in% participants$pid, ]
df.iv <- aggregate(pid ~ excluded, data = all.participants, FUN = length)
names(df.iv) <- c('exclusionReason', 'count')
kable(df.iv)
tmp <- aggregate(finalCorrect ~ adviceType + pid, data = trials, FUN = mean)
tmp
md.ttest(tmp$finalCorrect[tmp$adviceType==7], tmp$finalCorrect[tmp$adviceType==8], c(getAdviceTypeName(7), getAdviceTypeName(8)), paired = T)
files <- file_choose()
files <- file.choose()
participants <- NULL
trials <- NULL
advisors <- NULL
questionnaires <- NULL
genTrustQ <- NULL
for (i in seq(length(files))) {
fileName <- paste(folderName, files[[i]], sep='/')
json <- readChar(fileName, file.info(fileName)$size)
jsonData <- fromJSON(json, simplifyVector = T, simplifyMatrix = T, simplifyDataFrame = T)
# store all columns in participants table except the three last
# (trials, advisors, and questionnaires are stored separately)
participants <- rbind(participants,
as.data.frame(t(jsonData[!names(jsonData) %in% c('advisors',
'questionnaires',
'trials',
'generalisedTrustQuestionnaire')])))
# store the trials in the trials table
trials <- rbind(trials, jsonData$trials)
advisors <- rbind(advisors, jsonData$advisors)
questionnaires <- rbind(questionnaires, jsonData$questionnaires)
if(('generalisedTrustQuestionnaire' %in% names(jsonData)))
genTrustQ <- rbind(genTrustQ, jsonData$generalisedTrustQuestionnaire)
}
folderName <- ''
participants <- NULL
trials <- NULL
advisors <- NULL
questionnaires <- NULL
genTrustQ <- NULL
for (i in seq(length(files))) {
fileName <- paste(folderName, files[[i]], sep='/')
json <- readChar(fileName, file.info(fileName)$size)
jsonData <- fromJSON(json, simplifyVector = T, simplifyMatrix = T, simplifyDataFrame = T)
# store all columns in participants table except the three last
# (trials, advisors, and questionnaires are stored separately)
participants <- rbind(participants,
as.data.frame(t(jsonData[!names(jsonData) %in% c('advisors',
'questionnaires',
'trials',
'generalisedTrustQuestionnaire')])))
# store the trials in the trials table
trials <- rbind(trials, jsonData$trials)
advisors <- rbind(advisors, jsonData$advisors)
questionnaires <- rbind(questionnaires, jsonData$questionnaires)
if(('generalisedTrustQuestionnaire' %in% names(jsonData)))
genTrustQ <- rbind(genTrustQ, jsonData$generalisedTrustQuestionnaire)
}
files
fileName <- files
json <- readChar(fileName, file.info(fileName)$size)
jsonData <- fromJSON(json, simplifyVector = T, simplifyMatrix = T, simplifyDataFrame = T)
library(jsonlite)
jsonData <- fromJSON(json, simplifyVector = T, simplifyMatrix = T, simplifyDataFrame = T)
# store all columns in participants table except the three last
# (trials, advisors, and questionnaires are stored separately)
participants <- rbind(participants,
as.data.frame(t(jsonData[!names(jsonData) %in% c('advisors',
'questionnaires',
'trials',
'generalisedTrustQuestionnaire')])))
# store the trials in the trials table
trials <- rbind(trials, jsonData$trials)
advisors <- rbind(advisors, jsonData$advisors)
questionnaires <- rbind(questionnaires, jsonData$questionnaires)
if(('generalisedTrustQuestionnaire' %in% names(jsonData)))
genTrustQ <- rbind(genTrustQ, jsonData$generalisedTrustQuestionnaire)
participants
trials
advisors
View(trials)
NA == NA
trials$advisor0agrees == trials$advisor1agrees
install.packages('semPaths')
install.packages('semPlot')
