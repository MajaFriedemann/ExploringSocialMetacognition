coord_flip() +
theme_light()
ggplot(all.trials[all.trials$pid=='agr1', ],
aes(x = pid, y = initialConfidence, colour = as.factor(confidenceCategory))) +
geom_beeswarm() +
coord_flip() +
theme_light()
ggplot(all.trials[all.trials$pid=='agr1' & all.trials$initialCorrect, ],
aes(x = pid, y = initialConfidence, colour = as.factor(confidenceCategory))) +
geom_beeswarm() +
coord_flip() +
theme_light()
ggplot(all.trials[all.trials$initialCorrect & all.trials$experiment=='agr', ],
aes(x = pid, y = initialConfidence, colour = as.factor(confidenceCategory))) +
geom_beeswarm() +
coord_flip() +
theme_light() +
facet_wrap(~pid)
ggplot(all.trials[all.trials$initialCorrect & all.trials$experiment=='MAT', ],
aes(x = pid, y = initialConfidence, colour = as.factor(confidenceCategory))) +
geom_beeswarm() +
coord_flip() +
theme_light() +
facet_wrap(~pid)
ggplot(all.trials[all.trials$initialCorrect & all.trials$experiment=='MAT', ],
aes(x = 'responses', y = initialConfidence, colour = as.factor(confidenceCategory))) +
geom_beeswarm() +
coord_flip() +
theme_light() +
facet_wrap(~pid)
ggplot(all.trials[all.trials$initialCorrect & all.trials$experiment=='MAT', ],
aes(x = 'r', y = initialConfidence, colour = as.factor(confidenceCategory))) +
geom_beeswarm() +
coord_flip() +
theme_light() +
facet_wrap(~pid)
confidenceCategories
all.trials$confidenceCategory[all.trials$experiment == 'MAT'] <- all.trials$confidenceCategory[all.trials$experiment=='MAT'']+1
all.trials$confidenceCategory[all.trials$experiment == 'MAT'] <- all.trials$confidenceCategory[all.trials$experiment=='MAT']+1
unique(all.trials$confidenceCategory)
trials$confidenceCategory[trials$experiment=='MAT'] <- trials$confidenceCategory[trials$experiment=='MAT']+1
ggplot(all.trials[all.trials$initialCorrect & all.trials$experiment=='MAT', ],
aes(x = 'r', y = initialConfidence, colour = as.factor(confidenceCategory))) +
geom_beeswarm() +
coord_flip() +
theme_light() +
facet_wrap(~pid)
pidList <- 'MAT2'
ggplot(all.trials[all.trials$initialCorrect & all.trials$pid %in% pidList, ],
aes(x = 'r', y = initialConfidence, colour = as.factor(confidenceCategory))) +
geom_beeswarm() +
coord_flip() +
theme_light() +
facet_wrap(~pid)
ggplot(all.trials[all.trials$initialCorrect & all.trials$pid %in% pidList, ],
aes(x = pid, y = initialConfidence, colour = as.factor(confidenceCategory))) +
geom_beeswarm() +
coord_flip() +
theme_light()
pidList <- c('MAT2', 'MAT5')
ggplot(all.trials[all.trials$initialCorrect & all.trials$pid %in% pidList, ],
aes(x = pid, y = initialConfidence, colour = as.factor(confidenceCategory))) +
geom_beeswarm() +
coord_flip() +
theme_light()
pidList <- c('MAT2', 'MAT5', 'MAT7')
ggplot(all.trials[all.trials$initialCorrect & all.trials$pid %in% pidList, ],
aes(x = pid, y = initialConfidence, colour = as.factor(confidenceCategory))) +
geom_beeswarm() +
coord_flip() +
theme_light()
pidList <- c('MAT2', 'MAT5', 'MAT7', 'MAT10', 'MAT1')
ggplot(all.trials[all.trials$initialCorrect & all.trials$pid %in% pidList, ],
aes(x = pid, y = initialConfidence, colour = as.factor(confidenceCategory))) +
geom_beeswarm() +
coord_flip() +
theme_light()
unique(trials$practice)
trials[trials$practice, ] <- NULL
trials <- trials[!trials$practice, ]
unique(trials$practice)
pidPerPlot <- 5
for(i in 1:ceiling(length(unique(trials$pid))/pidPerPlot)) {
pidList <- unique(trials$pid)[((i-1)*pidPerPlot+1):i*pidPerPlot]
ggplot(all.trials[all.trials$initialCorrect & all.trials$pid %in% pidList, ],
aes(x = pid, y = initialConfidence, colour = as.factor(confidenceCategory))) +
geom_beeswarm() +
coord_flip() +
theme_light()
}
pidPerPlot <- 5
swarm <- list()
for(i in 1:ceiling(length(unique(trials$pid))/pidPerPlot)) {
pidList <- unique(trials$pid)[((i-1)*pidPerPlot+1):i*pidPerPlot]
swarm[[i]] <- ggplot(all.trials[all.trials$initialCorrect & all.trials$pid %in% pidList, ],
aes(x = pid, y = initialConfidence, colour = as.factor(confidenceCategory))) +
geom_beeswarm() +
coord_flip() +
theme_light() +
labs(title = 'Beeswarm plot for confidence responses') +
theme(legend.position = 'top')
}
swarm[[1]]
swarm[[2]]
i
unique(trials$pid)[((i-1)*pidPerPlot+1):i*pidPerPlot]
unique(trials$pid)
((i-1)*pidPerPlot+1):i*pidPerPlot
pidPerPlot <- 5
swarm <- list()
for(i in 1:ceiling(length(unique(trials$pid))/pidPerPlot)) {
pidList <- unique(trials$pid)[((i-1)*pidPerPlot+1):(i*pidPerPlot)]
swarm[[i]] <- ggplot(all.trials[all.trials$initialCorrect & all.trials$pid %in% pidList, ],
aes(x = pid, y = initialConfidence, colour = as.factor(confidenceCategory))) +
geom_beeswarm() +
coord_flip() +
theme_light() +
labs(title = 'Beeswarm plot for confidence responses') +
theme(legend.position = 'top')
}
swarm[[1]]
swarm[[35]]
swarm[[1]]
pidPerPlot <- 5
swarm <- list()
for(i in 1:ceiling(length(unique(trials$pid))/pidPerPlot)) {
pidList <- unique(trials$pid)[((i-1)*pidPerPlot+1):(i*pidPerPlot)]
swarm[[i]] <- ggplot(all.trials[all.trials$initialCorrect & all.trials$pid %in% pidList, ],
aes(x = pid, y = initialConfidence, colour = as.factor(confidenceCategory))) +
geom_violin() +
geom_beeswarm() +
coord_flip() +
theme_light() +
labs(title = 'Beeswarm plot for confidence responses') +
theme(legend.position = 'top')
}
swarm[[1]]
pidPerPlot <- 5
swarm <- list()
for(i in 1:ceiling(length(unique(trials$pid))/pidPerPlot)) {
pidList <- unique(trials$pid)[((i-1)*pidPerPlot+1):(i*pidPerPlot)]
swarm[[i]] <- ggplot(all.trials[all.trials$initialCorrect & all.trials$pid %in% pidList, ],
aes(x = pid, y = initialConfidence, colour = as.factor(confidenceCategory))) +
geom_beeswarm() +
coord_flip() +
theme_light() +
labs(title = 'Beeswarm plot for confidence responses') +
theme(legend.position = 'top')
}
swarm[[1]]
pidPerPlot <- 5
swarm <- list()
for(i in 1:ceiling(length(unique(trials$pid))/pidPerPlot)) {
pidList <- unique(trials$pid)[((i-1)*pidPerPlot+1):(i*pidPerPlot)]
swarm[[i]] <- ggplot(all.trials[all.trials$initialCorrect & all.trials$pid %in% pidList, ],
aes(x = pid, y = initialConfidence, colour = as.factor(confidenceCategory))) +
geom_beeswarm() +
scale_y_continuous(limits = c(0,55), expand = c(0,0)) +
coord_flip() +
theme_light() +
labs(title = 'Beeswarm plot for confidence responses') +
theme(legend.position = 'top',
panel.grid = element_blank())
}
swarm[[1]]
ggplot(all.trials[all.trials$initialCorrect & all.trials$pid %in% pidList, ],
aes(x = pid, y = initialConfidence, colour = as.factor(confidenceCategory))) +
geom_beeswarm() +
scale_y_continuous(limits = c(0,55), expand = c(0,0)) +
coord_flip() +
theme_light() +
labs(title = 'Beeswarm plot for confidence responses') +
theme(legend.position = 'top')
ggplot(all.trials[all.trials$initialCorrect & all.trials$pid %in% pidList, ],
aes(x = pid, y = initialConfidence, colour = as.factor(confidenceCategory))) +
geom_beeswarm() +
scale_y_continuous(limits = c(0,55), expand = c(0,1)) +
coord_flip() +
theme_light() +
labs(title = 'Beeswarm plot for confidence responses') +
theme(legend.position = 'top')
pidPerPlot <- 5
swarm <- list()
for(i in 1:ceiling(length(unique(trials$pid))/pidPerPlot)) {
pidList <- unique(trials$pid)[((i-1)*pidPerPlot+1):(i*pidPerPlot)]
swarm[[i]] <- ggplot(all.trials[all.trials$initialCorrect & all.trials$pid %in% pidList, ],
aes(x = pid, y = initialConfidence, colour = as.factor(confidenceCategory))) +
geom_beeswarm() +
scale_y_continuous(limits = c(0,55), expand = c(0,1)) +
coord_flip() +
theme_light() +
labs(title = 'Beeswarm plot for confidence responses') +
theme(legend.position = 'top')
}
swarm[[30]]
swarm[[31]]
pidPerPlot <- 4
swarm <- list()
for(i in 1:ceiling(length(unique(trials$pid))/pidPerPlot)) {
pidList <- unique(trials$pid)[((i-1)*pidPerPlot+1):(i*pidPerPlot)]
swarm[[i]] <- ggplot(all.trials[all.trials$initialCorrect & all.trials$pid %in% pidList, ],
aes(x = pid, y = initialConfidence, colour = as.factor(confidenceCategory))) +
geom_beeswarm() +
scale_y_continuous(limits = c(0,55), expand = c(0,1)) +
coord_flip() +
theme_light() +
labs(title = 'Beeswarm plot for confidence responses') +
theme(legend.position = 'top')
}
swarm[[31]]
swarm[[35]]
swarm[[37]]
swarm[[38]]
lags <- c(5,15,30,60,90,120,Inf)
df.lags <- NULL
# For each lag setting
print('Calculating trial confidence categories at various lag settings')
pb <- txtProgressBar(min = 0, max = length(lags) * nrow(participants))
for(lag in lags) {
# For each participant
# for(pid in mask){
for(pid in unique(participants$pid)) {
# for each trial calculate the confidence category using the lag
ts <- all.trials[all.trials$pid == pid, ]
ts$initialConfidence[!ts$initialCorrect] <- NaN # void confidence for incorrect trials
for(i in (min(ts$id)+1):max(ts$id)) {
trial <- ts[ts$id == i, ]
low <- i - lag
low <- ifelse(low < min(ts$id), min(ts$id), low)
testSet <- ts[ts$id %in% low:(i-1) & !is.nan(ts$initialConfidence), ]
# markers <- quantile(testSet$initialConfidence, c(.3,.7)) # nice approach, but not used in JS version
testSet <- testSet[order(testSet$initialConfidence),]
markers <- testSet$initialConfidence[c(round(nrow(testSet)*.3), round(nrow(testSet)*.7))]
trial$confidenceCategory <- sum(markers < trial$initialConfidence)
ts[ts$id == i, ] <- trial
}
# calculate confidence category proportions
ts <- ts[!ts$practice, ]
for(confCat in confidenceCategories) {
df.lags <- rbind(df.lags, data.frame(lag,
pid,
experiment = ts$experiment[1],
confCat,
prop = mean(ts$confidenceCategory==confCat, na.rm = T)))
}
setTxtProgressBar(pb, getTxtProgressBar(pb) + 1)
}
}
close(pb)
# plot results
ggplot(df.lags, aes(x = as.factor(lag), y = prop, colour = as.factor(confCat))) +
geom_hline(yintercept = .4, linetype = 'dashed') +
geom_hline(yintercept = .3, linetype = 'dashed') +
stat_summary(geom = 'point', fun.y = mean) +
stat_summary(geom = 'errorbar', fun.data = mean_cl_boot) +
facet_wrap(~experiment)
unique(df.lags$experiment)
lags <- c(5,15,30,60,90,120,Inf)
df.lags <- NULL
# For each lag setting
print('Calculating trial confidence categories at various lag settings')
pb <- txtProgressBar(min = 0, max = length(lags) * nrow(participants))
for(lag in lags) {
# For each participant
# for(pid in mask){
for(pid in unique(all.trials$pid)) {
# for each trial calculate the confidence category using the lag
ts <- all.trials[all.trials$pid == pid, ]
ts$initialConfidence[!ts$initialCorrect] <- NaN # void confidence for incorrect trials
for(i in (min(ts$id)+1):max(ts$id)) {
trial <- ts[ts$id == i, ]
low <- i - lag
low <- ifelse(low < min(ts$id), min(ts$id), low)
testSet <- ts[ts$id %in% low:(i-1) & !is.nan(ts$initialConfidence), ]
# markers <- quantile(testSet$initialConfidence, c(.3,.7)) # nice approach, but not used in JS version
testSet <- testSet[order(testSet$initialConfidence),]
markers <- testSet$initialConfidence[c(round(nrow(testSet)*.3), round(nrow(testSet)*.7))]
trial$confidenceCategory <- sum(markers < trial$initialConfidence)
ts[ts$id == i, ] <- trial
}
# calculate confidence category proportions
ts <- ts[!ts$practice, ]
for(confCat in confidenceCategories) {
df.lags <- rbind(df.lags, data.frame(lag,
pid,
experiment = ts$experiment[1],
confCat,
prop = mean(ts$confidenceCategory==confCat, na.rm = T)))
}
setTxtProgressBar(pb, getTxtProgressBar(pb) + 1)
}
}
close(pb)
# plot results
ggplot(df.lags, aes(x = as.factor(lag), y = prop, colour = as.factor(confCat))) +
geom_hline(yintercept = .4, linetype = 'dashed') +
geom_hline(yintercept = .3, linetype = 'dashed') +
stat_summary(geom = 'point', fun.y = mean) +
stat_summary(geom = 'errorbar', fun.data = mean_cl_boot) +
facet_wrap(~experiment)
length(testSet)
length(ts)
low:(i-1)
ts$id
i - lag
min(ts$id)
ts$id %in% low:(i-1)
ts$id[305]
ts$id
all.trials$id <- rep(1:363, 25)
all.trials$id[all.trials$experiment=='MAT'] <- rep(1:363, 25)
min(trials$id[trials$experiment=='MAT'])
aggregate(id ~ pid, trials[trials$experiment=='MAT', ], min)
trials$id[trials$experiment=='MAT'] <- rep(51:363, 25)
length(trials$id[trials$experiment=='MAT'])
length(rep(51:363, 24))
trials$id[trials$experiment=='MAT'] <- rep(51:363, 24)
lags <- c(5,15,30,60,90,120,Inf)
df.lags <- NULL
# For each lag setting
print('Calculating trial confidence categories at various lag settings')
pb <- txtProgressBar(min = 0, max = length(lags) * nrow(participants))
for(lag in lags) {
# For each participant
# for(pid in mask){
for(pid in unique(all.trials$pid)) {
# for each trial calculate the confidence category using the lag
ts <- all.trials[all.trials$pid == pid, ]
ts$initialConfidence[!ts$initialCorrect] <- NaN # void confidence for incorrect trials
for(i in (min(ts$id)+1):max(ts$id)) {
trial <- ts[ts$id == i, ]
low <- i - lag
low <- ifelse(low < min(ts$id), min(ts$id), low)
testSet <- ts[ts$id %in% low:(i-1) & !is.nan(ts$initialConfidence), ]
# markers <- quantile(testSet$initialConfidence, c(.3,.7)) # nice approach, but not used in JS version
testSet <- testSet[order(testSet$initialConfidence),]
markers <- testSet$initialConfidence[c(round(nrow(testSet)*.3), round(nrow(testSet)*.7))]
trial$confidenceCategory <- sum(markers < trial$initialConfidence)
ts[ts$id == i, ] <- trial
}
# calculate confidence category proportions
ts <- ts[!ts$practice, ]
for(confCat in confidenceCategories) {
df.lags <- rbind(df.lags, data.frame(lag,
pid,
experiment = ts$experiment[1],
confCat,
prop = mean(ts$confidenceCategory==confCat, na.rm = T)))
}
setTxtProgressBar(pb, getTxtProgressBar(pb) + 1)
}
}
close(pb)
# plot results
ggplot(df.lags, aes(x = as.factor(lag), y = prop, colour = as.factor(confCat))) +
geom_hline(yintercept = .4, linetype = 'dashed') +
geom_hline(yintercept = .3, linetype = 'dashed') +
stat_summary(geom = 'point', fun.y = mean) +
stat_summary(geom = 'errorbar', fun.data = mean_cl_boot) +
facet_wrap(~experiment)
load(file.choose())
# Add in the exported data from the MATLAB experiment
# load(file.choose())
name <- as.character(export$trials$experiment[1])
results[[name]] <- list()
for(n in names(export))
results[[name]][[n]] <- export[[n]]
results$Nic$all.trials$pid <- paste0('Nic', results$Nic$all.trials$pid)
results$Nic$trials$pid   <- paste0('Nic', results$Nic$trials$pid)
all.trials <- rbind(all.trials, results$Nic$all.trials)
trials <- rbind(trials, results$Nic$trials)
lags <- c(5,15,30,60,90,120,Inf)
df.lags <- NULL
# For each lag setting
print('Calculating trial confidence categories at various lag settings')
pb <- txtProgressBar(min = 0, max = length(lags) * nrow(participants))
for(lag in lags) {
# For each participant
# for(pid in mask){
for(pid in unique(all.trials$pid)) {
# for each trial calculate the confidence category using the lag
ts <- all.trials[all.trials$pid == pid, ]
ts$initialConfidence[!ts$initialCorrect] <- NaN # void confidence for incorrect trials
for(i in (min(ts$id)+1):max(ts$id)) {
trial <- ts[ts$id == i, ]
low <- i - lag
low <- ifelse(low < min(ts$id), min(ts$id), low)
testSet <- ts[ts$id %in% low:(i-1) & !is.nan(ts$initialConfidence), ]
# markers <- quantile(testSet$initialConfidence, c(.3,.7)) # nice approach, but not used in JS version
testSet <- testSet[order(testSet$initialConfidence),]
markers <- testSet$initialConfidence[c(round(nrow(testSet)*.3), round(nrow(testSet)*.7))]
trial$confidenceCategory <- sum(markers < trial$initialConfidence)
ts[ts$id == i, ] <- trial
}
# calculate confidence category proportions
ts <- ts[!ts$practice, ]
for(confCat in confidenceCategories) {
df.lags <- rbind(df.lags, data.frame(lag,
pid,
experiment = ts$experiment[1],
confCat,
prop = mean(ts$confidenceCategory==confCat, na.rm = T)))
}
setTxtProgressBar(pb, getTxtProgressBar(pb) + 1)
}
}
close(pb)
# plot results
ggplot(df.lags, aes(x = as.factor(lag), y = prop, colour = as.factor(confCat))) +
geom_hline(yintercept = .4, linetype = 'dashed') +
geom_hline(yintercept = .3, linetype = 'dashed') +
stat_summary(geom = 'point', fun.y = mean) +
stat_summary(geom = 'errorbar', fun.data = mean_cl_boot) +
facet_wrap(~experiment)
library(ggplot2)
# plot results
ggplot(df.lags, aes(x = as.factor(lag), y = prop, colour = as.factor(confCat))) +
geom_hline(yintercept = .4, linetype = 'dashed') +
geom_hline(yintercept = .3, linetype = 'dashed') +
stat_summary(geom = 'point', fun.y = mean) +
stat_summary(geom = 'errorbar', fun.data = mean_cl_boot) +
facet_wrap(~experiment)
df.markers <- NULL
for(pid in unique(trials$pid)) {
ts <- all.trials[all.trials$pid == pid & all.trials$initialCorrect, ]
tmp <- list()
for(practice in c(T,F)) {
v <- ts$initialConfidence[ts$practice == practice]
v <- v[order(v)]
tmp[[as.numeric(practice)+1]] <- data.frame(low = v[round(length(v) * .3)],
high = v[round(length(v) * .7)])
}
for(marker in c(1,2)) {
name <- c('low', 'high')[marker]
df.markers <- rbind(df.markers, data.frame(pid,
experiment = ts$experiment[1],
marker = name,
practice = as.numeric(tmp[[marker]][name]),
real = as.numeric(tmp[[marker]][name])))
}
}
ggplot(df.markers, aes(x = practice, y = real, colour = pid)) +
geom_abline(slope = 1, linetype = 'dashed') +
geom_rect(inherit.aes = F, xmin = 0, ymin = 0, xmax = 15, ymax = 15, data = data.frame(marker = 'low'),
fill = 'lightblue', alpha = .3) +
geom_rect(inherit.aes = F, xmin = 35, ymin = 35, xmax = 50, ymax = 50, data = data.frame(marker = 'high'),
fill = 'pink', alpha = .3) +
geom_point(alpha = 0.3) +
facet_grid(marker ~ experiment) +
theme_light() +
theme(legend.position = 'none',
panel.spacing = unit(1, 'lines')) +
coord_equal() +
scale_x_continuous(limits = c(0,50), expand = c(0,0)) +
scale_y_continuous(limits = c(0,50), expand = c(0,0)) +
labs(title = 'Confidence Thresholds',
subtitle = 'Each dot is a participant\'s low/high threshold\nBoxes show idealised low/high confidence areas of the scales.')
as.numeric('abc1')
sub('\D+', '', pid)
sub('\\D+', '', pid)
df.markers <- NULL
for(pid in unique(trials$pid)) {
ts <- all.trials[all.trials$pid == pid & all.trials$initialCorrect, ]
tmp <- list()
for(practice in c(T,F)) {
v <- ts$initialConfidence[ts$practice == practice]
v <- v[order(v)]
tmp[[as.numeric(practice)+1]] <- data.frame(low = v[round(length(v) * .3)],
high = v[round(length(v) * .7)])
}
for(marker in c(1,2)) {
name <- c('low', 'high')[marker]
df.markers <- rbind(df.markers, data.frame(pid,
pNum = sub('\\D+', '', pid),
experiment = ts$experiment[1],
marker = name,
practice = as.numeric(tmp[[marker]][name]),
real = as.numeric(tmp[[marker]][name])))
}
}
ggplot(df.markers, aes(x = practice, y = real, colour = as.factor(pNum))) +
geom_abline(slope = 1, linetype = 'dashed') +
geom_rect(inherit.aes = F, xmin = 0, ymin = 0, xmax = 15, ymax = 15, data = data.frame(marker = 'low'),
fill = 'lightblue', alpha = .3) +
geom_rect(inherit.aes = F, xmin = 35, ymin = 35, xmax = 50, ymax = 50, data = data.frame(marker = 'high'),
fill = 'pink', alpha = .3) +
geom_point(alpha = 0.3) +
facet_grid(marker ~ experiment) +
theme_light() +
theme(legend.position = 'none',
panel.spacing = unit(1, 'lines')) +
coord_equal() +
scale_x_continuous(limits = c(0,50), expand = c(0,0)) +
scale_y_continuous(limits = c(0,50), expand = c(0,0)) +
labs(title = 'Confidence Thresholds',
subtitle = 'Each dot is a participant\'s low/high threshold\nBoxes show idealised low/high confidence areas of the scales.')
ggplot(df.markers, aes(x = practice, y = real, colour = as.factor(pNum))) +
geom_abline(slope = 1, linetype = 'dashed') +
geom_rect(inherit.aes = F, xmin = 0, ymin = 0, xmax = 15, ymax = 15, data = data.frame(marker = 'low'),
fill = 'lightblue', alpha = .3) +
geom_rect(inherit.aes = F, xmin = 35, ymin = 35, xmax = 50, ymax = 50, data = data.frame(marker = 'high'),
fill = 'pink', alpha = .3) +
geom_point(alpha = 0.8) +
facet_grid(marker ~ experiment) +
theme_light() +
theme(legend.position = 'none',
panel.spacing = unit(1, 'lines')) +
coord_equal() +
scale_x_continuous(limits = c(0,50), expand = c(0,0)) +
scale_y_continuous(limits = c(0,50), expand = c(0,0)) +
labs(title = 'Confidence Thresholds',
subtitle = 'Each dot is a participant\'s low/high threshold\nBoxes show idealised low/high confidence areas of the scales.')
