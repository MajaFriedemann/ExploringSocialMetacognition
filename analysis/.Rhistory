"repeatedQuestion",
paste(tmp$excluded, ", repeatedQuestion"))
exclusions$excluded[exclusions$pid %in% ids, ] <- tmp$excluded
}
}
table(exclusions$excluded)
debrief.form$guessedManipulation <-
c(F, F, F, F, F, F, F, F, F, T,
F, F, F, F, F, F, F, T, F, T,
F, F, F, F, F, F, F, F, T, F,
F, T, F, F)
debrief.form[, c("pid", "comment", "guessedManipulation")]
for (p in exclusions$pid) {
if (p %in% debrief.form$pid) {
if (debrief.form$guessedManipulation[debrief.form$pid == p]) {
exclusions$excluded[exclusions$pid == p] <-
if (exclusions$excluded[exclusions$pid == p] == F)
"guessedManipulation" else
paste(c(exclusions$excluded[exclusions$pid == p],
"guessedManipulation"), collapse = ", ")
}
}
}
# Check for erroneous marker values
okayMarkers <- c(1, 3, 9, 27)
for (p in unique(AdvisedTrial$pid)) {
tmp <- AdvisedTrial[AdvisedTrial$pid == p, ]
if (!all(tmp$responseMarkerWidth %in% okayMarkers) |
!all(tmp$responseMarkerWidthFinal %in% okayMarkers)) {
if (p %in% exclusions$pid) {
exclusions$excluded[exclusions$pid == p] <-
if (exclusions$excluded[exclusions$pid == p] == F)
"badMarker" else
paste(c(exclusions$excluded[exclusions$pid == p],
"badMarker"), collapse = ", ")
}
}
}
table(exclusions$excluded)
n <- 5 # set by power analysis
for (x in unique(okayIds$condition)) {
i <- 0
for (p in exclusions$pid[exclusions$excluded == F]) {
if (okayIds$condition[okayIds$pid %in% p] == x) {
if (i >= n) {
exclusions$excluded[exclusions$pid == p] <- "excess"
} else {
i <- i + 1
}
}
}
}
table(exclusions$excluded)
AdvisedTrial <- AdvisedTrial[AdvisedTrial$pid %in%
exclusions$pid[exclusions$excluded == F], ]
decisions <- decisions[decisions$pid %in%
exclusions$pid[exclusions$excluded == F], ]
PP <- PP[PP$pid %in% exclusions$pid[exclusions$excluded == F], ]
# Drop extraneous factor levels
for (n in ls()) {
dirty <- F
x <- get(n)
if ("data.frame" %in% class(x)) {
for (i in 1:ncol(x)) {
if (is.factor(x[[i]])) {
x[[i]] <- factor(x[[i]]) # renew level assignment
dirty <- T
}
}
}
if (dirty) {
assign(n, x)
}
}
aggregate(pid ~ pid + firstAdvisor + feedback, AdvisedTrial,
function(x) length(unique(x)))
# bind feedback property from participants
advisors <- advisors[advisors$pid %in% PP$pid, ]
advisors <- left_join(advisors, unique(PP[c("pid", "feedback")]), "pid")
# drop practice advisors
advisors <- advisors[advisors$idDescription != "Practice", ]
# Calculate the proportion of trials each breakdown in PP accounts for
PP$proportion <- sapply(1:nrow(PP),
function(i)
2 * PP$number[i] /
sum(PP$number[PP$pid == PP$pid[i]]))
# Pad out the proportions with 0s
for (p in unique(PP$pid)) {
for (d in unique(PP$decision))
for (m in markerList)
if (nrow(PP[PP$pid == p &
PP$decision == d &
PP$responseMarker == m, ]) == 0)
PP <- safeBind(list(PP,
tibble(pid = p,
responseMarker = m,
feedback = PP$feedback[PP$pid == p][1],
decision = d,
number = 0,
excluded = PP$excluded[PP$pid == p][1],
proportion = 0)))
}
#' Means of v for each marker after converting df entries to participant means
#' @params v column
#' @params df dataframe containing v
markerBreakdown <- function(v, df, hideMarkerTotal = F, missingValue = NA, ...) {
v <- substitute(v)
fun <- function(x) {
if (!nrow(x))
return(missingValue)
eq <- as.formula(paste(ensym(v), "~ + pid"))
tmp <- aggregate(eq, x, mean, ...)
mean(tmp[, ncol(tmp)])
}
# rename total fields
n <- function(x, alt = NA) if (length(x) == 1) x else alt
out <- list()
for (d in uniqueTotal(df$decision)) {
if (length(d) != 1)
next()
for (f in uniqueTotal(df$feedback)) {
tmp <- tibble(decision = n(d), feedback = n(f))
for (m in uniqueTotal(markerList)) {
if (length(m) != 1 && hideMarkerTotal)
next()
x <- fun(df[df$decision %in% d &
df$feedback %in% f &
df$responseMarker %in% m, ])
if (is.na(n(m)))
tmp$mean <- x
else
tmp[paste0("mean|m=", m)] <- x
}
out[[d]] <- rbind(out[[d]], tmp)
}
}
out
}
#' Return a version of df with only the trials with a single advisor,
#' and with all advice columns accessible as advisor0x where x is the
#' name of the advisor column.
#' @param df data frame to process
singleAdvisorTrials <- function(df) {
# Find the number of advisors by counting advisorXadvice columns
df$advisorCount <- 0
for (r in 1:nrow(df)) {
i <- 0
while (T) {
if (!length(grep(paste0("advisor", i), names(df)))) {
break()
}
i <- i + 1
}
df$advisorCount[r] <- i
}
# Only keep trials with a single advisor
out <- df[df$advisorCount == 1, ]
# fill in missing column names using the advisor's description + varname
advCols <- unique(reFirstMatch(paste0("(?:",
paste(advisorNames, collapse = "|"),
")\\.(\\S+)$"), names(df)))
advCols <- advCols[!(advCols %in% unique(reFirstMatch("advisor0(\\S+)$",
names(df))))]
for (i in 1:nrow(out)) {
for (v in advCols) {
out[i, paste0("advisor0", v)] <-
out[i, paste0(out$advisor0idDescription[i], ".", v)]
}
}
out
}
block2 <- singleAdvisorTrials(AdvisedTrial) # in this design block2 is the same as the main AdvisedTrial dataframe
block2Decisions <- singleAdvisorTrials(decisions) # likewise for block2Decisions and decisions
offBrand <- AdvisedTrial[AdvisedTrial$advisor0offBrand, ]
tmp <- markerBreakdown(proportion, PP, hideMarkerTotal = T)
# Proportions within a row should sum to 1
for (x in tmp)
expect_equal(apply(x[, 3:5], 1, sum), rep(1, nrow(x)))
num2str.tibble(tmp$first, isProportion = T, precision = 3)
num2str.tibble(tmp$last, isProportion = T, precision = 3)
ggplot(PP[!is.na(PP$responseMarker), ],
aes(x = responseMarker, y = proportion)) +
geom_violin(alpha = .25, colour = NA, fill = "grey75") +
geom_boxplot(fill = NA, outlier.color = NA) +
geom_line(alpha = .5, aes(colour = pid, group = pid)) +
geom_point(alpha = .5, aes(colour = pid)) +
stat_summary(geom = "line", fun.y = mean,
aes(group = 1, linetype = "mean"), size = 1.5) +
facet_grid(feedback ~ decision, labeller = label_both) +
scale_linetype_manual(values = c("dashed")) +
labs(x = "response marker width (years)",
y = "p(marker used)")
tmp <- markerBreakdown(responseCorrect, decisions)
num2str.tibble(tmp$first, isProportion = T, precision = 3)
num2str.tibble(tmp$last, isProportion = T, precision = 3)
ggplot(aggregate(responseCorrect ~
responseMarker + decision + feedback + pid,
decisions, mean),
aes(x = responseMarker, y = responseCorrect)) +
geom_violin(alpha = .25, colour = NA, fill = "grey75") +
geom_boxplot(fill = NA, outlier.color = NA) +
geom_line(alpha = .5, aes(colour = pid, group = pid)) +
geom_point(alpha = .5, aes(colour = pid)) +
stat_summary(geom = "line", fun.y = mean,
aes(group = 1, linetype = "mean"), size = 1.5) +
facet_grid(feedback ~ decision, labeller = label_both) +
scale_linetype_manual(values = c("dashed")) +
labs(x = "response marker width (years)",
y = "p(response correct)")
tmp <- markerBreakdown(responseError, block2Decisions)
num2str.tibble(tmp$first)
num2str.tibble(tmp$last)
ggplot(aggregate(responseError ~
responseMarker + decision + feedback + pid,
block2Decisions, mean),
aes(x = responseMarker, y = responseError)) +
geom_violin(alpha = .25, colour = NA, fill = "grey75") +
geom_boxplot(fill = NA, outlier.color = NA) +
geom_line(alpha = .5, aes(colour = pid, group = pid)) +
geom_point(alpha = .5, aes(colour = pid)) +
stat_summary(geom = "line", fun.y = mean,
aes(group = 1, linetype = "mean"), size = 1.5) +
facet_grid(feedback ~ decision, labeller = label_both) +
scale_linetype_manual(values = c("dashed")) +
labs(x = "response marker width (years)",
y = "|target - response marker centre| (years)")
out <- list()
for (f in unique(AdvisedTrial$feedback)) {
m <- AdvisedTrial$feedback == f
tmp <- NULL
for (a in advisorNames) {
r <- tibble(feedback = f, advisor = a)
for (x in adviceTypes) {
eq <- as.formula(paste0(a, ".nominalType ~ pid"))
r[, x] <- mean(aggregate(eq,
AdvisedTrial[m, ],
function(q) mean(q == x))[, 2])
}
tmp <- rbind(tmp, r)
}
out[[as.character(f)]] <- tmp
}
prop2str(out$`TRUE`, precision = 3)
prop2str(out$`FALSE`, precision = 3)
out <- list()
for (f in unique(AdvisedTrial$feedback)) {
m <- AdvisedTrial$feedback == f
tmp <- NULL
for (a in advisorNames) {
r <- tibble(feedback = f, advisor = a)
for (x in adviceTypes) {
eq <- as.formula(paste0(a, ".actualType ~ pid"))
r[, x] <- mean(aggregate(eq,
AdvisedTrial[m, ],
function(q) mean(q == x))[, 2])
}
tmp <- rbind(tmp, r)
}
out[[as.character(f)]] <- tmp
}
prop2str(out$`TRUE`, precision = 3)
prop2str(out$`FALSE`, precision = 3)
tmp <- NULL
for (a in advisorNames) {
eq <- as.formula(paste0(a, ".error ~ pid + feedback + firstAdvisor"))
r <- aggregate(eq, AdvisedTrial, mean, na.rm = T)
colnames(r) <- c("pid", "feedback", "firstAdvisor", "error")
r$advisor = a
tmp <- rbind(tmp, as.tibble(r))
}
prop2str(as.tibble(aggregate(error ~ advisor + feedback + firstAdvisor,
tmp,
mean, na.rm = T)),
precision = 3)
ggplot(tmp, aes(x = advisor, y = error, colour = pid)) +
geom_violin(colour = NA, fill = "grey75", alpha = .25) +
geom_boxplot(outlier.colour = NA, fill = NA, aes(group = advisor)) +
geom_line(alpha = .5, aes(colour = pid, group = pid)) +
geom_point(alpha = .5, aes(colour = pid)) +
stat_summary(geom = "line", fun.y = mean,
aes(group = 1, linetype = "mean"), size = 1.5) +
facet_grid(firstAdvisor ~ feedback, scales = "free_y", labeller = label_both)
tmp <- NULL
for (a in advisorNames) {
eq <- as.formula(paste0(a, ".error ~ pid + feedback + firstAdvisor"))
r <- aggregate(eq, offBrand, mean, na.rm = T)
colnames(r) <- c("pid", "feedback", "firstAdvisor", "error")
r$advisor = a
tmp <- rbind(tmp, as.tibble(r))
}
prop2str(as.tibble(aggregate(error ~ advisor + feedback + firstAdvisor,
tmp,
mean, na.rm = T)),
precision = 3)
ggplot(tmp, aes(x = advisor, y = error, colour = pid)) +
geom_violin(colour = NA, fill = "grey75", alpha = .25) +
geom_boxplot(outlier.colour = NA, fill = NA, aes(group = advisor)) +
geom_line(alpha = .5, aes(colour = pid, group = pid)) +
geom_point(alpha = .5, aes(colour = pid)) +
stat_summary(geom = "line", fun.y = mean,
aes(group = 1, linetype = "mean"), size = 1.5) +
facet_grid(firstAdvisor ~ feedback, scales = "free_y", labeller = label_both)
tmp <- NULL
for (a in advisorNames) {
eq <- as.formula(paste0(a, ".distance ~ pid + feedback + firstAdvisor"))
r <- aggregate(eq, AdvisedTrial, mean, na.rm = T)
colnames(r) <- c("pid", "feedback", "firstAdvisor", "distance")
r$advisor = a
tmp <- rbind(tmp, as.tibble(r))
}
prop2str(as.tibble(aggregate(distance ~ advisor + feedback + firstAdvisor,
tmp,
mean, na.rm = T)),
precision = 3)
ggplot(tmp, aes(x = advisor, y = distance, colour = pid)) +
geom_violin(colour = NA, fill = "grey75", alpha = .25) +
geom_boxplot(outlier.colour = NA, fill = NA, aes(group = advisor)) +
geom_line(alpha = .5, aes(colour = pid, group = pid)) +
geom_point(alpha = .5, aes(colour = pid)) +
stat_summary(geom = "line", fun.y = mean,
aes(group = 1, linetype = "mean"), size = 1.5) +
facet_grid(firstAdvisor ~ feedback, labeller = label_both)
tmp <- NULL
for (a in advisorNames) {
eq <- as.formula(paste0(a, ".distance ~ pid + feedback + firstAdvisor"))
r <- aggregate(eq, offBrand, mean, na.rm = T)
colnames(r) <- c("pid", "feedback", "firstAdvisor", "distance")
r$advisor = a
tmp <- rbind(tmp, as.tibble(r))
}
prop2str(as.tibble(aggregate(distance ~ advisor + feedback + firstAdvisor,
tmp,
mean, na.rm = T)),
precision = 3)
ggplot(tmp, aes(x = advisor, y = distance, colour = pid)) +
geom_violin(colour = NA, fill = "grey75", alpha = .25) +
geom_boxplot(outlier.colour = NA, fill = NA, aes(group = advisor)) +
geom_line(alpha = .5, aes(colour = pid, group = pid)) +
geom_point(alpha = .5, aes(colour = pid)) +
stat_summary(geom = "line", fun.y = mean,
aes(group = 1, linetype = "mean"), size = 1.5) +
facet_grid(firstAdvisor ~ feedback, scales = "free_y", labeller = label_both)
tmp <- NULL
for (a in advisorNames) {
eq <- as.formula(paste0(a, ".woa ~ pid + feedback + firstAdvisor"))
r <- aggregate(eq, AdvisedTrial, mean, na.rm = T)
colnames(r) <- c("pid", "feedback", "firstAdvisor", "WoA")
r$advisor <- a
tmp <- rbind(tmp, r)
}
prop2str(as.tibble(aggregate(WoA ~ advisor + feedback + firstAdvisor,
tmp,
mean, na.rm = T)),
precision = 3)
ggplot(tmp, aes(x = advisor, y = WoA, colour = pid)) +
geom_violin(colour = NA, fill = "grey75", alpha = .25) +
geom_boxplot(outlier.colour = NA, fill = NA, aes(group = advisor)) +
geom_line(alpha = .5, aes(colour = pid, group = pid)) +
geom_point(alpha = .5, aes(colour = pid)) +
stat_summary(geom = "line", fun.y = mean,
aes(group = 1, linetype = "mean"), size = 1.5) +
facet_grid(firstAdvisor ~ feedback, labeller = label_both)
tmp <- NULL
for (a in advisorNames) {
x <- offBrand[offBrand$advisor0idDescription == a, ]
eq <- as.formula(paste0(a, ".woa ~ pid + feedback + firstAdvisor"))
r <- aggregate(eq, x, mean, na.rm = T)
colnames(r) <- c("pid", "feedback", "firstAdvisor", "WoA")
r$advisor <- a
tmp <- rbind(tmp, r)
}
prop2str(as.tibble(aggregate(WoA ~ advisor + feedback + firstAdvisor,
tmp,
mean, na.rm = T)),
precision = 3)
ggplot(tmp, aes(x = advisor, y = WoA, colour = pid)) +
geom_violin(colour = NA, fill = "grey75", alpha = .25) +
geom_boxplot(outlier.colour = NA, fill = NA, aes(group = advisor)) +
geom_line(alpha = .5, aes(colour = pid, group = pid)) +
geom_point(alpha = .5, aes(colour = pid)) +
stat_summary(geom = "line", fun.y = mean,
aes(group = 1, linetype = "mean"), size = 1.5) +
facet_grid(firstAdvisor ~ feedback, labeller = label_both)
low <- 0
high <- 1
n <- 11
block2$woa <- ""
for (x in c("woa", "woaRaw")) {
block2[, paste0("advisor0", x)] <- sapply(1:nrow(block2), function(i)
unlist(block2[i,
paste0(as.character(block2$advisor0idDescription[i]),
".", x)]))
}
block2$woa[block2$advisor0woaRaw >= 1] <- ">=1"
for (x in rev(seq(low, high, length.out = n))) {
block2$woa[block2$advisor0woaRaw < x] <- paste0("<", x)
}
block2$woa <- factor(block2$woa)
# update offbrand
offBrand <- block2[block2$advisor0actualType == "disagreeReflected", ]
tmp <- block2[!is.nan(block2$advisor0woaRaw), ]
ggplot(tmp, aes(woa)) +
geom_histogram(stat = "count") +
facet_grid(feedback ~ advisor0idDescription, labeller = label_both)
tmp <-
block2[block2$woa %in% c("<0", ">=1", ""), c("pid", "advisor0idDescription",
"stimHTML", "number",
"responseEstimateLeft",
"responseMarkerWidth",
"responseEstimateLeftFinal",
"responseMarkerWidthFinal",
"advisor0advice",
"advisor0woa",
"advisor0woaRaw")]
tmp <- aggregate(errorReduction ~ pid + feedback + firstAdvisor,
AdvisedTrial, mean, na.rm = T)
num2str(as.tibble(aggregate(errorReduction ~ feedback + firstAdvisor,
tmp, mean, na.rm = T)))
ggplot(tmp, aes(x = feedback, y = errorReduction, colour = pid)) +
geom_violin(alpha = .25, colour = NA, fill = "grey75") +
geom_boxplot(fill = NA, outlier.color = NA, aes(group = feedback)) +
stat_summary(geom = "line", fun.y = mean,
aes(group = 1, linetype = "mean"), size = 1.5) +
geom_point(alpha = .5, aes(colour = pid)) +
facet_wrap(~firstAdvisor, labeller = label_both)
tmp <- aggregate(errorReduction ~
pid + feedback + firstAdvisor + advisor0idDescription,
offBrand, mean, na.rm = T)
num2str(as.tibble(aggregate(errorReduction ~
feedback + firstAdvisor +
advisor0idDescription,
tmp, mean, na.rm = T)))
ggplot(tmp,
aes(x = advisor0idDescription, y = errorReduction, colour = pid)) +
geom_hline(yintercept = 0, linetype = "dashed", size = 0.5) +
geom_violin(alpha = .25, colour = NA, fill = "grey75") +
geom_boxplot(fill = NA, outlier.color = NA,
aes(group = advisor0idDescription)) +
stat_summary(geom = "line", fun.y = mean,
aes(group = 1, linetype = "mean"), size = 1.5) +
geom_point(alpha = .5, aes(colour = pid)) +
facet_grid(firstAdvisor ~ feedback, labeller = label_both)
df <- aggregate(advisor0woa ~
pid + feedback + advisor0idDescription + firstAdvisor,
offBrand, mean, na.rm = T)
df$feedback <- factor(df$feedback)
# remove incomplete cases
for (p in unique(df$pid)) {
if (nrow(df[df$pid == p, ]) != 2) {
print(paste("Dropping incomplete case pid =", p))
df <- df[df$pid != p, ]
}
}
# refactor pid
df$pid <- factor(df$pid)
r <- ezANOVA(df, advisor0woa, pid,
within = advisor0idDescription,
between = list(feedback, firstAdvisor),
detailed = T,
return_aov = T,
type = 2)
r
df <- df[order(df$pid), ]
tmp <- df[df$advisor0idDescription == "Accurate",
c("pid", "feedback", "firstAdvisor")]
tmp$AccPref <- df$advisor0woa[df$advisor0idDescription == "Accurate"] -
df$advisor0woa[df$advisor0idDescription == "Agreeing"]
r <- md.ttest(tmp$AccPref[tmp$feedback == T],
tmp$AccPref[tmp$feedback != T],
labels = c("*M*|fb", "*M*|¬fb"))
cat(r)
r <- md.ttest(tmp$AccPref[tmp$firstAdvisor == "Accurate"],
tmp$AccPref[tmp$firstAdvisor != "Accurate"],
labels = c("*M*|Acc", "*M*|Agr"))
cat(r)
# examine by feedback type
r <- md.ttest(tmp$AccPref[tmp$feedback == T &
tmp$firstAdvisor == "Accurate"],
tmp$AccPref[tmp$feedback == T &
tmp$firstAdvisor != "Accurate"],
labels = c("*M*|fb,Acc", "*M*|fb,Agr"))
cat(r)
cat("\n\n")
r <- md.ttest(tmp$AccPref[tmp$feedback != T &
tmp$firstAdvisor == "Accurate"],
tmp$AccPref[tmp$feedback != T &
tmp$firstAdvisor != "Accurate"],
labels = c("*M*|¬fb,Acc", "*M*|¬fb,Agr"))
cat(r)
# list packages
packageNames <- (.packages())
# don't include very core package
packageNames <- packageNames[!(packageNames %in%
rownames(installed.packages(
priority = "base")))]
# but do include the base package
packageNames <- c("base", packageNames)
out <- NULL
for (p in packageNames) {
out <- rbind(out, data.frame('Package' = p,
'Citations' = paste(format(citation(p),
style = 'textVersion'),
collapse = '<br/><br/>')))
}
kable(out)
cat(paste('Time stamp:', Sys.time(), '\n\n'))
cat('Runtime \n')
proc.time()
cat('\n')
sessionInfo()
source('F:/xampp/htdocs/ExploringSocialMetacognition/analysis/ACv2/paymentAndExclusion.R', echo=TRUE)
source('F:/xampp/htdocs/ExploringSocialMetacognition/analysis/ACv2/paymentAndExclusion.R', echo=TRUE)
