<!DOCTYPE html>
<html>
<head>
    <title>My experiment</title>
    <script src="https://www.gstatic.com/charts/loader.js"></script>
    <script src="../jsPsych/jspsych.js"></script>
    <script src="../jsPsych/plugins/jspsych-instructions.js"></script>
    <script src="../jsPsych/plugins/jspsych-html-keyboard-response.js"></script>
    <script src="../jsPsych/plugins/jspsych-canvas-sliders-response.js"></script>
    <script src="jspsych-function-sliders-response.js"></script>
    <script src="exploringSocialMetacognition.js"></script>
    <script src="analysis.js"></script>
    <script src="jspsych-jas-present-advice-choice.js"></script>
    <link rel="stylesheet" href="../jsPsych/css/jspsych.css"/>
    <link rel="stylesheet" href="confidenceSliders.css"/>
    <link rel="stylesheet" href="feedbackStyle.css"/>
    <style type="text/css">
        body {
            background-color: #858585;
        }
        div.advisorChoice-marker {
            width: 12px;
            height: 40px;
            position: absolute;
            z-index: -1;
            box-shadow: 0 0 5px 0 yellow;
            border-radius: 3px;
            background-color: yellow;
        }
        img.advisor-portrait {
            border: 2px solid black;
            padding: 5px;
            background-color: black;
            border-radius: 25px;
        }
        img.advisorChoice-choice {
            max-height: 150px;
            display: block;
            margin: 20px auto;
        }
        img.advisorChoice-choice:hover {
            cursor: pointer;
            background-color: white;
        }
        .jspsych-content {
            width: 100%;
        }
        #progressbar-outer {
            width: 80%;
            height: 15px;
            background-color: #F1F1F1;
            display: inline-block;
            border-radius: 5px;
        }
        #progressbar-inner {
            background-color: #2196F3;
            height: 15px;
            border-radius: 5px;
        }
        #jspsych-progressbar-container > span {
            font-size: 0.8em;
        }
        #jspsych-content {
            max-width: 600px;
        }
    </style>
</head>
<body></body>
<script type="text/javascript">
    const trialTypes = {
        catch: 0,
        force: 1,
        choice: 2
    };
    const trialTypeNames = {
        [trialTypes.catch]: 'catch',
        [trialTypes.force]: 'force',
        [trialTypes.choice]: 'choice'
    };

    /**
     * Do the actual drawing on the canvas.
     *
     * This function is called by the trial (supplied as stimulus). Query the Governor to get the details for
     * drawing.
     *
     * @param {string} canvasId - id of the canvas on which to draw the dots (supplied by the trial)
     * @param {function} callback - function to execute in order to enable plugin to collect a response
     */
    function drawDots(canvasId) {
        gov.currentTrial.dotDifference = gov.dotDifference;
        let low = gov.dotCount - gov.dotDifference;
        let high = gov.dotCount + gov.dotDifference;
        let dots = gov.currentTrial.whichSide === 0 ? [high, low] : [low, high];
        let grid = new ESM.DoubleDotGrid(dots[0], dots[1], {
            spacing: 100
        });
        gov.currentTrial.grid = grid;
        setTimeout(function () {
            gov.currentTrial.fixationDrawTime.push(performance.now());
            drawFixation(canvasId);
        }, gov.preTrialInterval);
        setTimeout(function(){
            gov.currentTrial.stimulusDrawTime.push(performance.now());
            grid.draw(canvasId);
        }, gov.preTrialInterval+gov.preStimulusInterval);
    }

    /**
     * Draw a fixation cross on *canvasId*
     * @param {string} canvasId - id of the canvas on which to draw
     */
    function drawFixation(canvasId) {
        let ctx = document.querySelector('#'+canvasId).getContext('2d');
        let len = 5;
        ctx.strokeStyle = 'black';
        ctx.lineWidth = '2';
        ctx.beginPath();
        // horizontal
        ctx.moveTo((ctx.canvas.clientWidth/2)-len, ctx.canvas.clientHeight/2);
        ctx.lineTo((ctx.canvas.clientWidth/2)+len, ctx.canvas.clientHeight/2);
        ctx.stroke();
        // vertical
        ctx.strokeStyle = 'black';
        ctx.beginPath();
        ctx.moveTo(ctx.canvas.clientWidth/2, (ctx.canvas.clientHeight/2)-len);
        ctx.lineTo(ctx.canvas.clientWidth/2, (ctx.canvas.clientHeight/2)+len);
        ctx.stroke();
    }

    /**
     * Extract the answer from the plugin's response. The plugin provides indices of the last time a slider was
     * moved; the answer is simply the slider which was moved last.
     *
     * @param {Object} response - response field provided by the jspsych-canvas-sliders-response plugin
     */
    function getAnswerFromResponse(response) {
        // Which slider was moved last?
        let L = response[0].lastChangedTime;
        let R = response[1].lastChangedTime;
        if (isNaN(L) && isNaN(R))
            return NaN;
        if (isNaN(R))
            return 0;
        if (isNaN(L))
            return 1;
        return R > L ? 1 : 0;
    }

    /**
     * Return the confidence score associated with a given slider.
     *
     * @param {Object} response - response field provided by jspsych-canvas-sliders-response plugin
     * @param {int} answer - which slider's value to extract
     */
    function getConfidenceFromResponse(response, answer) {
        if (isNaN(response[answer].answer))
            return NaN;
        return parseInt(response[answer].answer);
    }

    /**
     * Return a list of ESM.Trial objects.
     *
     * A large part of the work of defining the experiment takes place here, although the key properties are
     * actually defined in the Governor definition.
     *
     * The trials defined here are the master list used by the Governor to decide which stimuli to serve,
     * which advisor or choice to offer, etc. This list is **not necessarily the same as** the trial list
     * established at the beginning of the experiment and handed to jsPsych. It is therefore the responsibility
     * of the programmer to ensure that these lists are lawfully aligned such that the block structures, etc.
     * match.
     *
     * A possible alternative strategy - push new trials to the jsPsych timeline at
     * the end of each completed trial. Since we don't get nice progress bar this way we may as well use on-the-fly
     * timeline tweaking. This may just be more work to duplicate jsPsych's capabilities, though
     */
    function getTrials() {
        let trials = [];
        let id = 0;
        let realId = 0;
        let advisorChoices = [2, 3];
        // Shuffle advisors so they appear an equal number of times
        let advisorDeck = shuffleShoe(advisorChoices, gov.blockCount*gov.blockStructure[trialTypes.force]);
        // Same for which side the correct answer appears on
        let whichSideDeck = shuffleShoe([0, 1], gov.blockCount*gov.blockLength);
        // Define trials
        for (let b=1; b<=gov.practiceBlockCount+gov.blockCount; b++) {
            let blockLength = b<=gov.practiceBlockCount? gov.practiceBlockLength : gov.blockLength;
            // intro trials are a special case so the block length needs to be longer to accommodate them
            if (b === 1)
                blockLength += 3;
            // Work out what type of trial to be
            let trialTypeDeck = [];
            let structure = b<=gov.practiceBlockCount? gov.practiceBlockStructure : gov.blockStructure;
            if (b === 1)
                structure = {0:0, 1:5, 2:0};
            for (let tt=0; tt<Object.keys(trialTypes).length; tt++) {
                for (let i=0; i<structure[tt]; i++)
                    trialTypeDeck.push(tt);
            }
            trialTypeDeck = shuffle(trialTypeDeck);
            for (let i=1; i<=blockLength; i++) {
                id++;
                let isPractice = b<=gov.practiceBlockCount;
                let trialType = trialTypeDeck[i-1];
                let advisorId = 0;
                if (isPractice)
                    advisorId = id<=2? 0 : 1;
                else
                    advisorId = trialType === trialTypes.force? advisorDeck[realId] : 0;
                let r = Math.random() < .5? 1 : 0;
                let choice = trialType === trialTypes.choice? [advisorChoices[r], advisorChoices[1-r]] : [];
                trials.push(new ESM.Trial(id, {
                    type: trialType,
                    typeName: trialTypeNames[trialType],
                    block: b,
                    advisorId,
                    choice,
                    answer: [NaN, NaN],
                    confidence: [NaN, NaN],
                    getCorrect: function(finalAnswer = true) {
                        let answer = finalAnswer? this.answer[1] : this.answer[0];
                        return answer === this.whichSide;
                    },
                    whichSide: isPractice? Math.round(Math.random()) : whichSideDeck[realId],
                    practice: isPractice,
                    feedback: isPractice,
                    warnings: [],
                    stimulusDrawTime: [],
                    stimulusOffTime: [],
                    fixationDrawTime: []
                }));
                if (!isPractice)
                    realId++;
            }
        }
        return trials;
    }

    /**
     * Sets a click function on the sliders which makes them behave as if they are moved to 50 when they are focussed.
     * This prevents users clicking on the slider, getting the visual feedback of the slider being activated and set,
     * and then being told they have not moved the slider.
     */
    function setSliderClick() {
        let sliders = document.querySelectorAll('.jspsych-sliders-response-slider');
        sliders.forEach(function (slider) {
            slider.addEventListener('click', function () {
                if (typeof this.clickFunctionRun !== 'undefined')
                    return;
                this.clickFunctionRun = true;
                if (this.value !== "50")
                    return;
                // send a change event
                let event = new Event('change');
                this.dispatchEvent(event);
            });
        });
        drawProgressBar();
    }

    /**
     * Show a ghost of the previous thumb placement to remind judges of their previous answer.
     */
    function showMarker() {
        let slider = document.querySelector('#jspsych-canvas-sliders-response-slider'+
            gov.currentTrial.answer[0].toString());
        let marker = document.createElement('div');
        marker.className = 'advisorChoice-marker';
        slider.parentElement.appendChild(marker);

        let yOffset = slider.getBoundingClientRect().y;
        yOffset -= (marker.clientHeight - slider.clientHeight) / 2;
        yOffset += 1; // compensate for box shadow on the slider making things look off
        marker.style.top = yOffset.toString() + 'px';

        let xOffset = 0;
        if (gov.currentTrial.answer[0] === 0) {
            // Left bar is scored in reverse
            xOffset = 100 - gov.currentTrial.confidence[0];
        } else {
            xOffset = gov.currentTrial.confidence[0];
        }
        marker.style.left = (slider.getBoundingClientRect().x +
            xOffset * (slider.clientWidth-marker.clientWidth) / 100).toString() + 'px';

        // and call the slider-click function because we only get one on_load call
        setSliderClick();
    }

    /**
     * Advisor choice function called by the jspsych-jas-present-advice-choice plugin.
     * Offer a choice of advisors by drawing clickable portraits.
     *
     * @param {HTMLElement} display_element - element within which to display the choices
     * @param {function} callback - function to call when a portrait is clicked. Called with the choice as an argument.
     */
    function getAdvisorChoice(display_element, callback) {
        let choices = gov.currentTrial.choice;
        if (choices.length === 0) { // force and catch trials
            if (typeof gov.currentAdvisor === 'undefined') {
                callback(-1); // catch trials
                return;
            } else {
                callback(gov.currentAdvisor.id); // force trials
                return;
            }
        }
        // present choices
        let choiceImgs = [];
        for (let a=0; a<choices.length; a++) {
            let advisor = gov.advisors[gov.getAdvisorIndex(choices[a])];
            let img = document.createElement('img');
            img.className = 'advisorChoice-choice advisor-portrait';
            img.id = 'advisorChoice-choice-' + a.toString();
            img.src = advisor.portrait.src;
            img.addEventListener('click', function () {
                gov.currentTrial.advisorId = choices[a];
                gov.setAgreementVars();
                callback(choices[a]);
            });
            choiceImgs.push(img);
        }
        let p = document.createElement('p');
        p.innerText = 'Click on a portrait to hear the advisor\'s advice';
        p.className = 'advisorChoice-choice';
        display_element.appendChild(choiceImgs.pop());
        display_element.appendChild(p);
        display_element.appendChild(choiceImgs.pop());
    }

    /**
     * Save the data sent from the plugin in the ESM.Trial object
     *
     * @param {Object} pluginData - response data sent by a jsPsych plugin
     */
    function storePluginData(pluginData) {
        if (Object.keys(gov.currentTrial).indexOf('pluginResponse') === -1)
            gov.currentTrial.pluginResponse = [];
        // Save this trial data (jspsych would do this for us, but we have access to a bunch of stuff it doesn't
        gov.currentTrial.pluginResponse.push(pluginData);
    }

    /**
     * Storage function for any trial not otherwise handled (e.g. breaks, instructions) so we don't lose their timings.
     */
    function storeMiscTrialData(trial) {
        gov.miscTrials.push(trial);
    }

    /**
     * Return the category of the confidence offered in the trial with id *trialId*. Confidence category is 0, 1, or 2
     * depending upon whether the confidence is in the lower 30%, middle 40%, or upper 30% of trials.
     * @param {int} trialId - identifier of the trial
     * @param {Object} [args] - additional options object
     * @param {int} [args.nTrialsBack=null] - maximum number of trials to search
     * @param {boolean} [args.correctOnly=true] - whether to only extract confidence on correct trials
     * @param {boolean} [args.initialAnswerCorrect=true] - whether to test the inital (as opposed to final answer) correctness
     * @param {boolean} [args.initialConfidence=true] - whether to count the initial (as opposed to final) confidence
     */
    function getConfidenceCategory(trialId, args) {
        args = args || {};
        args.nTrialsBack = args.nTrialsBack || null;
        args.correctOnly = typeof args.correctOnly === 'undefined'? true : args.correctOnly;
        args.initialAnswerCorrect = typeof args.initialAnswerCorrect? true : args.initialAnswerCorrect;
        args.initialConfidence = typeof args.initialConfidence? true : args.initialConfidence;
        let trialIndex = gov.trials.indexOf(analysis.getMatches(gov.trials, function (trial) {
            return trial.id === trialId;
        })[0]);
        if (trialIndex === -1) {
            gov.currentTrial.warnings.push('getConfidenceCategory: trial not found in gov.trials');
            return 1;
        }
        let confidenceScore = gov.trials[trialIndex].confidence[(args.initialConfidence? 0 : 1)];

        // collate valid trials
        let validTrials = [];
        for (let i=0; i<args.nTrialsBack; i++) {
            // stop if we run out of trials
            if (i+1 === trialIndex) {
                break;
            }
            let trial = gov.trials[trialIndex-(i+1)];
            // have to have provided a confidence
            if (isNaN(trial.confidence[(args.initialConfidence? 0 : 1)]))
                continue;
            // have to be correct if we want only correct trials
            if (args.correctOnly && trial.answer[(args.initialAnswerCorrect? 0 : 1)] !== trial.whichSide)
                continue;
            validTrials.push(trial);
        }

        // Get confidence list
        let confidenceList = [];
        validTrials.forEach(function (trial) {
            confidenceList.push(trial.confidence[(args.initialConfidence? 0 : 1)]);
        });
        // Put it in order
        confidenceList.sort();
        // Find the markers at 30% and 70%
        let bounds = {
            low: confidenceList[Math.ceil(confidenceList.length*.3)],
            high: confidenceList[Math.floor(confidenceList.length*.7)]
        };
        // Protect against too few trials
        if (typeof bounds.low === 'undefined' || typeof bounds.high === 'undefined' ||
            !bounds.low.length || !bounds.high.length) {
            gov.currentTrial.warnings.push('getConfidenceCategory: too few trials available to estimate confidence');
            return 1;
        }
        if (confidenceScore > bounds.low && confidenceScore < bounds.high)
            return 1;
        if (confidenceScore <= bounds.low)
            return 0;
        if (confidenceScore >= bounds.high)
            return 2;

        // Fallback
        gov.currentTrial.warnings.push('getConfidenceCategory: confidence score ('+confidenceScore+') fell through ' +
            'bounds ['+bounds.low+', '+bounds.high+']');
    }

    /**
     * Get the confidence category of the last response
     * @param {Object} [args] - additional options object
     * @param {int} [args.nTrialsBack=null] - maximum number of trials to search
     * @param {boolean} [args.correctOnly=true] - whether to only extract confidence on correct trials
     * @param {boolean} [args.initialAnswerCorrect=true] - whether to test the inital (as opposed to final answer) correctness
     * @param {boolean} [args.initialConfidence=true] - whether to count the initial (as opposed to final) confidence
     */
    function getLastConfidenceCategory(args) {
        let last = analysis.getMatches(gov.trials, function (trial) {
            return !isNaN(trial.answer[0]);
        }).length-1;

        let cc = gov.getConfidenceCategory(gov.trials[last].id, args);
        gov.trials[last].confidenceCategory = cc;
        return cc;
    }

    /**
     * Process the judge's initial response
     * @param {Object} trial - jsPsych plugin response
     */
    function initialResponse(trial) {
        storePluginData(trial);
        gov.currentTrial.stimulusOffTime.push(trial.stimulusOffTime);
        // trial is the complete trial object with its trial.response object
        gov.currentTrial.answer[0] = getAnswerFromResponse(trial.response);
        gov.currentTrial.confidence[0]  = getConfidenceFromResponse(trial.response, gov.currentTrial.answer[0]);

        if (typeof gov.currentAdvisor === 'undefined' && gov.currentTrial.choice.length === 0) {
            gov.closeTrial(trial);
        } else if (gov.currentTrial.choice.length === 0)
            gov.setAgreementVars();
    }

    /**
     * Determine whether the advisor in this trial is to agree or disagree with the judge
     */
    function setAgreementVars() {
        // Check the answer and dis/agree as appropriate
        if (gov.currentAdvisor.agrees(gov.currentTrial.getCorrect(false), gov.getLastConfidenceCategory())) {
            gov.advice = gov.currentAdvisor.voice.getLineByFunction(function (line) {
                gov.currentTrial.advisorAgrees = true;
                return line.side === gov.currentTrial.whichSide;
            });
        } else {
            gov.advice = gov.currentAdvisor.voice.getLineByFunction(function (line) {
                gov.currentTrial.advisorAgrees = false;
                let side = [1, 0][gov.currentTrial.whichSide];
                return line.side === side;
            });
        }
    }

    /**
     * Process the judge's final response
     * @param {Object} trial - jsPsych plugin response
     */
    function finalResponse(trial) {
        gov.currentTrial.stimulusOffTime.push(trial.stimulusOffTime); // always undefined - no stimulus!
        storePluginData(trial);
        gov.currentTrial.answer[1] = getAnswerFromResponse(trial.response);
        // empty responses are allowed 2nd time through (copy intial response)
        if (isNaN(gov.currentTrial.answer[1])) {
            gov.currentTrial.answer[1] = gov.currentTrial.answer[0];
            gov.currentTrial.confidence[1] = gov.currentTrial.confidence[0];
        } else {
            gov.currentTrial.confidence[1] = getConfidenceFromResponse(trial.response, gov.currentTrial.answer[1]);
        }
        gov.closeTrial(trial);
    }

    /**
     * Wrap up a trial. Store data, staircase difficulty, and prepare next trial.
     * @param {Object} trial - jsPsych plugin response
     */
    function closeTrial(trial) {
        // Feedback
        if (gov.currentTrial.feedback) {
            if (gov.currentTrial.answer[1] === gov.currentTrial.whichSide ||
                (isNaN(gov.currentTrial.answer[1]) && gov.currentTrial.whichSide === gov.currentTrial.answer[0]))
                document.querySelector('body').style.backgroundColor = 'white';
            else
                document.querySelector('body').style.backgroundColor = 'black';
        }
        // Staircasing stuff
        let warning = "";
        if (gov.currentTrialIndex > 1) {
            // two-down one-up staircase
            let lastTrial = gov.trials[gov.currentTrialIndex-1];
            if (!gov.currentTrial.getCorrect(false)) {
                // Wrong! Make it easier
                gov.dotDifference += gov.difficultyStep;
                if (gov.dotDifference > gov.dotCount-1) {
                    gov.dotDifference = gov.dotCount-1;
                    warning = "Difficulty at minimum!";
                }
            } else if (lastTrial.getCorrect(false) && gov.currentTrial.getCorrect(false)) {
                // Two hits, impressive! Make it harder
                gov.dotDifference -= gov.difficultyStep;
                if (gov.dotDifference < 1) {
                    gov.dotDifference = 1;
                    warning = "Difficulty at maximum!";
                }
            }
        }
        if (warning.length > 0 && gov.currentTrialIndex < gov.trials.length) {
            gov.currentTrial.warnings.push(warning);
            console.warn(warning);
        }
        // Move to next trial
        gov.currentTrialIndex++;
    }

    /**
     * Draw a progress bar at the top of the screen
     */
    function drawProgressBar() {
        if (document.querySelector('#jspsych-progressbar-container') === null) {
            let div = document.createElement('div');
            div.id = 'jspsych-progressbar-container';
            let outer = document.createElement('div');
            outer.id = 'progressbar-outer';
            div.appendChild(outer);
            let inner = document.createElement('div');
            inner.id = 'progressbar-inner';
            outer.appendChild(inner);
            let content = document.querySelector('.jspsych-content-wrapper');
            content.parentElement.insertBefore(div, content);
        }
        let inner = document.querySelector('#progressbar-inner');
        inner.style.width = ((gov.trials.indexOf(gov.currentTrial)/gov.trials.length)*100).toString()+'%';

        document.querySelector('body').style.backgroundColor = '';
    }

    /**
     * Draws the questionnaire portrait. Called by the jsPsych plugin
     *
     * @param {HTMLElement} display_element - element within which to draw the portrait
     * @param {Function} callback - function to execute when drawing is complete. Called with the portrait src
     */
    function drawQuestionnaire(display_element, callback) {
        let advisor = gov.advisors[gov.getAdvisorIndex(gov.questionnaireStack.pop())];
        gov.lastQuestionnaireAdvisorId = advisor.id;
        let img = document.createElement('img');
        img.className = 'advisor-portrait';
        img.id = 'advisorChoice-choice-stimulus';
        img.src = advisor.portrait.src;
        display_element.appendChild(img);
        callback(img.src);
    }

    /**
     * Save the response to the questionnaire.
     */
    function questionnaireResponse(trial) {
        if (Object.keys(gov).indexOf('questionnaires') === -1)
            gov.questionnaires = [];
        trial.afterTrial = gov.currentTrialIndex-1;
        trial.advisorId = gov.lastQuestionnaireAdvisorId;
        gov.questionnaires.push(trial);
    }

    /**
     * Send all the data in the governor object to a backend which will save it to a file.
     */
    function exportGovernor() {
        let ask = new XMLHttpRequest();
        ask.open('POST', 'http://localhost:3000/saveData.js');
        ask.setRequestHeader('Content-Type', 'application/json');
        ask.send(JSON.stringify(gov));
    }

    let advisorIdDeck = shuffle([1, 2, 3]);
    let advisorVoiceDeck = shuffle([1, 2, 3]);
    let advisorPicDeck = shuffle([1, 2, 3]);
    let practiceAdvisor = new ESM.Advisor(advisorIdDeck[0], 0, advisorVoiceDeck[0], advisorPicDeck[0]);
    let advisorList = [
        new ESM.Advisor(advisorIdDeck[1], 1, advisorVoiceDeck[1], advisorPicDeck[1]),
        new ESM.Advisor(advisorIdDeck[2], 2, advisorVoiceDeck[2], advisorPicDeck[2])
    ];
    if (Math.random() < .5)
        advisorList = [advisorList[1], advisorList[0]];

    /**
     * The governor contains the properties which the experiment functions need to access from everywhere.
     *
     * The governor serves two key functions: it acts as a master object holding the disparate objects
     * required to run the experiment (e.g. advisors, trials); and it holds miscellaneous temporary
     * variables which are required for things such as staircasing.
    */
    window.gov = new ESM.Governor({
        participantId: (new Date).getTime(),
        dotCount: 200,
        dotDifference: 30,
        difficultyStep: 3,
        advisors: [
            practiceAdvisor,
            advisorList[0],
            advisorList[1]
        ],
        blockCount: 4,
        blockStructure: {
            [trialTypes.catch]: 0,
            [trialTypes.choice]: 6,
            [trialTypes.force]: 6
        },
        blockLength: 0 + 6 + 6,
        practiceBlockCount: 1,
        practiceBlockStructure: {
            [trialTypes.catch]: 0,
            [trialTypes.choice]: 0,
            [trialTypes.force]: 12
        },
        practiceBlockLength: 12,
        preTrialInterval: 200,
        preStimulusInterval: 500,
        stimulusDuration: 200,
        feedbackDuration: 200,
        questionnaireStack: [2, 3, 3, 2, 1],
        miscTrials: [],
        drawDots,
        getConfidenceCategory,
        getLastConfidenceCategory,
        initialResponse,
        finalResponse,
        closeTrial,
        storeMiscTrialData,
        drawProgressBar,
        drawQuestionnaire,
        questionnaireResponse,
        setAgreementVars,
        showMarker,
        storePluginData,
        exportGovernor
    });

    gov.timeStart = gov.participantId;
    gov.trials = getTrials();

    /* create timeline */
    let timeline = [];

    /* define welcome message trial */
    const welcome = {
        type: 'instructions',
        pages: [
            "Welcome to the experiment. Click 'next' to begin.",
            "<p>You will see two boxes containing dots either side of the centre of the screen. " +
            "Your task is to use the slider to decide which of the two boxes has the most dots.</p>"+
            "<p>You make your decision by using the grey bars below the boxes. If you get the decision " +
            "wrong the screen will go <span style='color: black; font-weight: bold;'>black</span> temporarily. " +
            "If you get the decision right, it will go <span style='color: white; font-weight: bold;'>white</span>. " +
            "Click one of the boxes and then press the 'continue' button.</p>" +
            "<p>Click 'next' to proceed.</p>"
        ],
        show_clickable_nav: true,
        on_load: gov.drawProgressBar,
        on_finish: gov.storeMiscTrialData
    };

    const sliderInstructions = {
        type: 'instructions',
        pages: ["<p>Good. The task is very difficult at first, but you will get used to it.</p>" +
            "<p>You can use the slider to indicate your <strong>confidence</strong> as well. " +
            "You do this by moving the slider more towards the edges if you are sure, and more towards the " +
            "middle if you are unsure.</p>" +
            "<p>E.g. if you were <strong>sure</strong> there were more dots on the <strong>left</strong>, you would move the " +
            "<strong>left</strong> slider all the way to the <strong>left</strong>.</p>" +
            "<p>If you thought there were more dots on the <strong>right</strong>, but you were " +
            "<strong>guessing</strong>, you would move the <strong>right</strong> slider, but you would move it as " +
            "far <strong>left</strong> as it will go.</p>" +
            "<p>Try using the slider to indicate your confidence now.</p>"],
        show_clickable_nav: true,
        on_load: gov.drawProgressBar,
        on_finish: gov.storeMiscTrialData
    };

    const adviceInstructions = {
        type: 'instructions',
        pages: ["<p>Most of the time you will get <strong>advice</strong> from an advisor to help you make your " +
            "decision.</p>" +
            "<p>This advice is not always correct, but it is there to help you: if you use the advice you will " +
            "perform better on the task.</p>" +
            "<p>Once you have heard the advice you will have the opportunity to adjust your answer. <strong>" +
            "Your previous answer</strong> is shown by a yellow marker. You are free to adjust your answer to indicate " +
            "that you are more or less sure, and even to change which box you think had most dots.</p>" +
            "<p>Click 'next' to see how the advice works.</p>"],
        show_clickable_nav: true,
        on_load: gov.drawProgressBar,
        on_finish: gov.storeMiscTrialData
    };

    const practiceInstructions = {
        type: 'instructions',
        pages: ["<p>Good.</p><p>The main experiment will start after you have had a bit of practice with " +
            "the task. To continue with the practice, press 'next'.</p>"],
        show_clickable_nav: true,
        on_load: gov.drawProgressBar,
        on_finish: gov.storeMiscTrialData
    };

    const finalInstructions = {
        type: 'instructions',
        pages: ["<p>Excellent. You are now ready to do the experiment.</p>" +
            "<p>From now on, <strong>the boxes will appear very briefly</strong>, so make sure you are " +
            "concentrating or you will miss them.</p>" +
            "<p>Also, sometimes you will be given a <strong>choice of advisor</strong>. When this happens you will see " +
            "two advisors and you will click one to hear their advice.</p>" +
            "<p>Please make sure you are in a comfortable, quiet environment, and click 'next' when you are " +
            "ready to begin.</p>"],
        show_clickable_nav: true,
        on_load: gov.drawProgressBar,
        on_finish: gov.storeMiscTrialData
    };

    const blockBreak = {
        type: 'instructions',
        pages: ["<h1>Break</h1><p>You may take a moment to rest here. Press 'next' when you are ready.</p>"],
        show_clickable_nav: true,
        on_load: gov.drawProgressBar,
        on_finish: gov.storeMiscTrialData
    };

    /* Initial response: present an initial stimulus and get a decision */
    const introInitialDecision = {
        type: "canvas-sliders-response",
        stimulus: gov.drawDots,
        stimulus_duration: null,
        prompt: '<p>Which box had more dots?</p>',
        sliderCount: 2,
        labels: [
            ['Certain', 'Unsure'],
            ['Unsure', 'Certain']
        ],
        slider_prompt: [
            'Left',
            'Right'
        ],
        slider_name: [
            'Left',
            'Right'
        ],
        reversed: [true, false],
        slider_col_spacing: [40],
        exclusive_group: [1, 1],
        require_change: [1, 1],
        canvasWidth: (new ESM.DoubleDotGrid(0,0)).displayWidth*2+100,
        canvasHeight: (new ESM.DoubleDotGrid(0,0)).displayHeight,
        on_load: setSliderClick,
        on_finish: gov.initialResponse,
        post_trial_gap: gov.feedbackDuration
    };

    /* Initial response: present an initial stimulus and get a decision */
    const initialDecision = {
        type: "canvas-sliders-response",
        stimulus: gov.drawDots,
        stimulus_duration: gov.preTrialInterval + gov.preStimulusInterval + gov.stimulusDuration,
        prompt: '<p>Which box had more dots?</p>',
        sliderCount: 2,
        labels: [
            ['Certain', 'Unsure'],
            ['Unsure', 'Certain']
        ],
        slider_prompt: [
            'Left',
            'Right'
        ],
        slider_name: [
            'Left',
            'Right'
        ],
        reversed: [true, false],
        slider_col_spacing: [40],
        exclusive_group: [1, 1],
        require_change: [1, 1],
        canvasWidth: (new ESM.DoubleDotGrid(0,0)).displayWidth*2+100,
        canvasHeight: (new ESM.DoubleDotGrid(0,0)).displayHeight,
        on_load: setSliderClick,
        on_finish: gov.initialResponse
    };

    /* Advice: present advice to the judge */
    const advice = {
        type: "jspsych-jas-present-advice-choice",
        choiceFunction: getAdvisorChoice,
        displayImageFunction: function(choice, divId) {
            let div = document.querySelector('#' + divId);
            let a = gov.currentAdvisor;
            if (typeof a === 'undefined')
                return -1; // special value which tells the present-advice plugin to end early
            div.innerHTML = a.portrait.outerHTML;
            return a.portrait.src;
        },
        trial_duration: 2000,
        playAudioFunction: function (choice) {
            let div = document.querySelector('#jspsych-jas-present-advice-choice-prompt');
            div.innerHTML = gov.currentAdvisor.name.toUpperCase() + ": " + gov.advice.string;
            gov.advice.play();
        },
        prompt: "",
        on_finish: gov.storePluginData,
        on_load: gov.drawProgressBar
    };

    /* Final decision: repeat the initial decision phase to let the judge reconsider their response */
    const finalDecision = {
        type: "canvas-sliders-response",
        stimulus: function(){},
        prompt: '<p>Final decision: Which box had more dots?</p>',
        sliderCount: 2,
        labels: [
            ['Certain', 'Unsure'],
            ['Unsure', 'Certain']
        ],
        slider_prompt: [
            'Left',
            'Right'
        ],
        slider_name: [
            'Left',
            'Right'
        ],
        reversed: [true, false],
        slider_col_spacing: [40],
        exclusive_group: [1, 1],
        canvasWidth: (new ESM.DoubleDotGrid(0,0)).displayWidth*2+100,
        canvasHeight: (new ESM.DoubleDotGrid(0,0)).displayHeight,
        on_load: gov.showMarker,
        on_finish: gov.finalResponse,
        post_trial_gap: gov.feedbackDuration
    };

    /* Questionnaires to ask about how the judge feels about the advisors */
    let order = shuffle([0, 1, 2]);

    const questionnaireProspective = {
        type: "function-sliders-response",
        stimulus: gov.drawQuestionnaire,
        prompt: '<p>This advisor will be...</p>',
        sliderCount: 3,
        slider_name: orderArray([
            'Likeability',
            'Ability',
            'Benevolence'
        ], order),
        labels: orderArray([
            ['Unlikeable', 'Likeable'],
            ['Incompetent', 'Competent'],
            ['Not trying to help', 'Trying to help']
        ], order),
        slider_arrangement: [0, 1, 2],
        require_change: [0, 1, 2],
        on_load: setSliderClick,
        on_finish: gov.questionnaireResponse
    };

    const questionnaire = {
        type: "function-sliders-response",
        stimulus: gov.drawQuestionnaire,
        prompt: '<p>This advisor is...</p>',
        sliderCount: 3,
        slider_name: orderArray([
            'Likeability',
            'Ability',
            'Benevolence'
        ], order),
        labels: orderArray([
            ['Unlikeable', 'Likeable'],
            ['Incompetent', 'Competent'],
            ['Not trying to help', 'Trying to help']
        ], order),
        slider_arrangement: [0, 1, 2],
        require_change: [0, 1, 2],
        on_load: setSliderClick,
        on_finish: gov.questionnaireResponse
    };

    const intro_procedure = {
        timeline: [introInitialDecision, advice, finalDecision],
        randomize_order: false,
        repetitions: 0
    };

    const practice_procedure = {
        timeline: [initialDecision, advice, finalDecision],
        randomize_order: false,
        repetitions: gov.practiceBlockLength
    };

    const test_procedure = {
        timeline: [initialDecision, advice, finalDecision],
        randomize_order: false,
        repetitions: gov.blockLength
    };

    // intro and practice
    timeline.push(welcome);
    timeline.push(introInitialDecision);
    timeline.push(sliderInstructions);
    timeline.push(introInitialDecision);
    timeline.push(adviceInstructions);
    timeline.push(intro_procedure);
    timeline.push(practiceInstructions);

    for (let b=1; b<=gov.practiceBlockCount; b++) {
        timeline.push(practice_procedure);
        if (b===1)
            timeline.push(questionnaire);
        timeline.push(blockBreak);
    }

    timeline.push(finalInstructions);
    timeline.push(questionnaireProspective);
    timeline.push(questionnaireProspective);

    // real experiment
    for (let b=1; b<=gov.blockCount; b++) {
        timeline.push(test_procedure);
        timeline.push(blockBreak);
    }

    // Remove the last break screen
    timeline.pop();

    timeline.push(questionnaire);
    timeline.push(questionnaire);

    /* define debrief */
    const debrief_block = {
        type: "html-keyboard-response",
        stimulus: function() {
            return "<p>You did it beautifully!</p>"+
                "<p>Press any key to end.</p>"
        }
    };
    //timeline.push(debrief_block);

    /* start the experiment */
    jsPsych.init({
        timeline: timeline,
        on_finish: function() {
            gov.timeEnd = (new Date()).getTime();
            // reset background colour
            document.querySelector('body').style.backgroundColor = '';
            gov.exportGovernor();
            feedback(gov);
        }
    });
    /*x =JSON.parse(DATA_IN);
    Object.keys(x).forEach(function (key) {gov[key] = x[key]});
    gov.exportGovernor();
    feedback(gov);*/
    function feedback(data) {
        google.charts.load('current', {'packages':['corechart']});
        google.charts.setOnLoadCallback(function(){analysis.advisorChoice.showFeedback(data)});
    }

</script>
</html>
