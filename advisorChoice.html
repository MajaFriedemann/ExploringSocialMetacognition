<!DOCTYPE html>
<html>
<head>
    <title>My experiment</title>
    <script src="../jsPsych/jspsych.js"></script>
    <script src="../jsPsych/plugins/jspsych-instructions.js"></script>
    <script src="../jsPsych/plugins/jspsych-html-keyboard-response.js"></script>
    <script src="../jsPsych/plugins/jspsych-canvas-sliders-response.js"></script>
    <script src="exploringSocialMetacognition.js"></script>
    <script src="jspsych-jas-present-advice.js"></script>
    <link rel="stylesheet" href="../jsPsych/css/jspsych.css"/>
    <link rel="stylesheet" href="confidenceSliders.css"/>
    <style type="text/css">
        div.advisorChoice-marker {
            width: 12px;
            height: 40px;
            position: relative;
            z-index: -1;
            box-shadow: 0px 0px 5px 1px yellow;
            border-radius: 3px;
        }
    </style>
</head>
<body style="background-color: #858585;"></body>
<script type="text/javascript">
    // This function does the actual drawing on the canvas, and is the one
    // called by the trial (it is passed in as a stimulus and called with
    // the id of the canvas supplied).
    // At the moment this doesn't do anything exciting; it just presents
    // 200 dots in random places in the box, but we could make it staircase
    // the number of dots based on past performance, etc.
    function drawDots(canvasId) {
        let low = gov.dotCount - gov.dotDifference;
        let high = gov.dotCount + gov.dotDifference;
        let dots = gov.currentTrial.whichSide === 0 ? [high, low] : [low, high];
        let grid = new ESM.DoubleDotGrid(dots[0], dots[1]);
        gov.currentTrial.grid = grid;
        grid.draw(canvasId);
    }

    function getAnswerFromResponse(response) {
        // Which slider was moved last?
        let L = response[0].lastChangedTime;
        let R = response[1].lastChangedTime;
        if (isNaN(L) && isNaN(R))
            return NaN;
        if (isNaN(R))
            return 0;
        if (isNaN(L))
            return 1;
        return R > L ? 1 : 0;
    }

    function getConfidenceFromResponse(response, answer) {
        if (isNaN(response[answer].answer))
            return NaN;
        return parseInt(response[answer].answer);
    }

    function getTrials (trialCount) {
        let trials = [];
        let blockLength = 5;
           for (let id=0; id<trialCount; id++) {
               trials.push(new ESM.Trial(id, {
                   whichSide: Math.random() < 0.5? 0 : 1,
                   block: Math.ceil(id / blockLength),
                   answer: [NaN, NaN],
                   confidence: [NaN, NaN],
                   getCorrect: function(finalAnswer = true) {
                       let answer = finalAnswer? this.answer[1] : this.answer[0];
                       return answer === this.whichSide;
                   },
                   warnings: []
               }));
           }
        return trials;
    }

    /**
     * Sets a click function on the sliders which makes them behave as if they are moved to 50 when they are focussed.
     * This prevents users clicking on the slider, getting the visual feedback of the slider being activated and set,
     * and then being told they have not moved the slider.
     */
    function setSliderClick() {
        let sliders = document.querySelectorAll('.jspsych-sliders-response-slider');
        sliders.forEach(function (slider) {
            slider.addEventListener('click', function () {
                if (typeof this.clickFunctionRun !== 'undefined')
                    return;
                this.clickFunctionRun = true;
                if (this.value !== "50")
                    return;
                // send a change event
                let event = new Event('change');
                this.dispatchEvent(event);
            });
        });
    }

    /**
     * Show a ghost of the previous thumb placement to remind judges of their previous answer.
     */
    function showMarker() {
        let slider = document.querySelector('#jspsych-canvas-sliders-response-slider'+
            gov.currentTrial.answer[0].toString());
        let marker = document.createElement('div');
        marker.className = 'advisorChoice-marker';
        slider.parentElement.appendChild(marker);
        let yOffset = document.querySelector('#jspsych-canvas-sliders-response-labels'+
            gov.currentTrial.answer[0].toString()).clientHeight;
        yOffset += slider.clientHeight + 18; // +18 for the margin
        yOffset *= -1;
        yOffset -= (marker.clientHeight - slider.clientHeight) / 2;
        yOffset += 1; // compensate for box shadow on the slider making things look off
        marker.style.top = yOffset.toString() + 'px';
        let xOffset = 0;
        if (gov.currentTrial.answer[0] === 0) {
            // Left bar is scored in reverse
            xOffset = 100 - gov.currentTrial.confidence[0];
        } else {
            xOffset = gov.currentTrial.confidence[0];
        }
        marker.style.left = (xOffset * slider.clientWidth / 100).toString() + 'px';

        // and call the slider-click function because we only get one on_load call
        setSliderClick();
    }

    // The governor contains the properties which the experiment functions need to access from everywhere.
    window.gov = new ESM.Governor({
        dotCount: 200,
        dotDifference: 30,
        difficultyStep: 3,
        advisors: [
            new ESM.Advisor(1,1),
            new ESM.Advisor(2,2),
            new ESM.Advisor(3,0)
        ],
        currentAdvisorIndex: 1,
        initialResponse: function (trial) {
            // trial is the complete trial object with its trial.response object
            gov.currentTrial.answer[0] = getAnswerFromResponse(trial.response);
            gov.currentTrial.confidence[0]  = getConfidenceFromResponse(trial.response, gov.currentTrial.answer[0]);

            // Check the answer and dis/agree as appropriate
            if (gov.currentAdvisor.agrees(gov.currentTrial.getCorrect(false), 1)) {
                gov.advice = gov.currentAdvisor.voice.getLineByFunction(function (line) {
                    return line.side === gov.currentTrial.whichSide;
                });
            } else {
                gov.advice = gov.currentAdvisor.voice.getLineByFunction(function (line) {
                    let side = [1, 0][gov.currentTrial.whichSide];
                    return line.side === side;
                });
            }
        },
        finalResponse: function (trial) {
            gov.currentTrial.answer[1] = getAnswerFromResponse(trial.response);
            // empty responses are allowed 2nd time through (copy intial response)
            if (isNaN(gov.currentTrial.answer[1])) {
                gov.currentTrial.answer[1] = gov.currentTrial.answer[0];
                gov.currentTrial.confidence[1] = gov.currentTrial.confidence[0];
            } else {
                gov.currentTrial.confidence[1]  = getConfidenceFromResponse(trial.response, gov.currentTrial.answer[1]);
            }
            // Staircasing stuff
            let warning = "";
            if (gov.currentTrialIndex > 1) {
                // two-down one-up staircase
                let lastTrial = gov.trials[gov.currentTrialIndex-1];
                if (!gov.currentTrial.getCorrect(false)) {
                    // Wrong! Make it easier
                    gov.dotDifference += gov.difficultyStep;
                    if (gov.dotDifference > gov.dotCount-1) {
                        gov.dotDifference = gov.dotCount-1;
                        warning = "Difficulty at minimum!";
                    }
                } else if (lastTrial.getCorrect(false) && gov.currentTrial.getCorrect(false)) {
                    // Two hits, impressive! Make it harder
                    gov.dotDifference -= gov.difficultyStep;
                    if (gov.dotDifference < 1) {
                        gov.dotDifference = 1;
                        warning = "Difficulty at maximum!";
                    }
                }
            }
            gov.currentTrialIndex++;
            if (warning.length > 0 && gov.currentTrialIndex < gov.trials.length) {
                gov.currentTrial.warnings.push(warning);
                console.warn(warning);
            }
        },
        trials: getTrials(5)
    });

    /* create timeline */
    let timeline = [];

    /* define welcome message trial */
    const welcome = {
        type: 'instructions',
        pages: [
            "Welcome to the experiment. Press any key to begin.",
            "<p>In this experiment, a box with dots will appear in the center"+
            " of the screen. Your task is to use the slider to give an estimate "+
            "of the number of dots that are in the box.</p>"+
            "<p>You will not know how many dots there can be in the box, except "+
            "by observing the boxes on each trial; nevertheless, you should try "+
            "to use the whole width of the scale, indicating the smallest "+
            "number of dots by using the left side and the largest number by "+
            "using the right side.</p>"
        ],
        show_clickable_nav: true,
    };
    //timeline.push(welcome);

    /* Initial response: present an initial stimulus and get a decision */
    const initialDecision = {
        type: "canvas-sliders-response",
        stimulus: drawDots,
        stimulus_duration: null,
        prompt: '<p>Which box had more dots?</p>',
        sliderCount: 2,
        labels: [
            ['Certain', 'Unsure'],
            ['Unsure', 'Certain']
        ],
        slider_prompt: [
            'Left',
            'Right'
        ],
        reversed: [true, false],
        slider_col_spacing: [40],
        exclusive_group: [1, 1],
        require_change: [1, 1],
        canvasWidth: 370,
        canvasHeight: 172,
        on_load: setSliderClick,
        on_finish: gov.initialResponse
    };

    /* Advice: present advice to the judge */
    const advice = {
        type: "jspsych-jas-present-advice",
        displayImageFunction: function(divId) {
            let div = document.querySelector('#' + divId);
            let a = gov.currentAdvisor;
            div.innerHTML = a.portrait.outerHTML;
            return a.portrait.src;
        },
        trial_duration: 2000,
        playAudioFunction: function () {
            let div = document.querySelector('#jspsych-jas-present-advice-prompt');
            div.innerHTML = gov.currentAdvisor.name.toUpperCase() + ": " + gov.advice.string;
            gov.advice.play();
        },
        prompt: ""
    };

    /* Final decision: repeat the initial decision phase to let the judge reconsider their response */
    let finalDecision = {
        type: "canvas-sliders-response",
        stimulus: function(){},
        prompt: '<p>Final decision:<br/>Which box had more dots?</p>',
        sliderCount: 2,
        labels: [
            ['Certain', 'Unsure'],
            ['Unsure', 'Certain']
        ],
        slider_prompt: [
            'Left',
            'Right'
        ],
        reversed: [true, false],
        slider_col_spacing: [40],
        exclusive_group: [1, 1],
        canvasWidth: 370,
        canvasHeight: 172,
        on_load: showMarker,
        on_finish: gov.finalResponse
    };

    const test_procedure = {
        timeline: [initialDecision, advice, finalDecision],
        randomize_order: false,
        repetitions: gov.trials.length
    };
    timeline.push(test_procedure);

    /* define debrief */

    let debrief_block = {
        type: "html-keyboard-response",
        stimulus: function() {
            return "<p>You did it beautifully!</p>"+
                "<p>Press any key to end.</p>"
        }
    };
    timeline.push(debrief_block);

    /* start the experiment */
    jsPsych.init({
        timeline: timeline,
        on_finish: function() {
            jsPsych.data.displayData();
        }
    });
</script>
</html>
