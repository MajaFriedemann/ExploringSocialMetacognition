<!DOCTYPE html>
<html>
<head>
    <title>My experiment</title>
    <script src="../jsPsych/jspsych.js"></script>
    <script src="../jsPsych/plugins/jspsych-instructions.js"></script>
    <script src="../jsPsych/plugins/jspsych-html-keyboard-response.js"></script>
    <script src="../jsPsych/plugins/jspsych-canvas-sliders-response.js"></script>
    <script src="exploringSocialMetacognition.js"></script>
    <script src="jspsych-jas-present-advice-choice.js"></script>
    <link rel="stylesheet" href="../jsPsych/css/jspsych.css"/>
    <link rel="stylesheet" href="confidenceSliders.css"/>
    <style type="text/css">
        div.advisorChoice-marker {
            width: 12px;
            height: 40px;
            position: relative;
            z-index: -1;
            box-shadow: 0px 0px 5px 0px yellow;
            border-radius: 3px;
            background-color: yellow;
        }
        img.advisor-portrait {
            border: 2px solid black;
            padding: 5px;
            background-color: black;
            border-radius: 25px;
        }
        img.advisorChoice-choice {
            max-height: 150px;
            display: block;
            margin: 20px auto;
        }
        img.advisorChoice-choice:hover {
            cursor: pointer;
            background-color: white;
        }
    </style>
</head>
<body style="background-color: #858585;"></body>
<script type="text/javascript">
    const trialTypes = {
        catch: 0,
        force: 1,
        choice: 2
    };

    // This function does the actual drawing on the canvas, and is the one
    // called by the trial (it is passed in as a stimulus and called with
    // the id of the canvas supplied).
    // At the moment this doesn't do anything exciting; it just presents
    // 200 dots in random places in the box, but we could make it staircase
    // the number of dots based on past performance, etc.
    function drawDots(canvasId) {
        let low = gov.dotCount - gov.dotDifference;
        let high = gov.dotCount + gov.dotDifference;
        let dots = gov.currentTrial.whichSide === 0 ? [high, low] : [low, high];
        let grid = new ESM.DoubleDotGrid(dots[0], dots[1]);
        gov.currentTrial.grid = grid;
        grid.draw(canvasId);
    }

    function getAnswerFromResponse(response) {
        // Which slider was moved last?
        let L = response[0].lastChangedTime;
        let R = response[1].lastChangedTime;
        if (isNaN(L) && isNaN(R))
            return NaN;
        if (isNaN(R))
            return 0;
        if (isNaN(L))
            return 1;
        return R > L ? 1 : 0;
    }

    function getConfidenceFromResponse(response, answer) {
        if (isNaN(response[answer].answer))
            return NaN;
        return parseInt(response[answer].answer);
    }

    function getTrials() {
        let trials = [];
        let id = 0;
        let realId = 0;
        let advisorChoices = [2, 3];
        // Shuffle advisors so they appear an equal number of times
        let advisorDeck = shuffleShoe(advisorChoices, gov.blockCount*gov.blockStructure[trialTypes.force]);
        // Same for which side the correct answer appears on
        let whichSideDeck = shuffleShoe([0, 1], gov.blockCount*gov.blockLength);
        // Define trials
        for (let b=1; b<=gov.practiceBlockCount+gov.blockCount; b++) {
            let blockLength = b<=gov.practiceBlockCount? gov.practiceBlockLength : gov.blockLength;
            // intro trials are a special case so the block length needs to be longer to accommodate them
            if (b === 1)
                blockLength += 3;
            // Work out what type of trial to be
            let trialTypeDeck = [];
            let structure = b<=gov.practiceBlockCount? gov.practiceBlockStructure : gov.blockStructure;
            if (b === 1)
                structure = {0:0, 1:5, 2:0};
            for (let tt=0; tt<Object.keys(trialTypes).length; tt++) {
                for (let i=0; i<structure[tt]; i++)
                    trialTypeDeck.push(tt);
            }
            trialTypeDeck = shuffle(trialTypeDeck);
            for (let i=1; i<=blockLength; i++) {
                id++;
                let isPractice = b<=gov.practiceBlockCount;
                let trialType = trialTypeDeck[i-1];
                let advisorId = 0;
                if (isPractice)
                    advisorId = id<=2? 0 : 1;
                else
                    advisorId = trialType === trialTypes.force? advisorDeck[realId] : 0;
                let r = Math.random() < .5? 1 : 0;
                let choice = trialType === trialTypes.choice? [advisorChoices[r], advisorChoices[1-r]] : [];
                trials.push(new ESM.Trial(id, {
                    type: trialType,
                    block: b,
                    advisorId,
                    choice,
                    answer: [NaN, NaN],
                    confidence: [NaN, NaN],
                    getCorrect: function(finalAnswer = true) {
                        let answer = finalAnswer? this.answer[1] : this.answer[0];
                        return answer === this.whichSide;
                    },
                    whichSide: isPractice? Math.round(Math.random()) : whichSideDeck[realId],
                    practice: isPractice,
                    warnings: []
                }));
                if (!isPractice)
                    realId++;
            }
        }
        return trials;
    }

    /**
     * Sets a click function on the sliders which makes them behave as if they are moved to 50 when they are focussed.
     * This prevents users clicking on the slider, getting the visual feedback of the slider being activated and set,
     * and then being told they have not moved the slider.
     */
    function setSliderClick() {
        let sliders = document.querySelectorAll('.jspsych-sliders-response-slider');
        sliders.forEach(function (slider) {
            slider.addEventListener('click', function () {
                if (typeof this.clickFunctionRun !== 'undefined')
                    return;
                this.clickFunctionRun = true;
                if (this.value !== "50")
                    return;
                // send a change event
                let event = new Event('change');
                this.dispatchEvent(event);
            });
        });
    }

    /**
     * Show a ghost of the previous thumb placement to remind judges of their previous answer.
     */
    function showMarker() {
        let slider = document.querySelector('#jspsych-canvas-sliders-response-slider'+
            gov.currentTrial.answer[0].toString());
        let marker = document.createElement('div');
        marker.className = 'advisorChoice-marker';
        slider.parentElement.appendChild(marker);
        let yOffset = document.querySelector('#jspsych-canvas-sliders-response-labels'+
            gov.currentTrial.answer[0].toString()).clientHeight;
        yOffset += slider.clientHeight + 18; // +18 for the margin
        yOffset *= -1;
        yOffset -= (marker.clientHeight - slider.clientHeight) / 2;
        yOffset += 1; // compensate for box shadow on the slider making things look off
        marker.style.top = yOffset.toString() + 'px';
        let xOffset = 0;
        if (gov.currentTrial.answer[0] === 0) {
            // Left bar is scored in reverse
            xOffset = 100 - gov.currentTrial.confidence[0];
        } else {
            xOffset = gov.currentTrial.confidence[0];
        }
        marker.style.left = (xOffset * (slider.clientWidth-marker.clientWidth) / 100).toString() + 'px';

        // and call the slider-click function because we only get one on_load call
        setSliderClick();
    }

    function getAdvisorChoice(callback, display_element) {
        let choices = gov.currentTrial.choice;
        if (choices.length === 0) { // force and catch trials
            if (typeof gov.currentAdvisor === 'undefined') {
                callback(-1); // catch trials
                return;
            } else {
                callback(gov.currentAdvisor.id); // force trials
                return;
            }
        }
        // present choices
        let choiceImgs = [];
        for (let a=0; a<choices.length; a++) {
            let advisor = gov.advisors[gov.getAdvisorIndex(choices[a])];
            let img = document.createElement('img');
            img.className = 'advisorChoice-choice advisor-portrait';
            img.id = 'advisorChoice-choice-' + a.toString();
            img.src = advisor.portrait.src;
            img.addEventListener('click', function () {
                gov.currentTrial.advisorId = choices[a];
                gov.setAgreementVars();
                callback(choices[a]);
            });
            choiceImgs.push(img);
        }
        let p = document.createElement('p');
        p.innerText = 'Click on a portrait to hear the advisor\'s advice';
        p.className = 'advisorChoice-choice';
        display_element.appendChild(choiceImgs.pop());
        display_element.appendChild(p);
        display_element.appendChild(choiceImgs.pop());
    }

    let adviceTypes = shuffle([1, 2]);
    // The governor contains the properties which the experiment functions need to access from everywhere.
    window.gov = new ESM.Governor({
        dotCount: 200,
        dotDifference: 30,
        difficultyStep: 3,
        advisors: [
            new ESM.Advisor(1,0),
            new ESM.Advisor(2,1),
            new ESM.Advisor(3,2)
        ],
        initialResponse: function (trial) {
            // trial is the complete trial object with its trial.response object
            gov.currentTrial.answer[0] = getAnswerFromResponse(trial.response);
            gov.currentTrial.confidence[0]  = getConfidenceFromResponse(trial.response, gov.currentTrial.answer[0]);

            if (typeof gov.currentAdvisor === 'undefined' && gov.currentTrial.choice.length === 0) {
                gov.closeTrial(trial);
                return;
            } else if (gov.currentTrial.choice.length === 0)
                gov.setAgreementVars();
        },
        finalResponse: function (trial) {
            gov.currentTrial.answer[1] = getAnswerFromResponse(trial.response);
            // empty responses are allowed 2nd time through (copy intial response)
            if (isNaN(gov.currentTrial.answer[1])) {
                gov.currentTrial.answer[1] = gov.currentTrial.answer[0];
                gov.currentTrial.confidence[1] = gov.currentTrial.confidence[0];
            } else {
                gov.currentTrial.confidence[1] = getConfidenceFromResponse(trial.response, gov.currentTrial.answer[1]);
            }
            gov.closeTrial(trial);
        },
        closeTrial: function (trial) {
            // Staircasing stuff
            let warning = "";
            if (gov.currentTrialIndex > 1) {
                // two-down one-up staircase
                let lastTrial = gov.trials[gov.currentTrialIndex-1];
                if (!gov.currentTrial.getCorrect(false)) {
                    // Wrong! Make it easier
                    gov.dotDifference += gov.difficultyStep;
                    if (gov.dotDifference > gov.dotCount-1) {
                        gov.dotDifference = gov.dotCount-1;
                        warning = "Difficulty at minimum!";
                    }
                } else if (lastTrial.getCorrect(false) && gov.currentTrial.getCorrect(false)) {
                    // Two hits, impressive! Make it harder
                    gov.dotDifference -= gov.difficultyStep;
                    if (gov.dotDifference < 1) {
                        gov.dotDifference = 1;
                        warning = "Difficulty at maximum!";
                    }
                }
            }
            if (warning.length > 0 && gov.currentTrialIndex < gov.trials.length) {
                gov.currentTrial.warnings.push(warning);
                console.warn(warning);
            }
            // Move to next trial
            gov.currentTrialIndex++;
            if (gov.currentTrialIndex > gov.trials.length) {
                gov.currentTrialIndex = 0; // reset to 0
                console.warn('gov: Reset currentTrialIndex!')
            }

        },
        setAgreementVars: function () {
            // Check the answer and dis/agree as appropriate
            if (gov.currentAdvisor.agrees(gov.currentTrial.getCorrect(false), 1)) {
                gov.advice = gov.currentAdvisor.voice.getLineByFunction(function (line) {
                    gov.currentTrial.advisorAgrees = true;
                    return line.side === gov.currentTrial.whichSide;
                });
            } else {
                gov.advice = gov.currentAdvisor.voice.getLineByFunction(function (line) {
                    gov.currentTrial.advisorAgrees = false;
                    let side = [1, 0][gov.currentTrial.whichSide];
                    return line.side === side;
                });
            }
        },
        blockCount: 2,
        blockStructure: {
            [trialTypes.catch]: 0,
            [trialTypes.choice]: 2,
            [trialTypes.force]: 2
        },
        blockLength: 0 + 2 + 2,
        practiceBlockCount: 1,
        practiceBlockStructure: {
            [trialTypes.catch]: 0,
            [trialTypes.choice]: 0,
            [trialTypes.force]: 2
        },
        practiceBlockLength: 2
    });

    gov.trials = getTrials();

    /* create timeline */
    let timeline = [];

    /* define welcome message trial */
    const welcome = {
        type: 'instructions',
        pages: [
            "Welcome to the experiment. Press any key to begin.",
            "<p>You will see two boxes containing dots either side of the centre of the screen. " +
            "Your task is to use the slider to decide which of the two boxes has the most dots.</p>"+
            "<p>You make your decision by using the grey bars below the boxes. Click one of the boxes and then " +
            "press the 'continue' button.</p>"
        ],
        show_clickable_nav: true
    };

    const sliderInstructions = {
        type: 'instructions',
        pages: ["<p>Good. The task is very difficult at first, but you will get used to it.</p>" +
            "<p>You can use the slider to indicate your <strong>confidence</strong> as well. " +
            "You do this by moving the slider more towards the edges if you are sure, and more towards the " +
            "middle if you are unsure.</p>" +
            "<p>E.g. if you were <strong>sure</strong> there were more dots on the <strong>left</strong>, you would move the " +
            "<strong>left</strong> slider all the way to the <strong>left</strong>.</p>" +
            "<p>If you thought there were more dots on the <strong>right</strong>, but you were " +
            "<strong>guessing</strong>, you would move the <strong>right</strong> slider, but you would move it as " +
            "far <strong>left</strong> as it will go.</p>" +
            "<p>Try using the slider to indicate your confidence now.</p>"],
        show_clickable_nav: true
    };

    const adviceInstructions = {
        type: 'instructions',
        pages: ["<p>Most of the time you will get <strong>advice</strong> from an advisor to help you make your " +
            "decision.</p>" +
            "<p>This advice is not always correct, but it is there to help you: if you use the advice you will " +
            "perform better on the task.</p>" +
            "<p>Once you have heard the advice you will have the opportunity to adjust your answer. <strong>" +
            "Your previous answer</strong> is shown by a yellow marker. You are free to adjust your answer to indicate " +
            "that you are more or less sure, and even to change which box you think had most dots.</p>" +
            "<p>Click 'next' to see how the advice works.</p>"],
        show_clickable_nav: true
    };

    const finalInstructions = {
        type: 'instructions',
        pages: ["<p>Excellent. You are now ready to do the experiment.</p>" +
            "<p>Please make sure you are in a comfortable, quiet environment, and click 'next' when you are " +
            "ready to begin.</p>"],
        show_clickable_nav: true
    };

    const blockBreak = {
        type: 'instructions',
        pages: ["<h1>Break</h1><p>You may take a moment to rest here. Press 'next' when you are ready.</p>"],
        show_clickable_nav: true
    };

    /* Initial response: present an initial stimulus and get a decision */
    const initialDecision = {
        type: "canvas-sliders-response",
        stimulus: drawDots,
        stimulus_duration: 200,
        prompt: '<p>Which box had more dots?</p>',
        sliderCount: 2,
        labels: [
            ['Certain', 'Unsure'],
            ['Unsure', 'Certain']
        ],
        slider_prompt: [
            'Left',
            'Right'
        ],
        reversed: [true, false],
        slider_col_spacing: [40],
        exclusive_group: [1, 1],
        require_change: [1, 1],
        canvasWidth: 370,
        canvasHeight: 172,
        on_load: setSliderClick,
        on_finish: gov.initialResponse
    };

    /* Advice: present advice to the judge */
    const advice = {
        type: "jspsych-jas-present-advice-choice",
        choiceFunction: getAdvisorChoice,
        displayImageFunction: function(choice, divId) {
            let div = document.querySelector('#' + divId);
            let a = gov.currentAdvisor;
            if (typeof a === 'undefined')
                return -1; // special value which tells the present-advice plugin to end early
            div.innerHTML = a.portrait.outerHTML;
            return a.portrait.src;
        },
        trial_duration: 2000,
        playAudioFunction: function (choice) {
            let div = document.querySelector('#jspsych-jas-present-advice-choice-prompt');
            div.innerHTML = gov.currentAdvisor.name.toUpperCase() + ": " + gov.advice.string;
            gov.advice.play();
        },
        prompt: ""
    };

    /* Final decision: repeat the initial decision phase to let the judge reconsider their response */
    let finalDecision = {
        type: "canvas-sliders-response",
        stimulus: function(){},
        prompt: '<p>Final decision:<br/>Which box had more dots?</p>',
        sliderCount: 2,
        labels: [
            ['Certain', 'Unsure'],
            ['Unsure', 'Certain']
        ],
        slider_prompt: [
            'Left',
            'Right'
        ],
        reversed: [true, false],
        slider_col_spacing: [40],
        exclusive_group: [1, 1],
        canvasWidth: 370,
        canvasHeight: 172,
        on_load: showMarker,
        on_finish: gov.finalResponse
    };

    const intro_procedure = {
        timeline: [initialDecision, advice, finalDecision],
        randomize_order: false,
        repetitions: 0
    };

    const practice_procedure = {
        timeline: [initialDecision, advice, finalDecision],
        randomize_order: false,
        repetitions: gov.practiceBlockLength
    };

    const test_procedure = {
        timeline: [initialDecision, advice, finalDecision],
        randomize_order: false,
        repetitions: gov.blockLength
    };

    // intro and practice
    timeline.push(welcome);
    timeline.push(initialDecision);
    timeline.push(sliderInstructions);
    timeline.push(initialDecision);
    timeline.push(adviceInstructions);
    timeline.push(intro_procedure);
    timeline.push(finalInstructions);

    for (let b=1; b<=gov.practiceBlockCount; b++) {
        timeline.push(practice_procedure);
        timeline.push(blockBreak);
    }

    // real experiment
    for (let b=1; b<=gov.blockCount; b++) {
        timeline.push(test_procedure);
        timeline.push(blockBreak);
    }

    // Remove the last break screen
    timeline.pop();

    /* define debrief */
    let debrief_block = {
        type: "html-keyboard-response",
        stimulus: function() {
            return "<p>You did it beautifully!</p>"+
                "<p>Press any key to end.</p>"
        }
    };
    timeline.push(debrief_block);

    /* start the experiment */
    jsPsych.init({
        timeline: timeline,
        on_finish: function() {
            jsPsych.data.displayData();
        }
    });
</script>
</html>
